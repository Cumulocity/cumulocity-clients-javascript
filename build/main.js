"use strict";

(function() {
    function baseIndexOf(array, value, fromIndex) {
        for (var index = (fromIndex || 0) - 1, length = array ? array.length : 0; ++index < length; ) if (array[index] === value) return index;
        return -1;
    }
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        if (cache = cache.cache, "boolean" == type || null == value) return cache[value] ? 0 : -1;
        "number" != type && "string" != type && (type = "object");
        var key = "number" == type ? value : keyPrefix + value;
        return cache = (cache = cache[type]) && cache[key], "object" == type ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if ("boolean" == type || null == value) cache[value] = !0; else {
            "number" != type && "string" != type && (type = "object");
            var key = "number" == type ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            "object" == type ? (typeCache[key] || (typeCache[key] = [])).push(value) : typeCache[key] = !0;
        }
    }
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    function compareAscending(a, b) {
        for (var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length; ++index < length; ) {
            var value = ac[index], other = bc[index];
            if (value !== other) {
                if (value > other || "undefined" == typeof value) return 1;
                if (other > value || "undefined" == typeof other) return -1;
            }
        }
        return a.index - b.index;
    }
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && "object" == typeof first && mid && "object" == typeof mid && last && "object" == typeof last) return !1;
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache.undefined = !1;
        var result = getObject();
        for (result.array = array, result.cache = cache, result.push = cachePush; ++index < length; ) result.push(array[index]);
        return result;
    }
    function escapeStringChar(match) {
        return "\\" + stringEscapes[match];
    }
    function getArray() {
        return arrayPool.pop() || [];
    }
    function getObject() {
        return objectPool.pop() || {
            array: null,
            cache: null,
            criteria: null,
            "false": !1,
            index: 0,
            "null": !1,
            number: null,
            object: null,
            push: null,
            string: null,
            "true": !1,
            undefined: !1,
            value: null
        };
    }
    function releaseArray(array) {
        array.length = 0, arrayPool.length < maxPoolSize && arrayPool.push(array);
    }
    function releaseObject(object) {
        var cache = object.cache;
        cache && releaseObject(cache), object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null, 
        objectPool.length < maxPoolSize && objectPool.push(object);
    }
    function slice(array, start, end) {
        start || (start = 0), "undefined" == typeof end && (end = array ? array.length : 0);
        for (var index = -1, length = end - start || 0, result = Array(0 > length ? 0 : length); ++index < length; ) result[index] = array[start + index];
        return result;
    }
    function runInContext(context) {
        function lodash(value) {
            return value && "object" == typeof value && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
        }
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll, this.__wrapped__ = value;
        }
        function baseBind(bindData) {
            function bound() {
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if (this instanceof bound) {
                    var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisArg, args || arguments);
            }
            var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
            return setBindData(bound, bindData), bound;
        }
        function baseClone(value, isDeep, callback, stackA, stackB) {
            if (callback) {
                var result = callback(value);
                if ("undefined" != typeof result) return result;
            }
            var isObj = isObject(value);
            if (!isObj) return value;
            var className = toString.call(value);
            if (!cloneableClasses[className]) return value;
            var ctor = ctorByClass[className];
            switch (className) {
              case boolClass:
              case dateClass:
                return new ctor(+value);

              case numberClass:
              case stringClass:
                return new ctor(value);

              case regexpClass:
                return result = ctor(value.source, reFlags.exec(value)), result.lastIndex = value.lastIndex, 
                result;
            }
            var isArr = isArray(value);
            if (isDeep) {
                var initedStack = !stackA;
                stackA || (stackA = getArray()), stackB || (stackB = getArray());
                for (var length = stackA.length; length--; ) if (stackA[length] == value) return stackB[length];
                result = isArr ? ctor(value.length) : {};
            } else result = isArr ? slice(value) : assign({}, value);
            return isArr && (hasOwnProperty.call(value, "index") && (result.index = value.index), 
            hasOwnProperty.call(value, "input") && (result.input = value.input)), isDeep ? (stackA.push(value), 
            stackB.push(result), (isArr ? forEach : forOwn)(value, function(objValue, key) {
                result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
            }), initedStack && (releaseArray(stackA), releaseArray(stackB)), result) : result;
        }
        function baseCreate(prototype, properties) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        function baseCreateCallback(func, thisArg, argCount) {
            if ("function" != typeof func) return identity;
            if ("undefined" == typeof thisArg || !("prototype" in func)) return func;
            var bindData = func.__bindData__;
            if ("undefined" == typeof bindData && (support.funcNames && (bindData = !func.name), 
            bindData = bindData || !support.funcDecomp, !bindData)) {
                var source = fnToString.call(func);
                support.funcNames || (bindData = !reFuncName.test(source)), bindData || (bindData = reThis.test(source), 
                setBindData(func, bindData));
            }
            if (bindData === !1 || bindData !== !0 && 1 & bindData[1]) return func;
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 2:
                return function(a, b) {
                    return func.call(thisArg, a, b);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        function baseCreateWrapper(bindData) {
            function bound() {
                var thisBinding = isBind ? thisArg : this;
                if (partialArgs) {
                    var args = slice(partialArgs);
                    push.apply(args, arguments);
                }
                if ((partialRightArgs || isCurry) && (args || (args = slice(arguments)), partialRightArgs && push.apply(args, partialRightArgs), 
                isCurry && args.length < arity)) return bitmask |= 16, baseCreateWrapper([ func, isCurryBound ? bitmask : -4 & bitmask, args, null, thisArg, arity ]);
                if (args || (args = arguments), isBindKey && (func = thisBinding[key]), this instanceof bound) {
                    thisBinding = baseCreate(func.prototype);
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            }
            var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5], isBind = 1 & bitmask, isBindKey = 2 & bitmask, isCurry = 4 & bitmask, isCurryBound = 8 & bitmask, key = func;
            return setBindData(bound, bindData), bound;
        }
        function baseDifference(array, values) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
            if (isLarge) {
                var cache = createCache(values);
                cache ? (indexOf = cacheIndexOf, values = cache) : isLarge = !1;
            }
            for (;++index < length; ) {
                var value = array[index];
                indexOf(values, value) < 0 && result.push(value);
            }
            return isLarge && releaseObject(values), result;
        }
        function baseFlatten(array, isShallow, isStrict, fromIndex) {
            for (var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = []; ++index < length; ) {
                var value = array[index];
                if (value && "object" == typeof value && "number" == typeof value.length && (isArray(value) || isArguments(value))) {
                    isShallow || (value = baseFlatten(value, isShallow, isStrict));
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    for (result.length += valLength; ++valIndex < valLength; ) result[resIndex++] = value[valIndex];
                } else isStrict || result.push(value);
            }
            return result;
        }
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            if (callback) {
                var result = callback(a, b);
                if ("undefined" != typeof result) return !!result;
            }
            if (a === b) return 0 !== a || 1 / a == 1 / b;
            var type = typeof a, otherType = typeof b;
            if (!(a !== a || a && objectTypes[type] || b && objectTypes[otherType])) return !1;
            if (null == a || null == b) return a === b;
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass && (className = objectClass), otherClass == argsClass && (otherClass = objectClass), 
            className != otherClass) return !1;
            switch (className) {
              case boolClass:
              case dateClass:
                return +a == +b;

              case numberClass:
                return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;

              case regexpClass:
              case stringClass:
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                if (aWrapped || bWrapped) return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                if (className != objectClass) return !1;
                var ctorA = a.constructor, ctorB = b.constructor;
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && "constructor" in a && "constructor" in b) return !1;
            }
            var initedStack = !stackA;
            stackA || (stackA = getArray()), stackB || (stackB = getArray());
            for (var length = stackA.length; length--; ) if (stackA[length] == a) return stackB[length] == b;
            var size = 0;
            if (result = !0, stackA.push(a), stackB.push(b), isArr) {
                if (length = a.length, size = b.length, result = size == length, result || isWhere) for (;size--; ) {
                    var index = length, value = b[size];
                    if (isWhere) for (;index-- && !(result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)); ) ; else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) break;
                }
            } else forIn(b, function(value, key, b) {
                return hasOwnProperty.call(b, key) ? (size++, result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB)) : void 0;
            }), result && !isWhere && forIn(a, function(value, key, a) {
                return hasOwnProperty.call(a, key) ? result = --size > -1 : void 0;
            });
            return stackA.pop(), stackB.pop(), initedStack && (releaseArray(stackA), releaseArray(stackB)), 
            result;
        }
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    for (var stackLength = stackA.length; stackLength--; ) if (found = stackA[stackLength] == source) {
                        value = stackB[stackLength];
                        break;
                    }
                    if (!found) {
                        var isShallow;
                        callback && (result = callback(value, source), (isShallow = "undefined" != typeof result) && (value = result)), 
                        isShallow || (value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {}), 
                        stackA.push(source), stackB.push(value), isShallow || baseMerge(value, source, callback, stackA, stackB);
                    }
                } else callback && (result = callback(value, source), "undefined" == typeof result && (result = source)), 
                "undefined" != typeof result && (value = result);
                object[key] = value;
            });
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                indexOf = cacheIndexOf, seen = cache;
            }
            for (;++index < length; ) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) && ((callback || isLarge) && seen.push(computed), 
                result.push(value));
            }
            return isLarge ? (releaseArray(seen.array), releaseObject(seen)) : callback && releaseArray(seen), 
            result;
        }
        function createAggregator(setter) {
            return function(collection, callback, thisArg) {
                var result = {};
                callback = lodash.createCallback(callback, thisArg, 3);
                var index = -1, length = collection ? collection.length : 0;
                if ("number" == typeof length) for (;++index < length; ) {
                    var value = collection[index];
                    setter(result, value, callback(value, index, collection), collection);
                } else forOwn(collection, function(value, key, collection) {
                    setter(result, value, callback(value, key, collection), collection);
                });
                return result;
            };
        }
        function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = 1 & bitmask, isBindKey = 2 & bitmask, isCurry = 4 & bitmask, isPartial = 16 & bitmask, isPartialRight = 32 & bitmask;
            if (!isBindKey && !isFunction(func)) throw new TypeError();
            isPartial && !partialArgs.length && (bitmask &= -17, isPartial = partialArgs = !1), 
            isPartialRight && !partialRightArgs.length && (bitmask &= -33, isPartialRight = partialRightArgs = !1);
            var bindData = func && func.__bindData__;
            if (bindData && bindData !== !0) return bindData = slice(bindData), bindData[2] && (bindData[2] = slice(bindData[2])), 
            bindData[3] && (bindData[3] = slice(bindData[3])), !isBind || 1 & bindData[1] || (bindData[4] = thisArg), 
            !isBind && 1 & bindData[1] && (bitmask |= 8), !isCurry || 4 & bindData[1] || (bindData[5] = arity), 
            isPartial && push.apply(bindData[2] || (bindData[2] = []), partialArgs), isPartialRight && unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs), 
            bindData[1] |= bitmask, createWrapper.apply(null, bindData);
            var creater = 1 == bitmask || 17 === bitmask ? baseBind : baseCreateWrapper;
            return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
        }
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        function isNative(value) {
            return "function" == typeof value && reNative.test(value);
        }
        function shimIsPlainObject(value) {
            var ctor, result;
            return value && toString.call(value) == objectClass && (ctor = value.constructor, 
            !isFunction(ctor) || ctor instanceof ctor) ? (forIn(value, function(value, key) {
                result = key;
            }), "undefined" == typeof result || hasOwnProperty.call(value, result)) : !1;
        }
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        function isArguments(value) {
            return value && "object" == typeof value && "number" == typeof value.length && toString.call(value) == argsClass || !1;
        }
        function clone(value, isDeep, callback, thisArg) {
            return "boolean" != typeof isDeep && null != isDeep && (thisArg = callback, callback = isDeep, 
            isDeep = !1), baseClone(value, isDeep, "function" == typeof callback && baseCreateCallback(callback, thisArg, 1));
        }
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, !0, "function" == typeof callback && baseCreateCallback(callback, thisArg, 1));
        }
        function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties ? assign(result, properties) : result;
        }
        function findKey(object, callback, thisArg) {
            var result;
            return callback = lodash.createCallback(callback, thisArg, 3), forOwn(object, function(value, key, object) {
                return callback(value, key, object) ? (result = key, !1) : void 0;
            }), result;
        }
        function findLastKey(object, callback, thisArg) {
            var result;
            return callback = lodash.createCallback(callback, thisArg, 3), forOwnRight(object, function(value, key, object) {
                return callback(value, key, object) ? (result = key, !1) : void 0;
            }), result;
        }
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function(value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            for (callback = baseCreateCallback(callback, thisArg, 3); length-- && callback(pairs[length--], pairs[length], object) !== !1; ) ;
            return object;
        }
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            for (callback = baseCreateCallback(callback, thisArg, 3); length--; ) {
                var key = props[length];
                if (callback(object[key], key, object) === !1) break;
            }
            return object;
        }
        function functions(object) {
            var result = [];
            return forIn(object, function(value, key) {
                isFunction(value) && result.push(key);
            }), result.sort();
        }
        function has(object, key) {
            return object ? hasOwnProperty.call(object, key) : !1;
        }
        function invert(object) {
            for (var index = -1, props = keys(object), length = props.length, result = {}; ++index < length; ) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        function isBoolean(value) {
            return value === !0 || value === !1 || value && "object" == typeof value && toString.call(value) == boolClass || !1;
        }
        function isDate(value) {
            return value && "object" == typeof value && toString.call(value) == dateClass || !1;
        }
        function isElement(value) {
            return value && 1 === value.nodeType || !1;
        }
        function isEmpty(value) {
            var result = !0;
            if (!value) return result;
            var className = toString.call(value), length = value.length;
            return className == arrayClass || className == stringClass || className == argsClass || className == objectClass && "number" == typeof length && isFunction(value.splice) ? !length : (forOwn(value, function() {
                return result = !1;
            }), result);
        }
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, "function" == typeof callback && baseCreateCallback(callback, thisArg, 2));
        }
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        function isFunction(value) {
            return "function" == typeof value;
        }
        function isObject(value) {
            return !(!value || !objectTypes[typeof value]);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNull(value) {
            return null === value;
        }
        function isNumber(value) {
            return "number" == typeof value || value && "object" == typeof value && toString.call(value) == numberClass || !1;
        }
        function isRegExp(value) {
            return value && "object" == typeof value && toString.call(value) == regexpClass || !1;
        }
        function isString(value) {
            return "string" == typeof value || value && "object" == typeof value && toString.call(value) == stringClass || !1;
        }
        function isUndefined(value) {
            return "undefined" == typeof value;
        }
        function mapValues(object, callback, thisArg) {
            var result = {};
            return callback = lodash.createCallback(callback, thisArg, 3), forOwn(object, function(value, key, object) {
                result[key] = callback(value, key, object);
            }), result;
        }
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) return object;
            if ("number" != typeof args[2] && (length = args.length), length > 3 && "function" == typeof args[length - 2]) var callback = baseCreateCallback(args[--length - 1], args[length--], 2); else length > 2 && "function" == typeof args[length - 1] && (callback = args[--length]);
            for (var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray(); ++index < length; ) baseMerge(object, sources[index], callback, stackA, stackB);
            return releaseArray(stackA), releaseArray(stackB), object;
        }
        function omit(object, callback, thisArg) {
            var result = {};
            if ("function" != typeof callback) {
                var props = [];
                forIn(object, function(value, key) {
                    props.push(key);
                }), props = baseDifference(props, baseFlatten(arguments, !0, !1, 1));
                for (var index = -1, length = props.length; ++index < length; ) {
                    var key = props[index];
                    result[key] = object[key];
                }
            } else callback = lodash.createCallback(callback, thisArg, 3), forIn(object, function(value, key, object) {
                callback(value, key, object) || (result[key] = value);
            });
            return result;
        }
        function pairs(object) {
            for (var index = -1, props = keys(object), length = props.length, result = Array(length); ++index < length; ) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        function pick(object, callback, thisArg) {
            var result = {};
            if ("function" != typeof callback) for (var index = -1, props = baseFlatten(arguments, !0, !1, 1), length = isObject(object) ? props.length : 0; ++index < length; ) {
                var key = props[index];
                key in object && (result[key] = object[key]);
            } else callback = lodash.createCallback(callback, thisArg, 3), forIn(object, function(value, key, object) {
                callback(value, key, object) && (result[key] = value);
            });
            return result;
        }
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (null == accumulator) if (isArr) accumulator = []; else {
                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                accumulator = baseCreate(proto);
            }
            return callback && (callback = lodash.createCallback(callback, thisArg, 4), (isArr ? forEach : forOwn)(object, function(value, index, object) {
                return callback(accumulator, value, index, object);
            })), accumulator;
        }
        function values(object) {
            for (var index = -1, props = keys(object), length = props.length, result = Array(length); ++index < length; ) result[index] = object[props[index]];
            return result;
        }
        function at(collection) {
            for (var args = arguments, index = -1, props = baseFlatten(args, !0, !1, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length); ++index < length; ) result[index] = collection[props[index]];
            return result;
        }
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = !1;
            return fromIndex = (0 > fromIndex ? nativeMax(0, length + fromIndex) : fromIndex) || 0, 
            isArray(collection) ? result = indexOf(collection, target, fromIndex) > -1 : "number" == typeof length ? result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1 : forOwn(collection, function(value) {
                return ++index >= fromIndex ? !(result = value === target) : void 0;
            }), result;
        }
        function every(collection, callback, thisArg) {
            var result = !0;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if ("number" == typeof length) for (;++index < length && (result = !!callback(collection[index], index, collection)); ) ; else forOwn(collection, function(value, index, collection) {
                return result = !!callback(value, index, collection);
            });
            return result;
        }
        function filter(collection, callback, thisArg) {
            var result = [];
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if ("number" == typeof length) for (;++index < length; ) {
                var value = collection[index];
                callback(value, index, collection) && result.push(value);
            } else forOwn(collection, function(value, index, collection) {
                callback(value, index, collection) && result.push(value);
            });
            return result;
        }
        function find(collection, callback, thisArg) {
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if ("number" != typeof length) {
                var result;
                return forOwn(collection, function(value, index, collection) {
                    return callback(value, index, collection) ? (result = value, !1) : void 0;
                }), result;
            }
            for (;++index < length; ) {
                var value = collection[index];
                if (callback(value, index, collection)) return value;
            }
        }
        function findLast(collection, callback, thisArg) {
            var result;
            return callback = lodash.createCallback(callback, thisArg, 3), forEachRight(collection, function(value, index, collection) {
                return callback(value, index, collection) ? (result = value, !1) : void 0;
            }), result;
        }
        function forEach(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            if (callback = callback && "undefined" == typeof thisArg ? callback : baseCreateCallback(callback, thisArg, 3), 
            "number" == typeof length) for (;++index < length && callback(collection[index], index, collection) !== !1; ) ; else forOwn(collection, callback);
            return collection;
        }
        function forEachRight(collection, callback, thisArg) {
            var length = collection ? collection.length : 0;
            if (callback = callback && "undefined" == typeof thisArg ? callback : baseCreateCallback(callback, thisArg, 3), 
            "number" == typeof length) for (;length-- && callback(collection[length], length, collection) !== !1; ) ; else {
                var props = keys(collection);
                length = props.length, forOwn(collection, function(value, key, collection) {
                    return key = props ? props[--length] : --length, callback(collection[key], key, collection);
                });
            }
            return collection;
        }
        function invoke(collection, methodName) {
            var args = slice(arguments, 2), index = -1, isFunc = "function" == typeof methodName, length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            return forEach(collection, function(value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            }), result;
        }
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0;
            if (callback = lodash.createCallback(callback, thisArg, 3), "number" == typeof length) for (var result = Array(length); ++index < length; ) result[index] = callback(collection[index], index, collection); else result = [], 
            forOwn(collection, function(value, key, collection) {
                result[++index] = callback(value, key, collection);
            });
            return result;
        }
        function max(collection, callback, thisArg) {
            var computed = -(1 / 0), result = computed;
            if ("function" != typeof callback && thisArg && thisArg[callback] === collection && (callback = null), 
            null == callback && isArray(collection)) for (var index = -1, length = collection.length; ++index < length; ) {
                var value = collection[index];
                value > result && (result = value);
            } else callback = null == callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3), 
            forEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                current > computed && (computed = current, result = value);
            });
            return result;
        }
        function min(collection, callback, thisArg) {
            var computed = 1 / 0, result = computed;
            if ("function" != typeof callback && thisArg && thisArg[callback] === collection && (callback = null), 
            null == callback && isArray(collection)) for (var index = -1, length = collection.length; ++index < length; ) {
                var value = collection[index];
                result > value && (result = value);
            } else callback = null == callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3), 
            forEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                computed > current && (computed = current, result = value);
            });
            return result;
        }
        function reduce(collection, callback, accumulator, thisArg) {
            if (!collection) return accumulator;
            var noaccum = arguments.length < 3;
            callback = lodash.createCallback(callback, thisArg, 4);
            var index = -1, length = collection.length;
            if ("number" == typeof length) for (noaccum && (accumulator = collection[++index]); ++index < length; ) accumulator = callback(accumulator, collection[index], index, collection); else forOwn(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = !1, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            return callback = lodash.createCallback(callback, thisArg, 4), forEachRight(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = !1, value) : callback(accumulator, value, index, collection);
            }), accumulator;
        }
        function reject(collection, callback, thisArg) {
            return callback = lodash.createCallback(callback, thisArg, 3), filter(collection, function(value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (collection && "number" != typeof collection.length && (collection = values(collection)), 
            null == n || guard) return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
            var result = shuffle(collection);
            return result.length = nativeMin(nativeMax(0, n), result.length), result;
        }
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            return forEach(collection, function(value) {
                var rand = baseRandom(0, ++index);
                result[index] = result[rand], result[rand] = value;
            }), result;
        }
        function size(collection) {
            var length = collection ? collection.length : 0;
            return "number" == typeof length ? length : keys(collection).length;
        }
        function some(collection, callback, thisArg) {
            var result;
            callback = lodash.createCallback(callback, thisArg, 3);
            var index = -1, length = collection ? collection.length : 0;
            if ("number" == typeof length) for (;++index < length && !(result = callback(collection[index], index, collection)); ) ; else forOwn(collection, function(value, index, collection) {
                return !(result = callback(value, index, collection));
            });
            return !!result;
        }
        function sortBy(collection, callback, thisArg) {
            var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            for (isArr || (callback = lodash.createCallback(callback, thisArg, 3)), forEach(collection, function(value, key, collection) {
                var object = result[++index] = getObject();
                isArr ? object.criteria = map(callback, function(key) {
                    return value[key];
                }) : (object.criteria = getArray())[0] = callback(value, key, collection), object.index = index, 
                object.value = value;
            }), length = result.length, result.sort(compareAscending); length--; ) {
                var object = result[length];
                result[length] = object.value, isArr || releaseArray(object.criteria), releaseObject(object);
            }
            return result;
        }
        function toArray(collection) {
            return collection && "number" == typeof collection.length ? slice(collection) : values(collection);
        }
        function compact(array) {
            for (var index = -1, length = array ? array.length : 0, result = []; ++index < length; ) {
                var value = array[index];
                value && result.push(value);
            }
            return result;
        }
        function difference(array) {
            return baseDifference(array, baseFlatten(arguments, !0, !0, 1));
        }
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length; ) if (callback(array[index], index, array)) return index;
            return -1;
        }
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            for (callback = lodash.createCallback(callback, thisArg, 3); length--; ) if (callback(array[length], length, array)) return length;
            return -1;
        }
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if ("number" != typeof callback && null != callback) {
                var index = -1;
                for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length && callback(array[index], index, array); ) n++;
            } else if (n = callback, null == n || thisArg) return array ? array[0] : undefined;
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        function flatten(array, isShallow, callback, thisArg) {
            return "boolean" != typeof isShallow && null != isShallow && (thisArg = callback, 
            callback = "function" != typeof isShallow && thisArg && thisArg[isShallow] === array ? null : isShallow, 
            isShallow = !1), null != callback && (array = map(array, callback, thisArg)), baseFlatten(array, isShallow);
        }
        function indexOf(array, value, fromIndex) {
            if ("number" == typeof fromIndex) {
                var length = array ? array.length : 0;
                fromIndex = 0 > fromIndex ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if ("number" != typeof callback && null != callback) {
                var index = length;
                for (callback = lodash.createCallback(callback, thisArg, 3); index-- && callback(array[index], index, array); ) n++;
            } else n = null == callback || thisArg ? 1 : callback || n;
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        function intersection() {
            for (var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray(); ++argsIndex < argsLength; ) {
                var value = arguments[argsIndex];
                (isArray(value) || isArguments(value)) && (args.push(value), caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen)));
            }
            var array = args[0], index = -1, length = array ? array.length : 0, result = [];
            outer: for (;++index < length; ) {
                var cache = caches[0];
                if (value = array[index], (cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                    for (argsIndex = argsLength, (cache || seen).push(value); --argsIndex; ) if (cache = caches[argsIndex], 
                    (cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) continue outer;
                    result.push(value);
                }
            }
            for (;argsLength--; ) cache = caches[argsLength], cache && releaseObject(cache);
            return releaseArray(caches), releaseArray(seen), result;
        }
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if ("number" != typeof callback && null != callback) {
                var index = length;
                for (callback = lodash.createCallback(callback, thisArg, 3); index-- && callback(array[index], index, array); ) n++;
            } else if (n = callback, null == n || thisArg) return array ? array[length - 1] : undefined;
            return slice(array, nativeMax(0, length - n));
        }
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            for ("number" == typeof fromIndex && (index = (0 > fromIndex ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1); index--; ) if (array[index] === value) return index;
            return -1;
        }
        function pull(array) {
            for (var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0; ++argsIndex < argsLength; ) for (var index = -1, value = args[argsIndex]; ++index < length; ) array[index] === value && (splice.call(array, index--, 1), 
            length--);
            return array;
        }
        function range(start, end, step) {
            start = +start || 0, step = "number" == typeof step ? step : +step || 1, null == end && (end = start, 
            start = 0);
            for (var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length); ++index < length; ) result[index] = start, 
            start += step;
            return result;
        }
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length; ) {
                var value = array[index];
                callback(value, index, array) && (result.push(value), splice.call(array, index--, 1), 
                length--);
            }
            return result;
        }
        function rest(array, callback, thisArg) {
            if ("number" != typeof callback && null != callback) {
                var n = 0, index = -1, length = array ? array.length : 0;
                for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length && callback(array[index], index, array); ) n++;
            } else n = null == callback || thisArg ? 1 : nativeMax(0, callback);
            return slice(array, n);
        }
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            for (callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity, 
            value = callback(value); high > low; ) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        function union() {
            return baseUniq(baseFlatten(arguments, !0, !0));
        }
        function uniq(array, isSorted, callback, thisArg) {
            return "boolean" != typeof isSorted && null != isSorted && (thisArg = callback, 
            callback = "function" != typeof isSorted && thisArg && thisArg[isSorted] === array ? null : isSorted, 
            isSorted = !1), null != callback && (callback = lodash.createCallback(callback, thisArg, 3)), 
            baseUniq(array, isSorted, callback);
        }
        function without(array) {
            return baseDifference(array, slice(arguments, 1));
        }
        function xor() {
            for (var index = -1, length = arguments.length; ++index < length; ) {
                var array = arguments[index];
                if (isArray(array) || isArguments(array)) var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
            }
            return result || [];
        }
        function zip() {
            for (var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(0 > length ? 0 : length); ++index < length; ) result[index] = pluck(array, index);
            return result;
        }
        function zipObject(keys, values) {
            var index = -1, length = keys ? keys.length : 0, result = {};
            for (values || !length || isArray(keys[0]) || (values = []); ++index < length; ) {
                var key = keys[index];
                values ? result[key] = values[index] : key && (result[key[0]] = key[1]);
            }
            return result;
        }
        function after(n, func) {
            if (!isFunction(func)) throw new TypeError();
            return function() {
                return --n < 1 ? func.apply(this, arguments) : void 0;
            };
        }
        function bind(func, thisArg) {
            return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
        }
        function bindAll(object) {
            for (var funcs = arguments.length > 1 ? baseFlatten(arguments, !0, !1, 1) : functions(object), index = -1, length = funcs.length; ++index < length; ) {
                var key = funcs[index];
                object[key] = createWrapper(object[key], 1, null, null, object);
            }
            return object;
        }
        function bindKey(object, key) {
            return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
        }
        function compose() {
            for (var funcs = arguments, length = funcs.length; length--; ) if (!isFunction(funcs[length])) throw new TypeError();
            return function() {
                for (var args = arguments, length = funcs.length; length--; ) args = [ funcs[length].apply(this, args) ];
                return args[0];
            };
        }
        function curry(func, arity) {
            return arity = "number" == typeof arity ? arity : +arity || func.length, createWrapper(func, 4, null, null, null, arity);
        }
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = !1, trailing = !0;
            if (!isFunction(func)) throw new TypeError();
            if (wait = nativeMax(0, wait) || 0, options === !0) {
                var leading = !0;
                trailing = !1;
            } else isObject(options) && (leading = options.leading, maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0), 
            trailing = "trailing" in options ? options.trailing : trailing);
            var delayed = function() {
                var remaining = wait - (now() - stamp);
                if (0 >= remaining) {
                    maxTimeoutId && clearTimeout(maxTimeoutId);
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined, isCalled && (lastCalled = now(), 
                    result = func.apply(thisArg, args), timeoutId || maxTimeoutId || (args = thisArg = null));
                } else timeoutId = setTimeout(delayed, remaining);
            }, maxDelayed = function() {
                timeoutId && clearTimeout(timeoutId), maxTimeoutId = timeoutId = trailingCall = undefined, 
                (trailing || maxWait !== wait) && (lastCalled = now(), result = func.apply(thisArg, args), 
                timeoutId || maxTimeoutId || (args = thisArg = null));
            };
            return function() {
                if (args = arguments, stamp = now(), thisArg = this, trailingCall = trailing && (timeoutId || !leading), 
                maxWait === !1) var leadingCall = leading && !timeoutId; else {
                    maxTimeoutId || leading || (lastCalled = stamp);
                    var remaining = maxWait - (stamp - lastCalled), isCalled = 0 >= remaining;
                    isCalled ? (maxTimeoutId && (maxTimeoutId = clearTimeout(maxTimeoutId)), lastCalled = stamp, 
                    result = func.apply(thisArg, args)) : maxTimeoutId || (maxTimeoutId = setTimeout(maxDelayed, remaining));
                }
                return isCalled && timeoutId ? timeoutId = clearTimeout(timeoutId) : timeoutId || wait === maxWait || (timeoutId = setTimeout(delayed, wait)), 
                leadingCall && (isCalled = !0, result = func.apply(thisArg, args)), !isCalled || timeoutId || maxTimeoutId || (args = thisArg = null), 
                result;
            };
        }
        function defer(func) {
            if (!isFunction(func)) throw new TypeError();
            var args = slice(arguments, 1);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, 1);
        }
        function delay(func, wait) {
            if (!isFunction(func)) throw new TypeError();
            var args = slice(arguments, 2);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        function memoize(func, resolver) {
            if (!isFunction(func)) throw new TypeError();
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            return memoized.cache = {}, memoized;
        }
        function once(func) {
            var ran, result;
            if (!isFunction(func)) throw new TypeError();
            return function() {
                return ran ? result : (ran = !0, result = func.apply(this, arguments), func = null, 
                result);
            };
        }
        function partial(func) {
            return createWrapper(func, 16, slice(arguments, 1));
        }
        function partialRight(func) {
            return createWrapper(func, 32, null, slice(arguments, 1));
        }
        function throttle(func, wait, options) {
            var leading = !0, trailing = !0;
            if (!isFunction(func)) throw new TypeError();
            return options === !1 ? leading = !1 : isObject(options) && (leading = "leading" in options ? options.leading : leading, 
            trailing = "trailing" in options ? options.trailing : trailing), debounceOptions.leading = leading, 
            debounceOptions.maxWait = wait, debounceOptions.trailing = trailing, debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            return createWrapper(wrapper, 16, [ value ]);
        }
        function constant(value) {
            return function() {
                return value;
            };
        }
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (null == func || "function" == type) return baseCreateCallback(func, thisArg, argCount);
            if ("object" != type) return property(func);
            var props = keys(func), key = props[0], a = func[key];
            return 1 != props.length || a !== a || isObject(a) ? function(object) {
                for (var length = props.length, result = !1; length-- && (result = baseIsEqual(object[props[length]], func[props[length]], null, !0)); ) ;
                return result;
            } : function(object) {
                var b = object[key];
                return a === b && (0 !== a || 1 / a == 1 / b);
            };
        }
        function escape(string) {
            return null == string ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        function identity(value) {
            return value;
        }
        function mixin(object, source, options) {
            var chain = !0, methodNames = source && functions(source);
            source && (options || methodNames.length) || (null == options && (options = source), 
            ctor = lodashWrapper, source = object, object = lodash, methodNames = functions(source)), 
            options === !1 ? chain = !1 : isObject(options) && "chain" in options && (chain = options.chain);
            var ctor = object, isFunc = isFunction(ctor);
            forEach(methodNames, function(methodName) {
                var func = object[methodName] = source[methodName];
                isFunc && (ctor.prototype[methodName] = function() {
                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                    push.apply(args, arguments);
                    var result = func.apply(object, args);
                    if (chain || chainAll) {
                        if (value === result && isObject(result)) return this;
                        result = new ctor(result), result.__chain__ = chainAll;
                    }
                    return result;
                });
            });
        }
        function noConflict() {
            return context._ = oldDash, this;
        }
        function noop() {}
        function property(key) {
            return function(object) {
                return object[key];
            };
        }
        function random(min, max, floating) {
            var noMin = null == min, noMax = null == max;
            if (null == floating && ("boolean" == typeof min && noMax ? (floating = min, min = 1) : noMax || "boolean" != typeof max || (floating = max, 
            noMax = !0)), noMin && noMax && (max = 1), min = +min || 0, noMax ? (max = min, 
            min = 0) : max = +max || 0, floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
            }
            return baseRandom(min, max);
        }
        function result(object, key) {
            if (object) {
                var value = object[key];
                return isFunction(value) ? object[key]() : value;
            }
        }
        function template(text, data, options) {
            var settings = lodash.templateSettings;
            text = String(text || ""), options = defaults({}, options, settings);
            var isEvaluating, imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                return interpolateValue || (interpolateValue = esTemplateValue), source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar), 
                escapeValue && (source += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = !0, 
                source += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), 
                index = offset + match.length, match;
            }), source += "';\n";
            var variable = options.variable, hasVariable = variable;
            hasVariable || (variable = "obj", source = "with (" + variable + ") {\n" + source + "\n}\n"), 
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), 
            source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
            try {
                var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                throw e.source = source, e;
            }
            return data ? result(data) : (result.source = source, result);
        }
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            for (callback = baseCreateCallback(callback, thisArg, 1); ++index < n; ) result[index] = callback(index);
            return result;
        }
        function unescape(string) {
            return null == string ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(null == prefix ? "" : prefix) + id;
        }
        function chain(value) {
            return value = new lodashWrapper(value), value.__chain__ = !0, value;
        }
        function tap(value, interceptor) {
            return interceptor(value), value;
        }
        function wrapperChain() {
            return this.__chain__ = !0, this;
        }
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError, arrayRef = [], objectProto = Object.prototype, oldDash = context._, toString = objectProto.toString, reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"), ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift, defineProperty = function() {
            try {
                var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {}
            return result;
        }(), nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, ctorByClass = {};
        ctorByClass[arrayClass] = Array, ctorByClass[boolClass] = Boolean, ctorByClass[dateClass] = Date, 
        ctorByClass[funcClass] = Function, ctorByClass[objectClass] = Object, ctorByClass[numberClass] = Number, 
        ctorByClass[regexpClass] = RegExp, ctorByClass[stringClass] = String, lodashWrapper.prototype = lodash.prototype;
        var support = lodash.support = {};
        support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext), 
        support.funcNames = "string" == typeof Function.name, lodash.templateSettings = {
            escape: /<%-([\s\S]+?)%>/g,
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: reInterpolate,
            variable: "",
            imports: {
                _: lodash
            }
        }, nativeCreate || (baseCreate = function() {
            function Object() {}
            return function(prototype) {
                if (isObject(prototype)) {
                    Object.prototype = prototype;
                    var result = new Object();
                    Object.prototype = null;
                }
                return result || context.Object();
            };
        }());
        var setBindData = defineProperty ? function(func, value) {
            descriptor.value = value, defineProperty(func, "__bindData__", descriptor);
        } : noop, isArray = nativeIsArray || function(value) {
            return value && "object" == typeof value && "number" == typeof value.length && toString.call(value) == arrayClass || !1;
        }, shimKeys = function(object) {
            var index, iterable = object, result = [];
            if (!iterable) return result;
            if (!objectTypes[typeof object]) return result;
            for (index in iterable) hasOwnProperty.call(iterable, index) && result.push(index);
            return result;
        }, keys = nativeKeys ? function(object) {
            return isObject(object) ? nativeKeys(object) : [];
        } : shimKeys, htmlEscapes = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, htmlUnescapes = invert(htmlEscapes), reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g"), assign = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable) return result;
            var args = arguments, argsIndex = 0, argsLength = "number" == typeof guard ? 2 : args.length;
            if (argsLength > 3 && "function" == typeof args[argsLength - 2]) var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2); else argsLength > 2 && "function" == typeof args[argsLength - 1] && (callback = args[--argsLength]);
            for (;++argsIndex < argsLength; ) if (iterable = args[argsIndex], iterable && objectTypes[typeof iterable]) for (var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0; ++ownIndex < length; ) index = ownProps[ownIndex], 
            result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
            return result;
        }, defaults = function(object, source, guard) {
            var index, iterable = object, result = iterable;
            if (!iterable) return result;
            for (var args = arguments, argsIndex = 0, argsLength = "number" == typeof guard ? 2 : args.length; ++argsIndex < argsLength; ) if (iterable = args[argsIndex], 
            iterable && objectTypes[typeof iterable]) for (var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0; ++ownIndex < length; ) index = ownProps[ownIndex], 
            "undefined" == typeof result[index] && (result[index] = iterable[index]);
            return result;
        }, forIn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable) return result;
            if (!objectTypes[typeof iterable]) return result;
            callback = callback && "undefined" == typeof thisArg ? callback : baseCreateCallback(callback, thisArg, 3);
            for (index in iterable) if (callback(iterable[index], index, collection) === !1) return result;
            return result;
        }, forOwn = function(collection, callback, thisArg) {
            var index, iterable = collection, result = iterable;
            if (!iterable) return result;
            if (!objectTypes[typeof iterable]) return result;
            callback = callback && "undefined" == typeof thisArg ? callback : baseCreateCallback(callback, thisArg, 3);
            for (var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0; ++ownIndex < length; ) if (index = ownProps[ownIndex], 
            callback(iterable[index], index, collection) === !1) return result;
            return result;
        }, isPlainObject = getPrototypeOf ? function(value) {
            if (!value || toString.call(value) != objectClass) return !1;
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        } : shimIsPlainObject, countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        }), groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        }), indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        }), pluck = map, where = filter, now = isNative(now = Date.now) && now || function() {
            return new Date().getTime();
        }, parseInt = 8 == nativeParseInt(whitespace + "08") ? nativeParseInt : function(value, radix) {
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
        };
        return lodash.after = after, lodash.assign = assign, lodash.at = at, lodash.bind = bind, 
        lodash.bindAll = bindAll, lodash.bindKey = bindKey, lodash.chain = chain, lodash.compact = compact, 
        lodash.compose = compose, lodash.constant = constant, lodash.countBy = countBy, 
        lodash.create = create, lodash.createCallback = createCallback, lodash.curry = curry, 
        lodash.debounce = debounce, lodash.defaults = defaults, lodash.defer = defer, lodash.delay = delay, 
        lodash.difference = difference, lodash.filter = filter, lodash.flatten = flatten, 
        lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn, 
        lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight, 
        lodash.functions = functions, lodash.groupBy = groupBy, lodash.indexBy = indexBy, 
        lodash.initial = initial, lodash.intersection = intersection, lodash.invert = invert, 
        lodash.invoke = invoke, lodash.keys = keys, lodash.map = map, lodash.mapValues = mapValues, 
        lodash.max = max, lodash.memoize = memoize, lodash.merge = merge, lodash.min = min, 
        lodash.omit = omit, lodash.once = once, lodash.pairs = pairs, lodash.partial = partial, 
        lodash.partialRight = partialRight, lodash.pick = pick, lodash.pluck = pluck, lodash.property = property, 
        lodash.pull = pull, lodash.range = range, lodash.reject = reject, lodash.remove = remove, 
        lodash.rest = rest, lodash.shuffle = shuffle, lodash.sortBy = sortBy, lodash.tap = tap, 
        lodash.throttle = throttle, lodash.times = times, lodash.toArray = toArray, lodash.transform = transform, 
        lodash.union = union, lodash.uniq = uniq, lodash.values = values, lodash.where = where, 
        lodash.without = without, lodash.wrap = wrap, lodash.xor = xor, lodash.zip = zip, 
        lodash.zipObject = zipObject, lodash.collect = map, lodash.drop = rest, lodash.each = forEach, 
        lodash.eachRight = forEachRight, lodash.extend = assign, lodash.methods = functions, 
        lodash.object = zipObject, lodash.select = filter, lodash.tail = rest, lodash.unique = uniq, 
        lodash.unzip = zip, mixin(lodash), lodash.clone = clone, lodash.cloneDeep = cloneDeep, 
        lodash.contains = contains, lodash.escape = escape, lodash.every = every, lodash.find = find, 
        lodash.findIndex = findIndex, lodash.findKey = findKey, lodash.findLast = findLast, 
        lodash.findLastIndex = findLastIndex, lodash.findLastKey = findLastKey, lodash.has = has, 
        lodash.identity = identity, lodash.indexOf = indexOf, lodash.isArguments = isArguments, 
        lodash.isArray = isArray, lodash.isBoolean = isBoolean, lodash.isDate = isDate, 
        lodash.isElement = isElement, lodash.isEmpty = isEmpty, lodash.isEqual = isEqual, 
        lodash.isFinite = isFinite, lodash.isFunction = isFunction, lodash.isNaN = isNaN, 
        lodash.isNull = isNull, lodash.isNumber = isNumber, lodash.isObject = isObject, 
        lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isString = isString, 
        lodash.isUndefined = isUndefined, lodash.lastIndexOf = lastIndexOf, lodash.mixin = mixin, 
        lodash.noConflict = noConflict, lodash.noop = noop, lodash.now = now, lodash.parseInt = parseInt, 
        lodash.random = random, lodash.reduce = reduce, lodash.reduceRight = reduceRight, 
        lodash.result = result, lodash.runInContext = runInContext, lodash.size = size, 
        lodash.some = some, lodash.sortedIndex = sortedIndex, lodash.template = template, 
        lodash.unescape = unescape, lodash.uniqueId = uniqueId, lodash.all = every, lodash.any = some, 
        lodash.detect = find, lodash.findWhere = find, lodash.foldl = reduce, lodash.foldr = reduceRight, 
        lodash.include = contains, lodash.inject = reduce, mixin(function() {
            var source = {};
            return forOwn(lodash, function(func, methodName) {
                lodash.prototype[methodName] || (source[methodName] = func);
            }), source;
        }(), !1), lodash.first = first, lodash.last = last, lodash.sample = sample, lodash.take = first, 
        lodash.head = first, forOwn(lodash, function(func, methodName) {
            var callbackable = "sample" !== methodName;
            lodash.prototype[methodName] || (lodash.prototype[methodName] = function(n, guard) {
                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                return chainAll || null != n && (!guard || callbackable && "function" == typeof n) ? new lodashWrapper(result, chainAll) : result;
            });
        }), lodash.VERSION = "2.4.1", lodash.prototype.chain = wrapperChain, lodash.prototype.toString = wrapperToString, 
        lodash.prototype.value = wrapperValueOf, lodash.prototype.valueOf = wrapperValueOf, 
        forEach([ "join", "pop", "shift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        }), forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return func.apply(this.__wrapped__, arguments), this;
            };
        }), forEach([ "concat", "slice", "splice" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        }), lodash;
    }
    var undefined, arrayPool = [], objectPool = [], idCounter = 0, keyPrefix = +new Date() + "", largeArraySize = 75, maxPoolSize = 40, whitespace = " 	\f\ufeff\n\r\u2028\u2029", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reFuncName = /^\s*function[ \n\r\t]+\w/, reInterpolate = /<%=([\s\S]+?)%>/g, reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)"), reNoMatch = /($^)/, reThis = /\bthis\b/, reUnescapedString = /['\n\r\t\u2028\u2029\\]/g, contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ], templateCounter = 0, argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]", cloneableClasses = {};
    cloneableClasses[funcClass] = !1, cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = !0;
    var debounceOptions = {
        leading: !1,
        maxWait: 0,
        trailing: !1
    }, descriptor = {
        configurable: !1,
        enumerable: !1,
        value: null,
        writable: !1
    }, objectTypes = {
        "boolean": !1,
        "function": !0,
        object: !0,
        number: !1,
        string: !1,
        undefined: !1
    }, stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, root = objectTypes[typeof window] && window || this, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, freeModule = objectTypes[typeof module] && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports && freeExports, freeGlobal = objectTypes[typeof global] && global;
    !freeGlobal || freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal || (root = freeGlobal);
    var _ = runInContext();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (root._ = _, 
    define(function() {
        return _;
    })) : freeExports && freeModule ? moduleExports ? (freeModule.exports = _)._ = _ : freeExports._ = _ : root._ = _;
}).call(this), function(global, factory) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    } : factory(global);
}("undefined" != typeof window ? window : this, function(window, noGlobal) {
    function isArraylike(obj) {
        var length = obj.length, type = jQuery.type(obj);
        return "function" === type || jQuery.isWindow(obj) ? !1 : 1 === obj.nodeType && length ? !0 : "array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        });
        if (qualifier.nodeType) return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        });
        if ("string" == typeof qualifier) {
            if (risSimple.test(qualifier)) return jQuery.filter(qualifier, elements, not);
            qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) >= 0 !== not;
        });
    }
    function sibling(cur, dir) {
        for (;(cur = cur[dir]) && 1 !== cur.nodeType; ) ;
        return cur;
    }
    function createOptions(options) {
        var object = optionsCache[options] = {};
        return jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = !0;
        }), object;
    }
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed, !1), window.removeEventListener("load", completed, !1), 
        jQuery.ready();
    }
    function Data() {
        Object.defineProperty(this.cache = {}, 0, {
            get: function() {
                return {};
            }
        }), this.expando = jQuery.expando + Math.random();
    }
    function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType) if (name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase(), 
        data = elem.getAttribute(name), "string" == typeof data) {
            try {
                data = "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
            } catch (e) {}
            data_user.set(elem, key, data);
        } else data = void 0;
        return data;
    }
    function returnTrue() {
        return !0;
    }
    function returnFalse() {
        return !1;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }
    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"), elem;
    }
    function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; l > i; i++) data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (data_priv.hasData(src) && (pdataOld = data_priv.access(src), pdataCur = data_priv.set(dest, pdataOld), 
            events = pdataOld.events)) {
                delete pdataCur.handle, pdataCur.events = {};
                for (type in events) for (i = 0, l = events[type].length; l > i; i++) jQuery.event.add(dest, type, events[type][i]);
            }
            data_user.hasData(src) && (udataOld = data_user.access(src), udataCur = jQuery.extend({}, udataOld), 
            data_user.set(dest, udataCur));
        }
    }
    function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue);
    }
    function actualDisplay(name, doc) {
        var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        return elem.detach(), display;
    }
    function defaultDisplay(nodeName) {
        var doc = document, display = elemdisplay[nodeName];
        return display || (display = actualDisplay(nodeName, doc), "none" !== display && display || (iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement), 
        doc = iframe[0].contentDocument, doc.write(), doc.close(), display = actualDisplay(nodeName, doc), 
        iframe.detach()), elemdisplay[nodeName] = display), display;
    }
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name]), 
        computed && ("" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), 
        rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, 
        maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, 
        ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), 
        void 0 !== ret ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    function vendorPropName(style, name) {
        if (name in style) return name;
        for (var capName = name[0].toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length; i--; ) if (name = cssPrefixes[i] + capName, 
        name in style) return name;
        return origName;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        for (var i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0, val = 0; 4 > i; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), 
        isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), 
        "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), 
        "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = !0, val = "width" === name ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        if (0 >= val || null == val) {
            if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), 
            rnumnonpx.test(val)) return val;
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), 
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function showHide(elements, show) {
        for (var display, elem, hidden, values = [], index = 0, length = elements.length; length > index; index++) elem = elements[index], 
        elem.style && (values[index] = data_priv.get(elem, "olddisplay"), display = elem.style.display, 
        show ? (values[index] || "none" !== display || (elem.style.display = ""), "" === elem.style.display && isHidden(elem) && (values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName)))) : (hidden = isHidden(elem), 
        "none" === display && hidden || data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"))));
        for (index = 0; length > index; index++) elem = elements[index], elem.style && (show && "none" !== elem.style.display && "" !== elem.style.display || (elem.style.display = show ? values[index] || "" : "none"));
        return elements;
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    function createFxNow() {
        return setTimeout(function() {
            fxNow = void 0;
        }), fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        for (includeWidth = includeWidth ? 1 : 0; 4 > i; i += 2 - includeWidth) which = cssExpand[i], 
        attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs;
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (tweeners[prop] || []).concat(tweeners["*"]), index = 0, length = collection.length; length > index; index++) if (tween = collection[index].call(animation, prop, value)) return tween;
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = data_priv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, 
        oldfire = hooks.empty.fire, hooks.empty.fire = function() {
            hooks.unqueued || oldfire();
        }), hooks.unqueued++, anim.always(function() {
            anim.always(function() {
                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
            });
        })), 1 === elem.nodeType && ("height" in props || "width" in props) && (opts.overflow = [ style.overflow, style.overflowX, style.overflowY ], 
        display = jQuery.css(elem, "display"), checkDisplay = "none" === display ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display, 
        "inline" === checkDisplay && "none" === jQuery.css(elem, "float") && (style.display = "inline-block")), 
        opts.overflow && (style.overflow = "hidden", anim.always(function() {
            style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
        }));
        for (prop in props) if (value = props[prop], rfxtypes.exec(value)) {
            if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                hidden = !0;
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        } else display = void 0;
        if (jQuery.isEmptyObject(orig)) "inline" === ("none" === display ? defaultDisplay(elem.nodeName) : display) && (style.display = display); else {
            dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = data_priv.access(elem, "fxshow", {}), 
            toggle && (dataShow.hidden = !hidden), hidden ? jQuery(elem).show() : anim.done(function() {
                jQuery(elem).hide();
            }), anim.done(function() {
                var prop;
                data_priv.remove(elem, "fxshow");
                for (prop in orig) jQuery.style(elem, prop, orig[prop]);
            });
            for (prop in orig) tween = createTween(hidden ? dataShow[prop] : 0, prop, anim), 
            prop in dataShow || (dataShow[prop] = tween.start, hidden && (tween.end = tween.start, 
            tween.start = "width" === prop || "height" === prop ? 1 : 0));
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) if (name = jQuery.camelCase(index), easing = specialEasing[name], 
        value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), 
        index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], 
        hooks && "expand" in hooks) {
            value = hooks.expand(value), delete props[name];
            for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
        } else specialEasing[name] = easing;
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++) animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [ animation, percent, remaining ]), 1 > percent && length ? remaining : (deferred.resolveWith(elem, [ animation ]), 
            !1);
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
                specialEasing: {}
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween), tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                for (stopped = !0; length > index; index++) animation.tweens[index].run(1);
                return gotoEnd ? deferred.resolveWith(elem, [ animation, gotoEnd ]) : deferred.rejectWith(elem, [ animation, gotoEnd ]), 
                this;
            }
        }), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); length > index; index++) if (result = animationPrefilters[index].call(animation, elem, props, animation.opts)) return result;
        return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), 
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
            if (jQuery.isFunction(func)) for (;dataType = dataTypes[i++]; ) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", 
            (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func);
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), 
                inspect(dataTypeOrTransport), !1);
            }), selected;
        }
        var inspected = {}, seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(), 
        void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
        }
        if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                firstDataType || (firstDataType = type);
            }
            finalDataType = finalDataType || firstDataType;
        }
        return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), 
        responses[finalDataType]) : void 0;
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), 
        !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), 
        prev = current, current = dataTypes.shift()) if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
            if (conv = converters[prev + " " + current] || converters["* " + current], !conv) for (conv2 in converters) if (tmp = conv2.split(" "), 
            tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], 
                dataTypes.unshift(tmp[1]));
                break;
            }
            if (conv !== !0) if (conv && s["throws"]) response = conv(response); else try {
                response = conv(response);
            } catch (e) {
                return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                };
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) jQuery.each(obj, function(i, v) {
            traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v ? i : "") + "]", v, traditional, add);
        }); else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj); else for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    }
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView;
    }
    var arr = [], slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, support = {}, document = window.document, version = "2.1.1", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return null != num ? 0 > num ? this[num + this.length] : this[num] : slice.call(this);
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            return ret.prevObject = this, ret.context = this.context, ret;
        },
        each: function(callback, args) {
            return jQuery.each(this, callback, args);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (0 > i ? len : 0);
            return this.pushStack(j >= 0 && len > j ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    }, jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, 
        i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, 
        i--); length > i; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], 
        copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
        clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, 
        target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target;
    }, jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return "function" === jQuery.type(obj);
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return null != obj && obj === obj.window;
        },
        isNumeric: function(obj) {
            return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
        },
        isPlainObject: function(obj) {
            return "object" !== jQuery.type(obj) || obj.nodeType || jQuery.isWindow(obj) ? !1 : obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ? !1 : !0;
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) return !1;
            return !0;
        },
        type: function(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            var script, indirect = eval;
            code = jQuery.trim(code), code && (1 === code.indexOf("use strict") ? (script = document.createElement("script"), 
            script.text = code, document.head.appendChild(script).parentNode.removeChild(script)) : indirect(code));
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
            var value, i = 0, length = obj.length, isArray = isArraylike(obj);
            if (args) {
                if (isArray) for (;length > i && (value = callback.apply(obj[i], args), value !== !1); i++) ; else for (i in obj) if (value = callback.apply(obj[i], args), 
                value === !1) break;
            } else if (isArray) for (;length > i && (value = callback.call(obj[i], i, obj[i]), 
            value !== !1); i++) ; else for (i in obj) if (value = callback.call(obj[i], i, obj[i]), 
            value === !1) break;
            return obj;
        },
        trim: function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            return null != arr && (isArraylike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] : arr) : push.call(ret, arr)), 
            ret;
        },
        inArray: function(elem, arr, i) {
            return null == arr ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            for (var len = +second.length, j = 0, i = first.length; len > j; j++) first[i++] = second[j];
            return first.length = i, first;
        },
        grep: function(elems, callback, invert) {
            for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++) callbackInverse = !callback(elems[i], i), 
            callbackInverse !== callbackExpect && matches.push(elems[i]);
            return matches;
        },
        map: function(elems, callback, arg) {
            var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
            if (isArray) for (;length > i; i++) value = callback(elems[i], i, arg), null != value && ret.push(value); else for (i in elems) value = callback(elems[i], i, arg), 
            null != value && ret.push(value);
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), 
            jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : void 0;
        },
        now: Date.now,
        support: support
    }), jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    var Sizzle = function(window) {
        function Sizzle(selector, context, results, seed) {
            var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
            if ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), 
            context = context || document, results = results || [], !selector || "string" != typeof selector) return results;
            if (1 !== (nodeType = context.nodeType) && 9 !== nodeType) return [];
            if (documentIsHTML && !seed) {
                if (match = rquickExpr.exec(selector)) if (m = match[1]) {
                    if (9 === nodeType) {
                        if (elem = context.getElementById(m), !elem || !elem.parentNode) return results;
                        if (elem.id === m) return results.push(elem), results;
                    } else if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), 
                    results;
                } else {
                    if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), 
                    results;
                    if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), 
                    results;
                }
                if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (nid = old = expando, newContext = context, newSelector = 9 === nodeType && selector, 
                    1 === nodeType && "object" !== context.nodeName.toLowerCase()) {
                        for (groups = tokenize(selector), (old = context.getAttribute("id")) ? nid = old.replace(rescape, "\\$&") : context.setAttribute("id", nid), 
                        nid = "[id='" + nid + "'] ", i = groups.length; i--; ) groups[i] = nid + toSelector(groups[i]);
                        newContext = rsibling.test(selector) && testContext(context.parentNode) || context, 
                        newSelector = groups.join(",");
                    }
                    if (newSelector) try {
                        return push.apply(results, newContext.querySelectorAll(newSelector)), results;
                    } catch (qsaError) {} finally {
                        old || context.removeAttribute("id");
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
            }
            var keys = [];
            return cache;
        }
        function markFunction(fn) {
            return fn[expando] = !0, fn;
        }
        function assert(fn) {
            var div = document.createElement("div");
            try {
                return !!fn(div);
            } catch (e) {
                return !1;
            } finally {
                div.parentNode && div.parentNode.removeChild(div), div = null;
            }
        }
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = attrs.length; i--; ) Expr.attrHandle[arr[i]] = handler;
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
            if (diff) return diff;
            if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return "input" === name && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return ("input" === name || "button" === name) && elem.type === type;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument, markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
                });
            });
        }
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== strundefined && context;
        }
        function setFilters() {}
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; len > i; i++) selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, checkNonElements = base && "parentNode" === dir, doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
            } : function(elem, context, xml) {
                var oldCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
                } else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) {
                    if (outerCache = elem[expando] || (elem[expando] = {}), (oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                    if (outerCache[dir] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
                }
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
                return !0;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; len > i; i++) Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++) (elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), 
            mapped && map.push(i));
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), 
            postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), 
            markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap), 
                postFilter(temp, [], context, xml), i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        for (i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
                    }
                } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), 
                postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut);
            });
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                return indexOf.call(checkContext, elem) > -1;
            }, implicitRelative, !0), matchers = [ function(elem, context, xml) {
                return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            } ]; len > i; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
                if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                    for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++) ;
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                        value: " " === tokens[i - 2].type ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                for (outermost && (outermostContext = context !== document && context); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0; matcher = elementMatchers[j++]; ) if (matcher(elem, context, xml)) {
                            results.push(elem);
                            break;
                        }
                        outermost && (dirruns = dirrunsUnique);
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem));
                }
                if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
                }
                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), 
                unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            return a === b && (hasDuplicate = !0), 0;
        }, strundefined = "undefined", MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function(elem) {
            for (var i = 0, len = this.length; len > i; i++) if (this[i] === elem) return i;
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", identifier = characterEncoding.replace("w", "w#"), attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + characterEncoding + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + characterEncoding + ")"),
            CLASS: new RegExp("^\\.(" + characterEncoding + ")"),
            TAG: new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
        };
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), 
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
                    target.length = j - 1;
                }
            };
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? "HTML" !== documentElement.nodeName : !1;
        }, setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, 
            docElem = doc.documentElement, documentIsHTML = !isXML(doc), parent && parent !== parent.top && (parent.addEventListener ? parent.addEventListener("unload", function() {
                setDocument();
            }, !1) : parent.attachEvent && parent.attachEvent("onunload", function() {
                setDocument();
            })), support.attributes = assert(function(div) {
                return div.className = "i", !div.getAttribute("className");
            }), support.getElementsByTagName = assert(function(div) {
                return div.appendChild(doc.createComment("")), !div.getElementsByTagName("*").length;
            }), support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
                return div.innerHTML = "<div class='a'></div><div class='a i'></div>", div.firstChild.className = "i", 
                2 === div.getElementsByClassName("i").length;
            }), support.getById = assert(function(div) {
                return docElem.appendChild(div).id = expando, !doc.getElementsByName || !doc.getElementsByName(expando).length;
            }), support.getById ? (Expr.find.ID = function(id, context) {
                if (typeof context.getElementById !== strundefined && documentIsHTML) {
                    var m = context.getElementById(id);
                    return m && m.parentNode ? [ m ] : [];
                }
            }, Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId;
                };
            }) : (delete Expr.find.ID, Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag) : void 0;
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
                    return tmp;
                }
                return results;
            }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                return typeof context.getElementsByClassName !== strundefined && documentIsHTML ? context.getElementsByClassName(className) : void 0;
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(doc.querySelectorAll)) && (assert(function(div) {
                div.innerHTML = "<select msallowclip=''><option selected=''></option></select>", 
                div.querySelectorAll("[msallowclip^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), 
                div.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), 
                div.querySelectorAll(":checked").length || rbuggyQSA.push(":checked");
            }), assert(function(div) {
                var input = doc.createElement("input");
                input.setAttribute("type", "hidden"), div.appendChild(input).setAttribute("name", "D"), 
                div.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 
                div.querySelectorAll(":enabled").length || rbuggyQSA.push(":enabled", ":disabled"), 
                div.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(div) {
                support.disconnectedMatch = matches.call(div, "div"), matches.call(div, "[s!='']:x"), 
                rbuggyMatches.push("!=", pseudos);
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), 
            hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, sortOrder = hasCompare ? function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0 : 4 & compare ? -1 : 1);
            } : function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
                if (aup === bup) return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
                for (;ap[i] === bp[i]; ) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            }, doc) : document;
        }, Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        }, Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), 
            !(!support.matchesSelector || !documentIsHTML || rbuggyMatches && rbuggyMatches.test(expr) || rbuggyQSA && rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
            } catch (e) {}
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        }, Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), 
            contains(context, elem);
        }, Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }, Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        }, Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), 
            results.sort(sortOrder), hasDuplicate) {
                for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
                for (;j--; ) results.splice(duplicates[j], 1);
            }
            return sortInput = null, results;
        }, getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent) return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
                } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
            } else for (;node = elem[i++]; ) ret += getText(node);
            return ret;
        }, Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), 
                    "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), 
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), 
                    match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), 
                    match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), 
                    match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0;
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
                        if (parent) {
                            if (simple) {
                                for (;dir; ) {
                                    for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                    start = dir = "only" === type && !start && "nextSibling";
                                }
                                return !0;
                            }
                            if (start = [ forward ? parent.firstChild : parent.lastChild ], forward && useCache) {
                                for (outerCache = parent[expando] || (parent[expando] = {}), cache = outerCache[type] || [], 
                                nodeIndex = cache[0] === dirruns && cache[1], diff = cache[0] === dirruns && cache[2], 
                                node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
                                    outerCache[type] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) diff = cache[1]; else for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((node[expando] || (node[expando] = {}))[type] = [ dirruns, diff ]), 
                            node !== elem)); ) ;
                            return diff -= last, diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ], 
                    Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf.call(seed, matched[i]), 
                        seed[idx] = !(matches[idx] = matched[i]);
                    }) : function(elem) {
                        return fn(elem, 0, args);
                    }) : fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
                    }) : function(elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), 
                    lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), 
                        elemLang === lang || 0 === elemLang.indexOf(lang + "-"); while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return !1;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: function(elem) {
                    return elem.disabled === !1;
                },
                disabled: function(elem) {
                    return elem.disabled === !0;
                },
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name;
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ 0 > argument ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; length > i; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; --i >= 0; ) matchIndexes.push(i);
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = 0 > argument ? argument + length : argument; ++i < length; ) matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        }, Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
            submit: !0,
            reset: !0
        }) Expr.pseudos[i] = createButtonPseudo(i);
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(), 
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), 
                groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }), soFar = soFar.slice(matched.length));
                for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                }), soFar = soFar.slice(matched.length));
                if (!matched) break;
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }, compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]), 
                cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), 
                cached.selector = selector;
            }
            return cached;
        }, select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], 
                    !context) return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], 
                !Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                    if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), 
                    results;
                    break;
                }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context), 
            results;
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, 
        support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(div1) {
            return 1 & div1.compareDocumentPosition(document.createElement("div"));
        }), assert(function(div) {
            return div.innerHTML = "<a href='#'></a>", "#" === div.firstChild.getAttribute("href");
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2);
        }), support.attributes && assert(function(div) {
            return div.innerHTML = "<input/>", div.firstChild.setAttribute("value", ""), "" === div.firstChild.getAttribute("value");
        }) || addHandle("value", function(elem, name, isXML) {
            return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue;
        }), assert(function(div) {
            return null == div.getAttribute("disabled");
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }), Sizzle;
    }(window);
    jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, 
    jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, 
    jQuery.contains = Sizzle.contains;
    var rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return 1 === elem.nodeType;
        }));
    }, jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;
            if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                for (i = 0; len > i; i++) if (jQuery.contains(self[i], this)) return !0;
            }));
            for (i = 0; len > i; i++) jQuery.find(selector, self[i], ret);
            return ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret), ret.selector = this.selector ? this.selector + " " + selector : selector, 
            ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], !1));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], !0));
        },
        is: function(selector) {
            return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
        var match, elem;
        if (!selector) return this;
        if ("string" == typeof selector) {
            if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [ null, selector, null ] : rquickExpr.exec(selector), 
            !match || !match[1] && context) return !context || context.jquery ? (context || rootjQuery).find(selector) : this.constructor(context).find(selector);
            if (match[1]) {
                if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), 
                rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this;
            }
            return elem = document.getElementById(match[2]), elem && elem.parentNode && (this.length = 1, 
            this[0] = elem), this.context = document, this.selector = selector, this;
        }
        return selector.nodeType ? (this.context = this[0] = selector, this.length = 1, 
        this) : jQuery.isFunction(selector) ? "undefined" != typeof rootjQuery.ready ? rootjQuery.ready(selector) : selector(jQuery) : (void 0 !== selector.selector && (this.selector = selector.selector, 
        this.context = selector.context), jQuery.makeArray(selector, this));
    };
    init.prototype = jQuery.fn, rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    jQuery.extend({
        dir: function(elem, dir, until) {
            for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; ) if (1 === elem.nodeType) {
                if (truncate && jQuery(elem).is(until)) break;
                matched.push(elem);
            }
            return matched;
        },
        sibling: function(n, elem) {
            for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
            return matched;
        }
    }), jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                for (var i = 0; l > i; i++) if (jQuery.contains(this, targets[i])) return !0;
            });
        },
        closest: function(selectors, context) {
            for (var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || "string" != typeof selectors ? jQuery(selectors, context || this.context) : 0; l > i; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
            }
            return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function(elem) {
            return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
        }
    }), jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        parents: function(elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), 
            this.length > 1 && (guaranteedUnique[name] || jQuery.unique(matched), rparentsprev.test(name) && matched.reverse()), 
            this.pushStack(matched);
        };
    });
    var rnotwhite = /\S+/g, optionsCache = {};
    jQuery.Callbacks = function(options) {
        options = "string" == typeof options ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
        var memory, fired, firing, firingStart, firingLength, firingIndex, list = [], stack = !options.once && [], fire = function(data) {
            for (memory = options.memory && data, fired = !0, firingIndex = firingStart || 0, 
            firingStart = 0, firingLength = list.length, firing = !0; list && firingLength > firingIndex; firingIndex++) if (list[firingIndex].apply(data[0], data[1]) === !1 && options.stopOnFalse) {
                memory = !1;
                break;
            }
            firing = !1, list && (stack ? stack.length && fire(stack.shift()) : memory ? list = [] : self.disable());
        }, self = {
            add: function() {
                if (list) {
                    var start = list.length;
                    !function add(args) {
                        jQuery.each(args, function(_, arg) {
                            var type = jQuery.type(arg);
                            "function" === type ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== type && add(arg);
                        });
                    }(arguments), firing ? firingLength = list.length : memory && (firingStart = start, 
                    fire(memory));
                }
                return this;
            },
            remove: function() {
                return list && jQuery.each(arguments, function(_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1), 
                    firing && (firingLength >= index && firingLength--, firingIndex >= index && firingIndex--);
                }), this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !(!list || !list.length);
            },
            empty: function() {
                return list = [], firingLength = 0, this;
            },
            disable: function() {
                return list = stack = memory = void 0, this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                return stack = void 0, memory || self.disable(), this;
            },
            locked: function() {
                return !stack;
            },
            fireWith: function(context, args) {
                return !list || fired && !stack || (args = args || [], args = [ context, args.slice ? args.slice() : args ], 
                firing ? stack.push(args) : fire(args)), this;
            },
            fire: function() {
                return self.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    }, jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ], [ "notify", "progress", jQuery.Callbacks("memory") ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    return deferred.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify) : newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments);
                            });
                        }), fns = null;
                    }).promise();
                },
                promise: function(obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            return promise.pipe = promise.then, jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[3];
                promise[tuple[1]] = list.add, stateString && list.add(function() {
                    state = stateString;
                }, tuples[1 ^ i][2].disable, tuples[2][2].lock), deferred[tuple[0]] = function() {
                    return deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments), 
                    this;
                }, deferred[tuple[0] + "With"] = list.fireWith;
            }), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
        },
        when: function(subordinate) {
            var progressValues, progressContexts, resolveContexts, i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = 1 !== length || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = 1 === remaining ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this, values[i] = arguments.length > 1 ? slice.call(arguments) : value, 
                    values === progressValues ? deferred.notifyWith(contexts, values) : --remaining || deferred.resolveWith(contexts, values);
                };
            };
            if (length > 1) for (progressValues = new Array(length), progressContexts = new Array(length), 
            resolveContexts = new Array(length); length > i; i++) resolveValues[i] && jQuery.isFunction(resolveValues[i].promise) ? resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)) : --remaining;
            return remaining || deferred.resolveWith(resolveContexts, resolveValues), deferred.promise();
        }
    });
    var readyList;
    jQuery.fn.ready = function(fn) {
        return jQuery.ready.promise().done(fn), this;
    }, jQuery.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0);
        },
        ready: function(wait) {
            (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || (readyList.resolveWith(document, [ jQuery ]), 
            jQuery.fn.triggerHandler && (jQuery(document).triggerHandler("ready"), jQuery(document).off("ready"))));
        }
    }), jQuery.ready.promise = function(obj) {
        return readyList || (readyList = jQuery.Deferred(), "complete" === document.readyState ? setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed, !1), 
        window.addEventListener("load", completed, !1))), readyList.promise(obj);
    }, jQuery.ready.promise();
    var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = null == key;
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key) jQuery.access(elems, fn, i, key[i], !0, emptyGet, raw);
        } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), 
        bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
        })), fn)) for (;len > i; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    jQuery.acceptData = function(owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType;
    }, Data.uid = 1, Data.accepts = jQuery.acceptData, Data.prototype = {
        key: function(owner) {
            if (!Data.accepts(owner)) return 0;
            var descriptor = {}, unlock = owner[this.expando];
            if (!unlock) {
                unlock = Data.uid++;
                try {
                    descriptor[this.expando] = {
                        value: unlock
                    }, Object.defineProperties(owner, descriptor);
                } catch (e) {
                    descriptor[this.expando] = unlock, jQuery.extend(owner, descriptor);
                }
            }
            return this.cache[unlock] || (this.cache[unlock] = {}), unlock;
        },
        set: function(owner, data, value) {
            var prop, unlock = this.key(owner), cache = this.cache[unlock];
            if ("string" == typeof data) cache[data] = value; else if (jQuery.isEmptyObject(cache)) jQuery.extend(this.cache[unlock], data); else for (prop in data) cache[prop] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            var cache = this.cache[this.key(owner)];
            return void 0 === key ? cache : cache[key];
        },
        access: function(owner, key, value) {
            var stored;
            return void 0 === key || key && "string" == typeof key && void 0 === value ? (stored = this.get(owner, key), 
            void 0 !== stored ? stored : this.get(owner, jQuery.camelCase(key))) : (this.set(owner, key, value), 
            void 0 !== value ? value : key);
        },
        remove: function(owner, key) {
            var i, name, camel, unlock = this.key(owner), cache = this.cache[unlock];
            if (void 0 === key) this.cache[unlock] = {}; else {
                jQuery.isArray(key) ? name = key.concat(key.map(jQuery.camelCase)) : (camel = jQuery.camelCase(key), 
                key in cache ? name = [ key, camel ] : (name = camel, name = name in cache ? [ name ] : name.match(rnotwhite) || [])), 
                i = name.length;
                for (;i--; ) delete cache[name[i]];
            }
        },
        hasData: function(owner) {
            return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
            owner[this.expando] && delete this.cache[owner[this.expando]];
        }
    };
    var data_priv = new Data(), data_user = new Data(), rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
    jQuery.extend({
        hasData: function(elem) {
            return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
            return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
            data_user.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            data_priv.remove(elem, name);
        }
    }), jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (void 0 === key) {
                if (this.length && (data = data_user.get(elem), 1 === elem.nodeType && !data_priv.get(elem, "hasDataAttrs"))) {
                    for (i = attrs.length; i--; ) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), 
                    dataAttr(elem, name, data[name])));
                    data_priv.set(elem, "hasDataAttrs", !0);
                }
                return data;
            }
            return "object" == typeof key ? this.each(function() {
                data_user.set(this, key);
            }) : access(this, function(value) {
                var data, camelKey = jQuery.camelCase(key);
                if (elem && void 0 === value) {
                    if (data = data_user.get(elem, key), void 0 !== data) return data;
                    if (data = data_user.get(elem, camelKey), void 0 !== data) return data;
                    if (data = dataAttr(elem, camelKey, void 0), void 0 !== data) return data;
                } else this.each(function() {
                    var data = data_user.get(this, camelKey);
                    data_user.set(this, camelKey, value), -1 !== key.indexOf("-") && void 0 !== data && data_user.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, !0);
        },
        removeData: function(key) {
            return this.each(function() {
                data_user.remove(this, key);
            });
        }
    }), jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            return elem ? (type = (type || "fx") + "queue", queue = data_priv.get(elem, type), 
            data && (!queue || jQuery.isArray(data) ? queue = data_priv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), 
            queue || []) : void 0;
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), 
            delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return data_priv.get(elem, key) || data_priv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    data_priv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    }), jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                --count || defer.resolveWith(elements, [ elements ]);
            };
            for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) tmp = data_priv.get(elements[i], type + "queueHooks"), 
            tmp && tmp.empty && (count++, tmp.empty.add(resolve));
            return resolve(), defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, cssExpand = [ "Top", "Right", "Bottom", "Left" ], isHidden = function(elem, el) {
        return elem = el || elem, "none" === jQuery.css(elem, "display") || !jQuery.contains(elem.ownerDocument, elem);
    }, rcheckableType = /^(?:checkbox|radio)$/i;
    !function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), 
        div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, 
        div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
    }();
    var strundefined = "undefined";
    support.focusinBubbles = "onfocusin" in window;
    var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.get(elem);
            if (elemData) for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, 
            selector = handleObjIn.selector), handler.guid || (handler.guid = jQuery.guid++), 
            (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            }), types = (types || "").match(rnotwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [], 
            type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, 
            type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, 
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
            }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, 
            special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle, !1)), 
            special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), 
            selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), 
            jQuery.event.global[type] = !0);
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = data_priv.hasData(elem) && data_priv.get(elem);
            if (elemData && (events = elemData.events)) {
                for (types = (types || "").match(rnotwhite) || [ "" ], t = types.length; t--; ) if (tmp = rtypenamespace.exec(types[t]) || [], 
                type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                    for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, 
                    handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), 
                    handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                    origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), 
                    delete events[type]);
                } else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                jQuery.isEmptyObject(events) && (delete elemData.handle, data_priv.remove(elem, "events"));
            }
        },
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") >= 0 && (namespaces = type.split("."), 
            type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, 
            event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), 
            event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), 
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] : jQuery.makeArray(data, [ event ]), 
            special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), 
                    tmp = cur;
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
                for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) event.type = i > 1 ? bubbleType : special.bindType || type, 
                handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle"), 
                handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && jQuery.acceptData(cur) && (event.result = handle.apply(cur, data), 
                event.result === !1 && event.preventDefault());
                return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !jQuery.acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], 
                tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, 
                tmp && (elem[ontype] = tmp)), event.result;
            }
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event);
            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (data_priv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            if (args[0] = event, event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem, 
                j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) && (event.handleObj = handleObj, 
                event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), 
                void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                return special.postDispatch && special.postDispatch.call(this, event), event.result;
            }
        },
        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && (!event.button || "click" !== event.type)) for (;cur !== this; cur = cur.parentNode || this) if (cur.disabled !== !0 || "click" !== event.type) {
                for (matches = [], i = 0; delegateCount > i; i++) handleObj = handlers[i], sel = handleObj.selector + " ", 
                void 0 === matches[sel] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [ cur ]).length), 
                matches[sel] && matches.push(handleObj);
                matches.length && handlerQueue.push({
                    elem: cur,
                    handlers: matches
                });
            }
            return delegateCount < handlers.length && handlerQueue.push({
                elem: this,
                handlers: handlers.slice(delegateCount)
            }), handlerQueue;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                return null == event.which && (event.which = null != original.charCode ? original.charCode : original.keyCode), 
                event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;
                return null == event.pageX && null != original.clientX && (eventDoc = event.target.ownerDocument || document, 
                doc = eventDoc.documentElement, body = eventDoc.body, event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0), 
                event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)), 
                event.which || void 0 === button || (event.which = 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0), 
                event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) return event;
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
            for (fixHook || (this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {}), 
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props, event = new jQuery.Event(originalEvent), 
            i = copy.length; i--; ) prop = copy[i], event[prop] = originalEvent[prop];
            return event.target || (event.target = document), 3 === event.target.nodeType && (event.target = event.target.parentNode), 
            fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    return this !== safeActiveElement() && this.focus ? (this.focus(), !1) : void 0;
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return "checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
                }
            }
        },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: !0,
                originalEvent: {}
            });
            bubble ? jQuery.event.trigger(e, null, elem) : jQuery.event.dispatch.call(elem, e), 
            e.isDefaultPrevented() && event.preventDefault();
        }
    }, jQuery.removeEvent = function(elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle, !1);
    }, jQuery.Event = function(src, props) {
        return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, 
        this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse) : this.type = src, 
        props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), 
        void (this[jQuery.expando] = !0)) : new jQuery.Event(src, props);
    }, jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue, e && e.preventDefault && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue, e && e.stopPropagation && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue, e && e.stopImmediatePropagation && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, 
                ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
            }
        };
    }), support.focusinBubbles || jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), !0);
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0), data_priv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this, attaches = data_priv.access(doc, fix) - 1;
                attaches ? data_priv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), 
                data_priv.remove(doc, fix));
            }
        };
    }), jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if ("object" == typeof types) {
                "string" != typeof selector && (data = data || selector, selector = void 0);
                for (type in types) this.on(type, selector, data, types[type], one);
                return this;
            }
            if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, 
            data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse; else if (!fn) return this;
            return 1 === one && (origFn = fn, fn = function(event) {
                return jQuery().off(event), origFn.apply(this, arguments);
            }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), this.each(function() {
                jQuery.event.add(this, types, fn, data, selector);
            });
        },
        one: function(types, selector, data, fn) {
            return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, 
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), 
            this;
            if ("object" == typeof types) {
                for (type in types) this.off(type, selector, types[type]);
                return this;
            }
            return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), 
            fn === !1 && (fn = returnFalse), this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        },
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0;
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td, jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) for (destElements = getAll(clone), 
            srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++) fixInput(srcElements[i], destElements[i]);
            if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem), 
            destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++) cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
            return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), 
            clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
            for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; l > i; i++) if (elem = elems[i], 
            elem || 0 === elem) if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem); else if (rhtml.test(elem)) {
                for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(), 
                wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2], 
                j = wrap[0]; j--; ) tmp = tmp.lastChild;
                jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
            } else nodes.push(context.createTextNode(elem));
            for (fragment.textContent = "", i = 0; elem = nodes[i++]; ) if ((!selection || -1 === jQuery.inArray(elem, selection)) && (contains = jQuery.contains(elem.ownerDocument, elem), 
            tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), 
            scripts)) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
            return fragment;
        },
        cleanData: function(elems) {
            for (var data, elem, type, key, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) {
                if (jQuery.acceptData(elem) && (key = elem[data_priv.expando], key && (data = data_priv.cache[key]))) {
                    if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                    data_priv.cache[key] && delete data_priv.cache[key];
                }
                delete data_user.cache[elem[data_user.expando]];
            }
        }
    }), jQuery.fn.extend({
        text: function(value) {
            return access(this, function(value) {
                return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                    (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = value);
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        remove: function(selector, keepData) {
            for (var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0; null != (elem = elems[i]); i++) keepData || 1 !== elem.nodeType || jQuery.cleanData(getAll(elem)), 
            elem.parentNode && (keepData && jQuery.contains(elem.ownerDocument, elem) && setGlobalEval(getAll(elem, "script")), 
            elem.parentNode.removeChild(elem));
            return this;
        },
        empty: function() {
            for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
            elem.textContent = "");
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, 
            this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (;l > i; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
                        elem.innerHTML = value);
                        elem = 0;
                    } catch (e) {}
                }
                elem && this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var arg = arguments[0];
            return this.domManip(arguments, function(elem) {
                arg = this.parentNode, jQuery.cleanData(getAll(this)), arg && arg.replaceChild(elem, this);
            }), arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
            return this.remove(selector, !0);
        },
        domManip: function(args, callback) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return this.each(function(index) {
                var self = set.eq(index);
                isFunction && (args[0] = value.call(this, index, self.html())), self.domManip(args, callback);
            });
            if (l && (fragment = jQuery.buildFragment(args, this[0].ownerDocument, !1, this), 
            first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), 
            first)) {
                for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++) node = fragment, 
                i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), 
                callback.call(this[i], node, i);
                if (hasScripts) for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), 
                i = 0; hasScripts > i; i++) node = scripts[i], rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : jQuery.globalEval(node.textContent.replace(rcleanScript, "")));
            }
            return this;
        }
    }), jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++) elems = i === last ? this : this.clone(!0), 
            jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
            return this.pushStack(ret);
        };
    });
    var iframe, elemdisplay = {}, rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function(elem) {
        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    };
    !function() {
        function computePixelPositionAndBoxSizingReliable() {
            div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
            div.innerHTML = "", docElem.appendChild(container);
            var divStyle = window.getComputedStyle(div, null);
            pixelPositionVal = "1%" !== divStyle.top, boxSizingReliableVal = "4px" === divStyle.width, 
            docElem.removeChild(container);
        }
        var pixelPositionVal, boxSizingReliableVal, docElem = document.documentElement, container = document.createElement("div"), div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", 
        support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", 
        container.appendChild(div), window.getComputedStyle && jQuery.extend(support, {
            pixelPosition: function() {
                return computePixelPositionAndBoxSizingReliable(), pixelPositionVal;
            },
            boxSizingReliable: function() {
                return null == boxSizingReliableVal && computePixelPositionAndBoxSizingReliable(), 
                boxSizingReliableVal;
            },
            reliableMarginRight: function() {
                var ret, marginDiv = div.appendChild(document.createElement("div"));
                return marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
                marginDiv.style.marginRight = marginDiv.style.width = "0", div.style.width = "1px", 
                docElem.appendChild(container), ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight), 
                docElem.removeChild(container), ret;
            }
        }));
    }(), jQuery.swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        for (name in options) elem.style[name] = old[name];
        return ret;
    };
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"), rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"), cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return "" === ret ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)), 
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, 
                "string" === type && (ret = rrelNum.exec(value)) && (value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)), 
                type = "number"), null != value && value === value && ("number" !== type || jQuery.cssNumber[origName] || (value += "px"), 
                support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), 
                hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), 
                void 0);
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)), 
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), 
            void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), 
            "" === extra || extra ? (num = parseFloat(val), extra === !0 || jQuery.isNumeric(num) ? num || 0 : val) : val;
        }
    }), jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                return computed ? rdisplayswap.test(jQuery.css(elem, "display")) && 0 === elem.offsetWidth ? jQuery.swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra);
                }) : getWidthOrHeight(elem, name, extra) : void 0;
            },
            set: function(elem, value, extra) {
                var styles = extra && getStyles(elem);
                return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles) : 0);
            }
        };
    }), jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        return computed ? jQuery.swap(elem, {
            display: "inline-block"
        }, curCSS, [ elem, "marginRight" ]) : void 0;
    }), jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [ value ]; 4 > i; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
    }), jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    for (styles = getStyles(elem), len = name.length; len > i; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map;
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, !0);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                isHidden(this) ? jQuery(this).show() : jQuery(this).hide();
            });
        }
    }), jQuery.Tween = Tween, Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem, this.prop = prop, this.easing = easing || "swing", this.options = options, 
            this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, 
            this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this;
        }
    }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                return null == tween.elem[tween.prop] || tween.elem.style && null != tween.elem.style[tween.prop] ? (result = jQuery.css(tween.elem, tween.prop, ""), 
                result && "auto" !== result ? result : 0) : tween.elem[tween.prop];
            },
            set: function(tween) {
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : tween.elem.style && (null != tween.elem.style[jQuery.cssProps[tween.prop]] || jQuery.cssHooks[tween.prop]) ? jQuery.style(tween.elem, tween.prop, tween.now + tween.unit) : tween.elem[tween.prop] = tween.now;
            }
        }
    }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
        }
    }, jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        }
    }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), rrun = /queueHooks$/, animationPrefilters = [ defaultPrefilter ], tweeners = {
        "*": [ function(prop, value) {
            var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"), start = (jQuery.cssNumber[prop] || "px" !== unit && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
            if (start && start[3] !== unit) {
                unit = unit || start[3], parts = parts || [], start = +target || 1;
                do scale = scale || ".5", start /= scale, jQuery.style(tween.elem, prop, start + unit); while (scale !== (scale = tween.cur() / target) && 1 !== scale && --maxIterations);
            }
            return parts && (start = tween.start = +start || +target || 0, tween.unit = unit, 
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2]), tween;
        } ]
    };
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            jQuery.isFunction(props) ? (callback = props, props = [ "*" ]) : props = props.split(" ");
            for (var prop, index = 0, length = props.length; length > index; index++) prop = props[index], 
            tweeners[prop] = tweeners[prop] || [], tweeners[prop].unshift(callback);
        },
        prefilter: function(callback, prepend) {
            prepend ? animationPrefilters.unshift(callback) : animationPrefilters.push(callback);
        }
    }), jQuery.speed = function(speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        return opt.duration = jQuery.fx.off ? 0 : "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default, 
        (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, 
        opt.complete = function() {
            jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
        }, opt;
    }, jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHidden).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || data_priv.get(this, "finish")) && anim.stop(!0);
            };
            return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop, stop(gotoEnd);
            };
            return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), 
            clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function() {
                var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = data_priv.get(this);
                if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), 
                dequeue = !1, timers.splice(index, 1));
                (dequeue || !gotoEnd) && jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            return type !== !1 && (type = type || "fx"), this.each(function() {
                var index, data = data_priv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), 
                index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), 
                timers.splice(index, 1));
                for (index = 0; length > index; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                delete data.finish;
            });
        }
    }), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback);
        };
    }), jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    }), jQuery.timers = [], jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(), fxNow = void 0;
    }, jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop();
    }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
        timerId || (timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval));
    }, jQuery.fx.stop = function() {
        clearInterval(timerId), timerId = null;
    }, jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, jQuery.fn.delay = function(time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", 
        this.queue(type, function(next, hooks) {
            var timeout = setTimeout(next, time);
            hooks.stop = function() {
                clearTimeout(timeout);
            };
        });
    }, function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, 
        select.disabled = !0, support.optDisabled = !opt.disabled, input = document.createElement("input"), 
        input.value = "t", input.type = "radio", support.radioValue = "t" === input.value;
    }();
    var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    }), jQuery.extend({
        attr: function(elem, name, value) {
            var hooks, ret, nType = elem.nodeType;
            if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return typeof elem.getAttribute === strundefined ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (name = name.toLowerCase(), 
            hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook)), 
            void 0 === value ? hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), 
            null == ret ? void 0 : ret) : null !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), 
            value) : void jQuery.removeAttr(elem, name));
        },
        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
            if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) propName = jQuery.propFix[name] || name, 
            jQuery.expr.match.bool.test(name) && (elem[propName] = !1), elem.removeAttribute(name);
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        return elem.setAttribute("type", value), val && (elem.value = val), value;
                    }
                }
            }
        }
    }), boolHook = {
        set: function(elem, value, name) {
            return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), 
            name;
        }
    }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            return isXML || (handle = attrHandle[name], attrHandle[name] = ret, ret = null != getter(elem, name, isXML) ? name.toLowerCase() : null, 
            attrHandle[name] = handle), ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    }), jQuery.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (elem && 3 !== nType && 8 !== nType && 2 !== nType) return notxml = 1 !== nType || !jQuery.isXMLDoc(elem), 
            notxml && (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), 
            void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
                }
            }
        }
    }), support.optSelected || (jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.parentNode && parent.parentNode.selectedIndex, null;
        }
    }), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });
    var rclass = /[\t\r\n\f]/g;
    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = "string" == typeof value && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, this.className));
            });
            if (proceed) for (classes = (value || "").match(rnotwhite) || []; len > i; i++) if (elem = this[i], 
            cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ")) {
                for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                finalValue = jQuery.trim(cur), elem.className !== finalValue && (elem.className = finalValue);
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, clazz, j, finalValue, proceed = 0 === arguments.length || "string" == typeof value && value, i = 0, len = this.length;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, this.className));
            });
            if (proceed) for (classes = (value || "").match(rnotwhite) || []; len > i; i++) if (elem = this[i], 
            cur = 1 === elem.nodeType && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "")) {
                for (j = 0; clazz = classes[j++]; ) for (;cur.indexOf(" " + clazz + " ") >= 0; ) cur = cur.replace(" " + clazz + " ", " ");
                finalValue = value ? jQuery.trim(cur) : "", elem.className !== finalValue && (elem.className = finalValue);
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
            }) : this.each(function() {
                if ("string" === type) for (var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else (type === strundefined || "boolean" === type) && (this.className && data_priv.set(this, "__className__", this.className), 
                this.className = this.className || value === !1 ? "" : data_priv.get(this, "__className__") || "");
            });
        },
        hasClass: function(selector) {
            for (var className = " " + selector + " ", i = 0, l = this.length; l > i; i++) if (1 === this[i].nodeType && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) return !0;
            return !1;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            {
                if (arguments.length) return isFunction = jQuery.isFunction(value), this.each(function(i) {
                    var val;
                    1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, 
                    null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function(value) {
                        return null == value ? "" : value + "";
                    })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], 
                    hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
                });
                if (elem) return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], 
                hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, 
                "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret);
            }
        }
    }), jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return null != val ? val : jQuery.trim(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type || 0 > index, values = one ? null : [], max = one ? index + 1 : options.length, i = 0 > index ? max : one ? index : 0; max > i; i++) if (option = options[i], 
                    !(!option.selected && i !== index || (support.optDisabled ? option.disabled : null !== option.getAttribute("disabled")) || option.parentNode.disabled && jQuery.nodeName(option.parentNode, "optgroup"))) {
                        if (value = jQuery(option).val(), one) return value;
                        values.push(value);
                    }
                    return values;
                },
                set: function(elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) option = options[i], 
                    (option.selected = jQuery.inArray(option.value, values) >= 0) && (optionSet = !0);
                    return optionSet || (elem.selectedIndex = -1), values;
                }
            }
        }
    }), jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0 : void 0;
            }
        }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
            return null === elem.getAttribute("value") ? "on" : elem.value;
        });
    }), jQuery.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    }), jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    });
    var nonce = jQuery.now(), rquery = /\?/;
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    }, jQuery.parseXML = function(data) {
        var xml, tmp;
        if (!data || "string" != typeof data) return null;
        try {
            tmp = new DOMParser(), xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
            xml = void 0;
        }
        return (!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data), 
        xml;
    };
    var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = "*/".concat("*");
    try {
        ajaxLocation = location.href;
    } catch (e) {
        ajaxLocation = document.createElement("a"), ajaxLocation.href = "", ajaxLocation = ajaxLocation.href;
    }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [], jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ajaxLocation,
            type: "GET",
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": jQuery.parseJSON,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                2 !== state && (state = 2, timeoutTimer && clearTimeout(timeoutTimer), transport = void 0, 
                responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && 300 > status || 304 === status, 
                responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), 
                isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), 
                modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), 
                modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, 
                success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, 
                (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), 
                jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", 
                isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) : deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]), 
                jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]), 
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]), 
                --jQuery.active || jQuery.event.trigger("ajaxStop")));
            }
            "object" == typeof url && (options = url, url = void 0), options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (2 === state) {
                        if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return null == match ? null : match;
                },
                getAllResponseHeaders: function() {
                    return 2 === state ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    return state || (name = requestHeadersNames[lname] = requestHeadersNames[lname] || name, 
                    requestHeaders[name] = value), this;
                },
                overrideMimeType: function(type) {
                    return state || (s.mimeType = type), this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) if (2 > state) for (code in map) statusCode[code] = [ statusCode[code], map[code] ]; else jqXHR.always(map[jqXHR.status]);
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText), done(0, finalText), this;
                }
            };
            if (deferred.promise(jqXHR).complete = completeDeferred.add, jqXHR.success = jqXHR.done, 
            jqXHR.error = jqXHR.fail, s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"), 
            s.type = options.method || options.type || s.method || s.type, s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [ "" ], 
            null == s.crossDomain && (parts = rurl.exec(s.url.toLowerCase()), s.crossDomain = !(!parts || parts[1] === ajaxLocParts[1] && parts[2] === ajaxLocParts[2] && (parts[3] || ("http:" === parts[1] ? "80" : "443")) === (ajaxLocParts[3] || ("http:" === ajaxLocParts[1] ? "80" : "443")))), 
            s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), 
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), 2 === state) return jqXHR;
            fireGlobals = s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), 
            s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url, 
            s.hasContent || (s.data && (cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data, 
            delete s.data), s.cache === !1 && (s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++)), 
            s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), 
            jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), 
            (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), 
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || 2 === state)) return jqXHR.abort();
            strAbort = "abort";
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) jqXHR[i](s[i]);
            if (transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]), 
                s.async && s.timeout > 0 && (timeoutTimer = setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout));
                try {
                    state = 1, transport.send(requestHeaders, done);
                } catch (e) {
                    if (!(2 > state)) throw e;
                    done(-1, e);
                }
            } else done(-1, "No Transport");
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
        }
    }), jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), 
            jQuery.ajax({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            });
        };
    }), jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    }), jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            "throws": !0
        });
    }, jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapAll(html.call(this, i));
            }) : (this[0] && (wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), 
            wrap.map(function() {
                for (var elem = this; elem.firstElementChild; ) elem = elem.firstElementChild;
                return elem;
            }).append(this)), this);
        },
        wrapInner: function(html) {
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            }) : this.each(function() {
                var self = jQuery(this), contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html);
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                jQuery.nodeName(this, "body") || jQuery(this).replaceWith(this.childNodes);
            }).end();
        }
    }), jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
    }, jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
    };
    var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {
            value = jQuery.isFunction(value) ? value() : null == value ? "" : value, s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
        if (void 0 === traditional && (traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional), 
        jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
            add(this.name, this.value);
        }); else for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        return s.join("&").replace(r20, "+");
    }, jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    }), jQuery.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest();
        } catch (e) {}
    };
    var xhrId = 0, xhrCallbacks = {}, xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    window.ActiveXObject && jQuery(window).on("unload", function() {
        for (var key in xhrCallbacks) xhrCallbacks[key]();
    }), support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, 
    jQuery.ajaxTransport(function(options) {
        var callback;
        return support.cors || xhrSupported && !options.crossDomain ? {
            send: function(headers, complete) {
                var i, xhr = options.xhr(), id = ++xhrId;
                if (xhr.open(options.type, options.url, options.async, options.username, options.password), 
                options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), 
                options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                for (i in headers) xhr.setRequestHeader(i, headers[i]);
                callback = function(type) {
                    return function() {
                        callback && (delete xhrCallbacks[id], callback = xhr.onload = xhr.onerror = null, 
                        "abort" === type ? xhr.abort() : "error" === type ? complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "string" == typeof xhr.responseText ? {
                            text: xhr.responseText
                        } : void 0, xhr.getAllResponseHeaders()));
                    };
                }, xhr.onload = callback(), xhr.onerror = callback("error"), callback = xhrCallbacks[id] = callback("abort");
                try {
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    if (callback) throw e;
                }
            },
            abort: function() {
                callback && callback();
            }
        } : void 0;
    }), jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(text) {
                return jQuery.globalEval(text), text;
            }
        }
    }), jQuery.ajaxPrefilter("script", function(s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET");
    }), jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        async: !0,
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type);
                    }), document.head.appendChild(script[0]);
                },
                abort: function() {
                    callback && callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0, callback;
        }
    }), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, 
        jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), 
        s.converters["script json"] = function() {
            return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
            responseContainer = arguments;
        }, jqXHR.always(function() {
            window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, 
            oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), 
            responseContainer = overwritten = void 0;
        }), "script") : void 0;
    }), jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || "string" != typeof data) return null;
        "boolean" == typeof context && (keepScripts = context, context = !1), context = context || document;
        var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
        return parsed ? [ context.createElement(parsed[1]) ] : (parsed = jQuery.buildFragment([ data ], context, scripts), 
        scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
    };
    var _load = jQuery.fn.load;
    jQuery.fn.load = function(url, params, callback) {
        if ("string" != typeof url && _load) return _load.apply(this, arguments);
        var selector, type, response, self = this, off = url.indexOf(" ");
        return off >= 0 && (selector = jQuery.trim(url.slice(off)), url = url.slice(0, off)), 
        jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), 
        self.length > 0 && jQuery.ajax({
            url: url,
            type: type,
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).complete(callback && function(jqXHR, status) {
            self.each(callback, response || [ jqXHR.responseText, status, jqXHR ]);
        }), this;
    }, jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    };
    var docElem = window.document.documentElement;
    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), 
            curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, 
            calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, 
            curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), 
            jQuery.isFunction(options) && (options = options.call(elem, i, curOffset)), null != options.top && (props.top = options.top - curOffset.top + curTop), 
            null != options.left && (props.left = options.left - curOffset.left + curLeft), 
            "using" in options ? options.using.call(elem, props) : curElem.css(props);
        }
    }, jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;
            if (doc) return docElem = doc.documentElement, jQuery.contains(docElem, elem) ? (typeof elem.getBoundingClientRect !== strundefined && (box = elem.getBoundingClientRect()), 
            win = getWindow(doc), {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            }) : box;
        },
        position: function() {
            if (this[0]) {
                var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
                return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), 
                offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), 
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", !0)), 
                {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var offsetParent = this.offsetParent || docElem; offsetParent && !jQuery.nodeName(offsetParent, "html") && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
                return offsetParent || docElem;
            });
        }
    }), jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                return void 0 === val ? win ? win[prop] : elem[method] : void (win ? win.scrollTo(top ? window.pageXOffset : val, top ? val : window.pageYOffset) : elem[method] = val);
            }, method, val, arguments.length, null);
        };
    }), jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0;
        });
    }), jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    return jQuery.isWindow(elem) ? elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, 
                    Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : void 0, chainable, null);
            };
        });
    }), jQuery.fn.size = function() {
        return this.length;
    }, jQuery.fn.andSelf = jQuery.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return jQuery;
    });
    var _jQuery = window.jQuery, _$ = window.$;
    return jQuery.noConflict = function(deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), 
        jQuery;
    }, typeof noGlobal === strundefined && (window.jQuery = window.$ = jQuery), jQuery;
}), function(undefined) {
    function dfl(a, b, c) {
        switch (arguments.length) {
          case 2:
            return null != a ? a : b;

          case 3:
            return null != a ? a : null != b ? b : c;

          default:
            throw new Error("Implement me");
        }
    }
    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }
    function defaultParsingFlags() {
        return {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1
        };
    }
    function printMsg(msg) {
        moment.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg);
    }
    function deprecate(msg, fn) {
        var firstTime = !0;
        return extend(function() {
            return firstTime && (printMsg(msg), firstTime = !1), fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        deprecations[name] || (printMsg(msg), deprecations[name] = !0);
    }
    function padToken(func, count) {
        return function(a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function(a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }
    function monthDiff(a, b) {
        var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
        return 0 > b - anchor ? (anchor2 = a.clone().add(wholeMonthDiff - 1, "months"), 
        adjust = (b - anchor) / (anchor - anchor2)) : (anchor2 = a.clone().add(wholeMonthDiff + 1, "months"), 
        adjust = (b - anchor) / (anchor2 - anchor)), -(wholeMonthDiff + adjust);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? (isPm = locale.isPM(meridiem), 
        isPm && 12 > hour && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour;
    }
    function Locale() {}
    function Moment(config, skipOverflow) {
        skipOverflow !== !1 && checkOverflow(config), copyConfig(this, config), this._d = new Date(+config._d), 
        updateInProgress === !1 && (updateInProgress = !0, moment.updateOffset(this), updateInProgress = !1);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 36e5 * hours, 
        this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, 
        this._data = {}, this._locale = moment.localeData(), this._bubble();
    }
    function extend(a, b) {
        for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
        return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), 
        a;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if ("undefined" != typeof from._isAMomentObject && (to._isAMomentObject = from._isAMomentObject), 
        "undefined" != typeof from._i && (to._i = from._i), "undefined" != typeof from._f && (to._f = from._f), 
        "undefined" != typeof from._l && (to._l = from._l), "undefined" != typeof from._strict && (to._strict = from._strict), 
        "undefined" != typeof from._tzm && (to._tzm = from._tzm), "undefined" != typeof from._isUTC && (to._isUTC = from._isUTC), 
        "undefined" != typeof from._offset && (to._offset = from._offset), "undefined" != typeof from._pf && (to._pf = from._pf), 
        "undefined" != typeof from._locale && (to._locale = from._locale), momentProperties.length > 0) for (i in momentProperties) prop = momentProperties[i], 
        val = from[prop], "undefined" != typeof val && (to[prop] = val);
        return to;
    }
    function absRound(number) {
        return 0 > number ? Math.ceil(number) : Math.floor(number);
    }
    function leftZeroFill(number, targetLength, forceSign) {
        for (var output = "" + Math.abs(number), sign = number >= 0; output.length < targetLength; ) output = "0" + output;
        return (sign ? forceSign ? "+" : "" : "-") + output;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), 
        base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), 
        res;
    }
    function momentsDifference(base, other) {
        var res;
        return other = makeAs(other, base), base.isBefore(other) ? res = positiveMomentsDifference(base, other) : (res = positiveMomentsDifference(other, base), 
        res.milliseconds = -res.milliseconds, res.months = -res.months), res;
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period)."), 
            tmp = val, val = period, period = tmp), val = "string" == typeof val ? +val : val, 
            dur = moment.duration(val, period), addOrSubtractDurationFromMoment(this, dur, direction), 
            this;
        };
    }
    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = null == updateOffset ? !0 : updateOffset, milliseconds && mom._d.setTime(+mom._d + milliseconds * isAdding), 
        days && rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding), months && rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding), 
        updateOffset && moment.updateOffset(mom, days || months);
    }
    function isArray(input) {
        return "[object Array]" === Object.prototype.toString.call(input);
    }
    function isDate(input) {
        return "[object Date]" === Object.prototype.toString.call(input) || input instanceof Date;
    }
    function compareArrays(array1, array2, dontConvert) {
        var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
        for (i = 0; len > i; i++) (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
        return diffs + lengthDiff;
    }
    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedProp, prop, normalizedInput = {};
        for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop), 
        normalizedProp && (normalizedInput[normalizedProp] = inputObject[prop]));
        return normalizedInput;
    }
    function makeList(field) {
        var count, setter;
        if (0 === field.indexOf("week")) count = 7, setter = "day"; else {
            if (0 !== field.indexOf("month")) return;
            count = 12, setter = "month";
        }
        moment[field] = function(format, index) {
            var i, getter, method = moment._locale[field], results = [];
            if ("number" == typeof format && (index = format, format = undefined), getter = function(i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || "");
            }, null != index) return getter(index);
            for (i = 0; count > i; i++) results.push(getter(i));
            return results;
        };
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        return 0 !== coercedNumber && isFinite(coercedNumber) && (value = coercedNumber >= 0 ? Math.floor(coercedNumber) : Math.ceil(coercedNumber)), 
        value;
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([ year, 11, 31 + dow - doy ]), dow, doy).week;
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function checkOverflow(m) {
        var overflow;
        m._a && -2 === m._pf.overflow && (overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || 24 === m._a[HOUR] && (0 !== m._a[MINUTE] || 0 !== m._a[SECOND] || 0 !== m._a[MILLISECOND]) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1, 
        m._pf._overflowDayOfYear && (YEAR > overflow || overflow > DATE) && (overflow = DATE), 
        m._pf.overflow = overflow);
    }
    function isValid(m) {
        return null == m._isValid && (m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated, 
        m._strict && (m._isValid = m._isValid && 0 === m._pf.charsLeftOver && 0 === m._pf.unusedTokens.length && m._pf.bigHour === undefined)), 
        m._isValid;
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        for (var j, next, locale, split, i = 0; i < names.length; ) {
            for (split = normalizeLocale(names[i]).split("-"), j = split.length, next = normalizeLocale(names[i + 1]), 
            next = next ? next.split("-") : null; j > 0; ) {
                if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break;
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) try {
            oldLocale = moment.locale(), require("./locale/" + name), moment.locale(oldLocale);
        } catch (e) {}
        return locales[name];
    }
    function makeAs(input, model) {
        var res, diff;
        return model._isUTC ? (res = model.clone(), diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res, 
        res._d.setTime(+res._d + diff), moment.updateOffset(res, !1), res) : moment(input).local();
    }
    function removeFormattingTokens(input) {
        return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var i, length, array = format.match(formattingTokens);
        for (i = 0, length = array.length; length > i; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
        return function(mom) {
            var output = "";
            for (i = 0; length > i; i++) output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            return output;
        };
    }
    function formatMoment(m, format) {
        return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] || (formatFunctions[format] = makeFormatFunction(format)), 
        formatFunctions[format](m)) : m.localeData().invalidDate();
    }
    function expandFormat(format, locale) {
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        var i = 5;
        for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format); ) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), 
        localFormattingTokens.lastIndex = 0, i -= 1;
        return format;
    }
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
          case "Q":
            return parseTokenOneDigit;

          case "DDDD":
            return parseTokenThreeDigits;

          case "YYYY":
          case "GGGG":
          case "gggg":
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;

          case "Y":
          case "G":
          case "g":
            return parseTokenSignedNumber;

          case "YYYYYY":
          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;

          case "S":
            if (strict) return parseTokenOneDigit;

          case "SS":
            if (strict) return parseTokenTwoDigits;

          case "SSS":
            if (strict) return parseTokenThreeDigits;

          case "DDD":
            return parseTokenOneToThreeDigits;

          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;

          case "a":
          case "A":
            return config._locale._meridiemParse;

          case "x":
            return parseTokenOffsetMs;

          case "X":
            return parseTokenTimestampMs;

          case "Z":
          case "ZZ":
            return parseTokenTimezone;

          case "T":
            return parseTokenT;

          case "SSSS":
            return parseTokenDigits;

          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "ww":
          case "WW":
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;

          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "W":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;

          case "Do":
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;

          default:
            return a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
        }
    }
    function utcOffsetFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(60 * parts[1]) + toInt(parts[2]);
        return "+" === parts[0] ? minutes : -minutes;
    }
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          case "Q":
            null != input && (datePartArray[MONTH] = 3 * (toInt(input) - 1));
            break;

          case "M":
          case "MM":
            null != input && (datePartArray[MONTH] = toInt(input) - 1);
            break;

          case "MMM":
          case "MMMM":
            a = config._locale.monthsParse(input, token, config._strict), null != a ? datePartArray[MONTH] = a : config._pf.invalidMonth = input;
            break;

          case "D":
          case "DD":
            null != input && (datePartArray[DATE] = toInt(input));
            break;

          case "Do":
            null != input && (datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10)));
            break;

          case "DDD":
          case "DDDD":
            null != input && (config._dayOfYear = toInt(input));
            break;

          case "YY":
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;

          case "YYYY":
          case "YYYYY":
          case "YYYYYY":
            datePartArray[YEAR] = toInt(input);
            break;

          case "a":
          case "A":
            config._meridiem = input;
            break;

          case "h":
          case "hh":
            config._pf.bigHour = !0;

          case "H":
          case "HH":
            datePartArray[HOUR] = toInt(input);
            break;

          case "m":
          case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;

          case "s":
          case "ss":
            datePartArray[SECOND] = toInt(input);
            break;

          case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(1e3 * ("0." + input));
            break;

          case "x":
            config._d = new Date(toInt(input));
            break;

          case "X":
            config._d = new Date(1e3 * parseFloat(input));
            break;

          case "Z":
          case "ZZ":
            config._useUTC = !0, config._tzm = utcOffsetFromString(input);
            break;

          case "dd":
          case "ddd":
          case "dddd":
            a = config._locale.weekdaysParse(input), null != a ? (config._w = config._w || {}, 
            config._w.d = a) : config._pf.invalidWeekday = input;
            break;

          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "e":
          case "E":
            token = token.substr(0, 1);

          case "gggg":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2), input && (config._w = config._w || {}, config._w[token] = toInt(input));
            break;

          case "gg":
          case "GG":
            config._w = config._w || {}, config._w[token] = moment.parseTwoDigitYear(input);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w, null != w.GG || null != w.W || null != w.E ? (dow = 1, doy = 4, weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year), 
        week = dfl(w.W, 1), weekday = dfl(w.E, 1)) : (dow = config._locale._week.dow, doy = config._locale._week.doy, 
        weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year), week = dfl(w.w, 1), 
        null != w.d ? (weekday = w.d, dow > weekday && ++week) : weekday = null != w.e ? w.e + dow : dow), 
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow), config._a[YEAR] = temp.year, 
        config._dayOfYear = temp.dayOfYear;
    }
    function dateFromConfig(config) {
        var i, date, currentDate, yearToUse, input = [];
        if (!config._d) {
            for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), 
            config._dayOfYear && (yearToUse = dfl(config._a[YEAR], currentDate[YEAR]), config._dayOfYear > daysInYear(yearToUse) && (config._pf._overflowDayOfYear = !0), 
            date = makeUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), 
            config._a[DATE] = date.getUTCDate()), i = 0; 3 > i && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
            for (;7 > i; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, 
            config._a[HOUR] = 0), config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input), 
            null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
            config._nextDay && (config._a[HOUR] = 24);
        }
    }
    function dateFromObject(config) {
        var normalizedInput;
        config._d || (normalizedInput = normalizeObjectUnits(config._i), config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ], 
        dateFromConfig(config));
    }
    function currentDateArray(config) {
        var now = new Date();
        return config._useUTC ? [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ] : [ now.getFullYear(), now.getMonth(), now.getDate() ];
    }
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) return void parseISO(config);
        config._a = [], config._pf.empty = !0;
        var i, parsedInput, tokens, token, skipped, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
        for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], 
        i = 0; i < tokens.length; i++) token = tokens[i], parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0], 
        parsedInput && (skipped = string.substr(0, string.indexOf(parsedInput)), skipped.length > 0 && config._pf.unusedInput.push(skipped), 
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), 
        formatTokenFunctions[token] ? (parsedInput ? config._pf.empty = !1 : config._pf.unusedTokens.push(token), 
        addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && config._pf.unusedTokens.push(token);
        config._pf.charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && config._pf.unusedInput.push(string), 
        config._pf.bigHour === !0 && config._a[HOUR] <= 12 && (config._pf.bigHour = undefined), 
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), 
        dateFromConfig(config), checkOverflow(config);
    }
    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (0 === config._f.length) return config._pf.invalidFormat = !0, void (config._d = new Date(NaN));
        for (i = 0; i < config._f.length; i++) currentScore = 0, tempConfig = copyConfig({}, config), 
        null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._pf = defaultParsingFlags(), 
        tempConfig._f = config._f[i], makeDateFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += tempConfig._pf.charsLeftOver, 
        currentScore += 10 * tempConfig._pf.unusedTokens.length, tempConfig._pf.score = currentScore, 
        (null == scoreToBeat || scoreToBeat > currentScore) && (scoreToBeat = currentScore, 
        bestMoment = tempConfig));
        extend(config, bestMoment || tempConfig);
    }
    function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
            for (config._pf.iso = !0, i = 0, l = isoDates.length; l > i; i++) if (isoDates[i][1].exec(string)) {
                config._f = isoDates[i][0] + (match[6] || " ");
                break;
            }
            for (i = 0, l = isoTimes.length; l > i; i++) if (isoTimes[i][1].exec(string)) {
                config._f += isoTimes[i][0];
                break;
            }
            string.match(parseTokenTimezone) && (config._f += "Z"), makeDateFromStringAndFormat(config);
        } else config._isValid = !1;
    }
    function makeDateFromString(config) {
        parseISO(config), config._isValid === !1 && (delete config._isValid, moment.createFromInputFallback(config));
    }
    function map(arr, fn) {
        var i, res = [];
        for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
        return res;
    }
    function makeDateFromInput(config) {
        var matched, input = config._i;
        input === undefined ? config._d = new Date() : isDate(input) ? config._d = new Date(+input) : null !== (matched = aspNetJsonRegex.exec(input)) ? config._d = new Date(+matched[1]) : "string" == typeof input ? makeDateFromString(config) : isArray(input) ? (config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
        }), dateFromConfig(config)) : "object" == typeof input ? dateFromObject(config) : "number" == typeof input ? config._d = new Date(input) : moment.createFromInputFallback(config);
    }
    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        return 1970 > y && date.setFullYear(y), date;
    }
    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        return 1970 > y && date.setUTCFullYear(y), date;
    }
    function parseWeekday(input, locale) {
        if ("string" == typeof input) if (isNaN(input)) {
            if (input = locale.weekdaysParse(input), "number" != typeof input) return null;
        } else input = parseInt(input, 10);
        return input;
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && [ "s", seconds ] || 1 === minutes && [ "m" ] || minutes < relativeTimeThresholds.m && [ "mm", minutes ] || 1 === hours && [ "h" ] || hours < relativeTimeThresholds.h && [ "hh", hours ] || 1 === days && [ "d" ] || days < relativeTimeThresholds.d && [ "dd", days ] || 1 === months && [ "M" ] || months < relativeTimeThresholds.M && [ "MM", months ] || 1 === years && [ "y" ] || [ "yy", years ];
        return args[2] = withoutSuffix, args[3] = +posNegDuration > 0, args[4] = locale, 
        substituteTimeAgo.apply({}, args);
    }
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var adjustedMoment, end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();
        return daysToDayOfWeek > end && (daysToDayOfWeek -= 7), end - 7 > daysToDayOfWeek && (daysToDayOfWeek += 7), 
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d"), {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var daysToAdd, dayOfYear, d = makeUTCDate(year, 0, 1).getUTCDay();
        return d = 0 === d ? 7 : d, weekday = null != weekday ? weekday : firstDayOfWeek, 
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (firstDayOfWeek > d ? 7 : 0), 
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1, {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }
    function makeMoment(config) {
        var res, input = config._i, format = config._f;
        return config._locale = config._locale || moment.localeData(config._l), null === input || format === undefined && "" === input ? moment.invalid({
            nullInput: !0
        }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), 
        moment.isMoment(input) ? new Moment(input, !0) : (format ? isArray(format) ? makeDateFromStringAndArray(config) : makeDateFromStringAndFormat(config) : makeDateFromInput(config), 
        res = new Moment(config), res._nextDay && (res.add(1, "d"), res._nextDay = undefined), 
        res));
    }
    function pickBy(fn, moments) {
        var res, i;
        if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return moment();
        for (res = moments[0], i = 1; i < moments.length; ++i) moments[i][fn](res) && (res = moments[i]);
        return res;
    }
    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        return "string" == typeof value && (value = mom.localeData().monthsParse(value), 
        "number" != typeof value) ? mom : (dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), 
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), mom);
    }
    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
    }
    function rawSetter(mom, unit, value) {
        return "Month" === unit ? rawMonthSetter(mom, value) : mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function makeAccessor(unit, keepTime) {
        return function(value) {
            return null != value ? (rawSetter(this, unit, value), moment.updateOffset(this, keepTime), 
            this) : rawGetter(this, unit);
        };
    }
    function daysToYears(days) {
        return 400 * days / 146097;
    }
    function yearsToDays(years) {
        return 146097 * years / 400;
    }
    function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
            return this._data[name];
        };
    }
    function makeGlobal(shouldDeprecate) {
        "undefined" == typeof ender && (oldGlobalMoment = globalScope.moment, shouldDeprecate ? globalScope.moment = deprecate("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.", moment) : globalScope.moment = moment);
    }
    for (var moment, oldGlobalMoment, i, VERSION = "2.9.0", globalScope = "undefined" == typeof global || "undefined" != typeof window && window !== global.window ? this : global, round = Math.round, hasOwnProperty = Object.prototype.hasOwnProperty, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = "undefined" != typeof module && module && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenOffsetMs = /[\+\-]?\d+/, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, unitMillisecondFactors = ("Date|Hours|Minutes|Seconds|Milliseconds".split("|"), 
    {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }), unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
            return this.month() + 1;
        },
        MMM: function(format) {
            return this.localeData().monthsShort(this, format);
        },
        MMMM: function(format) {
            return this.localeData().months(this, format);
        },
        D: function() {
            return this.date();
        },
        DDD: function() {
            return this.dayOfYear();
        },
        d: function() {
            return this.day();
        },
        dd: function(format) {
            return this.localeData().weekdaysMin(this, format);
        },
        ddd: function(format) {
            return this.localeData().weekdaysShort(this, format);
        },
        dddd: function(format) {
            return this.localeData().weekdays(this, format);
        },
        w: function() {
            return this.week();
        },
        W: function() {
            return this.isoWeek();
        },
        YY: function() {
            return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
            return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
            return leftZeroFill(this.year(), 5);
        },
        YYYYYY: function() {
            var y = this.year(), sign = y >= 0 ? "+" : "-";
            return sign + leftZeroFill(Math.abs(y), 6);
        },
        gg: function() {
            return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
            return leftZeroFill(this.weekYear(), 4);
        },
        ggggg: function() {
            return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
            return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 4);
        },
        GGGGG: function() {
            return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
            return this.weekday();
        },
        E: function() {
            return this.isoWeekday();
        },
        a: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), !0);
        },
        A: function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), !1);
        },
        H: function() {
            return this.hours();
        },
        h: function() {
            return this.hours() % 12 || 12;
        },
        m: function() {
            return this.minutes();
        },
        s: function() {
            return this.seconds();
        },
        S: function() {
            return toInt(this.milliseconds() / 100);
        },
        SS: function() {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
            return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
            var a = this.utcOffset(), b = "+";
            return 0 > a && (a = -a, b = "-"), b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
            var a = this.utcOffset(), b = "+";
            return 0 > a && (a = -a, b = "-"), b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
        },
        z: function() {
            return this.zoneAbbr();
        },
        zz: function() {
            return this.zoneName();
        },
        x: function() {
            return this.valueOf();
        },
        X: function() {
            return this.unix();
        },
        Q: function() {
            return this.quarter();
        }
    }, deprecations = {}, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ], updateInProgress = !1; ordinalizeTokens.length; ) i = ordinalizeTokens.pop(), 
    formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    for (;paddedTokens.length; ) i = paddedTokens.pop(), formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3), extend(Locale.prototype, {
        set: function(config) {
            var prop, i;
            for (i in config) prop = config[i], "function" == typeof prop ? this[i] = prop : this["_" + i] = prop;
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
            return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
            return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName, format, strict) {
            var i, mom, regex;
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), 
            i = 0; 12 > i; i++) {
                if (mom = moment.utc([ 2e3, i ]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), 
                this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), 
                strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), 
                this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
                if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
                if (!strict && this._monthsParse[i].test(monthName)) return i;
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
            return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
            return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
            return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
            var i, mom, regex;
            for (this._weekdaysParse || (this._weekdaysParse = []), i = 0; 7 > i; i++) if (this._weekdaysParse[i] || (mom = moment([ 2e3, 1 ]).day(i), 
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), 
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), this._weekdaysParse[i].test(weekdayName)) return i;
        },
        _longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
            var output = this._longDateFormat[key];
            return !output && this._longDateFormat[key.toUpperCase()] && (output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
                return val.slice(1);
            }), this._longDateFormat[key] = output), output;
        },
        isPM: function(input) {
            return "p" === (input + "").toLowerCase().charAt(0);
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
            return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function(key, mom, now) {
            var output = this._calendar[key];
            return "function" == typeof output ? output.apply(mom, [ now ]) : output;
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return "function" == typeof output ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return "function" == typeof format ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
            return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function(string) {
            return string;
        },
        postformat: function(string) {
            return string;
        },
        week: function(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
            dow: 0,
            doy: 6
        },
        firstDayOfWeek: function() {
            return this._week.dow;
        },
        firstDayOfYear: function() {
            return this._week.doy;
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
            return this._invalidDate;
        }
    }), moment = function(input, format, locale, strict) {
        var c;
        return "boolean" == typeof locale && (strict = locale, locale = undefined), c = {}, 
        c._isAMomentObject = !0, c._i = input, c._f = format, c._l = locale, c._strict = strict, 
        c._isUTC = !1, c._pf = defaultParsingFlags(), makeMoment(c);
    }, moment.suppressDeprecationWarnings = !1, moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }), moment.min = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }, moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }, moment.utc = function(input, format, locale, strict) {
        var c;
        return "boolean" == typeof locale && (strict = locale, locale = undefined), c = {}, 
        c._isAMomentObject = !0, c._useUTC = !0, c._isUTC = !0, c._l = locale, c._i = input, 
        c._f = format, c._strict = strict, c._pf = defaultParsingFlags(), makeMoment(c).utc();
    }, moment.unix = function(input) {
        return moment(1e3 * input);
    }, moment.duration = function(input, key) {
        var sign, ret, parseIso, diffRes, duration = input, match = null;
        return moment.isDuration(input) ? duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        } : "number" == typeof input ? (duration = {}, key ? duration[key] = input : duration.milliseconds = input) : (match = aspNetTimeSpanJsonRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, 
        duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(match[MILLISECOND]) * sign
        }) : (match = isoDurationRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, 
        parseIso = function(inp) {
            var res = inp && parseFloat(inp.replace(",", "."));
            return (isNaN(res) ? 0 : res) * sign;
        }, duration = {
            y: parseIso(match[2]),
            M: parseIso(match[3]),
            d: parseIso(match[4]),
            h: parseIso(match[5]),
            m: parseIso(match[6]),
            s: parseIso(match[7]),
            w: parseIso(match[8])
        }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(moment(duration.from), moment(duration.to)), 
        duration = {}, duration.ms = diffRes.milliseconds, duration.M = diffRes.months), 
        ret = new Duration(duration), moment.isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), 
        ret;
    }, moment.version = VERSION, moment.defaultFormat = isoFormat, moment.ISO_8601 = function() {}, 
    moment.momentProperties = momentProperties, moment.updateOffset = function() {}, 
    moment.relativeTimeThreshold = function(threshold, limit) {
        return relativeTimeThresholds[threshold] === undefined ? !1 : limit === undefined ? relativeTimeThresholds[threshold] : (relativeTimeThresholds[threshold] = limit, 
        !0);
    }, moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value);
    }), moment.locale = function(key, values) {
        var data;
        return key && (data = "undefined" != typeof values ? moment.defineLocale(key, values) : moment.localeData(key), 
        data && (moment.duration._locale = moment._locale = data)), moment._locale._abbr;
    }, moment.defineLocale = function(name, values) {
        return null !== values ? (values.abbr = name, locales[name] || (locales[name] = new Locale()), 
        locales[name].set(values), moment.locale(name), locales[name]) : (delete locales[name], 
        null);
    }, moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key);
    }), moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return moment._locale;
        if (!isArray(key)) {
            if (locale = loadLocale(key)) return locale;
            key = [ key ];
        }
        return chooseLocale(key);
    }, moment.isMoment = function(obj) {
        return obj instanceof Moment || null != obj && hasOwnProp(obj, "_isAMomentObject");
    }, moment.isDuration = function(obj) {
        return obj instanceof Duration;
    };
    for (i = lists.length - 1; i >= 0; --i) makeList(lists[i]);
    moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
    }, moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        return null != flags ? extend(m._pf, flags) : m._pf.userInvalidated = !0, m;
    }, moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone();
    }, moment.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    }, moment.isDate = isDate, extend(moment.fn = Moment.prototype, {
        clone: function() {
            return moment(this);
        },
        valueOf: function() {
            return +this._d - 6e4 * (this._offset || 0);
        },
        unix: function() {
            return Math.floor(+this / 1e3);
        },
        toString: function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
            return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
            var m = moment(this).utc();
            return 0 < m.year() && m.year() <= 9999 ? "function" == typeof Date.prototype.toISOString ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
        },
        toArray: function() {
            var m = this;
            return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
            return isValid(this);
        },
        isDSTShifted: function() {
            return this._a ? this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0 : !1;
        },
        parsingFlags: function() {
            return extend({}, this._pf);
        },
        invalidAt: function() {
            return this._pf.overflow;
        },
        utc: function(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        },
        local: function(keepLocalTime) {
            return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(this._dateUtcOffset(), "m")), 
            this;
        },
        format: function(inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
            var diff, output, that = makeAs(input, this), zoneDiff = 6e4 * (that.utcOffset() - this.utcOffset());
            return units = normalizeUnits(units), "year" === units || "month" === units || "quarter" === units ? (output = monthDiff(this, that), 
            "quarter" === units ? output /= 3 : "year" === units && (output /= 12)) : (diff = this - that, 
            output = "second" === units ? diff / 1e3 : "minute" === units ? diff / 6e4 : "hour" === units ? diff / 36e5 : "day" === units ? (diff - zoneDiff) / 864e5 : "week" === units ? (diff - zoneDiff) / 6048e5 : diff), 
            asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
            return moment.duration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },
        calendar: function(time) {
            var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", !0), format = -6 > diff ? "sameElse" : -1 > diff ? "lastWeek" : 0 > diff ? "lastDay" : 1 > diff ? "sameDay" : 2 > diff ? "nextDay" : 7 > diff ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },
        isLeapYear: function() {
            return isLeapYear(this.year());
        },
        isDST: function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
        },
        day: function(input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day;
        },
        month: makeAccessor("Month", !0),
        startOf: function(units) {
            switch (units = normalizeUnits(units)) {
              case "year":
                this.month(0);

              case "quarter":
              case "month":
                this.date(1);

              case "week":
              case "isoWeek":
              case "day":
                this.hours(0);

              case "hour":
                this.minutes(0);

              case "minute":
                this.seconds(0);

              case "second":
                this.milliseconds(0);
            }
            return "week" === units ? this.weekday(0) : "isoWeek" === units && this.isoWeekday(1), 
            "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this;
        },
        endOf: function(units) {
            return units = normalizeUnits(units), units === undefined || "millisecond" === units ? this : this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms");
        },
        isAfter: function(input, units) {
            var inputMs;
            return units = normalizeUnits("undefined" != typeof units ? units : "millisecond"), 
            "millisecond" === units ? (input = moment.isMoment(input) ? input : moment(input), 
            +this > +input) : (inputMs = moment.isMoment(input) ? +input : +moment(input), inputMs < +this.clone().startOf(units));
        },
        isBefore: function(input, units) {
            var inputMs;
            return units = normalizeUnits("undefined" != typeof units ? units : "millisecond"), 
            "millisecond" === units ? (input = moment.isMoment(input) ? input : moment(input), 
            +input > +this) : (inputMs = moment.isMoment(input) ? +input : +moment(input), +this.clone().endOf(units) < inputMs);
        },
        isBetween: function(from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units);
        },
        isSame: function(input, units) {
            var inputMs;
            return units = normalizeUnits(units || "millisecond"), "millisecond" === units ? (input = moment.isMoment(input) ? input : moment(input), 
            +this === +input) : (inputMs = +moment(input), +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units));
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function(other) {
            return other = moment.apply(null, arguments), this > other ? this : other;
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
            return other = moment.apply(null, arguments), other > this ? this : other;
        }),
        zone: deprecate("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", function(input, keepLocalTime) {
            return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), 
            this) : -this.utcOffset();
        }),
        utcOffset: function(input, keepLocalTime) {
            var localAdjust, offset = this._offset || 0;
            return null != input ? ("string" == typeof input && (input = utcOffsetFromString(input)), 
            Math.abs(input) < 16 && (input = 60 * input), !this._isUTC && keepLocalTime && (localAdjust = this._dateUtcOffset()), 
            this._offset = input, this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), 
            offset !== input && (!keepLocalTime || this._changeInProgress ? addOrSubtractDurationFromMoment(this, moment.duration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, 
            moment.updateOffset(this, !0), this._changeInProgress = null)), this) : this._isUTC ? offset : this._dateUtcOffset();
        },
        isLocal: function() {
            return !this._isUTC;
        },
        isUtcOffset: function() {
            return this._isUTC;
        },
        isUtc: function() {
            return this._isUTC && 0 === this._offset;
        },
        zoneAbbr: function() {
            return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
            return this._tzm ? this.utcOffset(this._tzm) : "string" == typeof this._i && this.utcOffset(utcOffsetFromString(this._i)), 
            this;
        },
        hasAlignedHourOffset: function(input) {
            return input = input ? moment(input).utcOffset() : 0, (this.utcOffset() - input) % 60 === 0;
        },
        daysInMonth: function() {
            return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
        },
        quarter: function(input) {
            return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
        },
        weekYear: function(input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return null == input ? year : this.add(input - year, "y");
        },
        isoWeekYear: function(input) {
            var year = weekOfYear(this, 1, 4).year;
            return null == input ? year : this.add(input - year, "y");
        },
        week: function(input) {
            var week = this.localeData().week(this);
            return null == input ? week : this.add(7 * (input - week), "d");
        },
        isoWeek: function(input) {
            var week = weekOfYear(this, 1, 4).week;
            return null == input ? week : this.add(7 * (input - week), "d");
        },
        weekday: function(input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return null == input ? weekday : this.add(input - weekday, "d");
        },
        isoWeekday: function(input) {
            return null == input ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        isoWeeksInYear: function() {
            return weeksInYear(this.year(), 1, 4);
        },
        weeksInYear: function() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },
        get: function(units) {
            return units = normalizeUnits(units), this[units]();
        },
        set: function(units, value) {
            var unit;
            if ("object" == typeof units) for (unit in units) this.set(unit, units[unit]); else units = normalizeUnits(units), 
            "function" == typeof this[units] && this[units](value);
            return this;
        },
        locale: function(key) {
            var newLocaleData;
            return key === undefined ? this._locale._abbr : (newLocaleData = moment.localeData(key), 
            null != newLocaleData && (this._locale = newLocaleData), this);
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
            return key === undefined ? this.localeData() : this.locale(key);
        }),
        localeData: function() {
            return this._locale;
        },
        _dateUtcOffset: function() {
            return 15 * -Math.round(this._d.getTimezoneOffset() / 15);
        }
    }), moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", !1), 
    moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", !1), moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", !1), 
    moment.fn.hour = moment.fn.hours = makeAccessor("Hours", !0), moment.fn.date = makeAccessor("Date", !0), 
    moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", !0)), 
    moment.fn.year = makeAccessor("FullYear", !0), moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", !0)), 
    moment.fn.days = moment.fn.day, moment.fn.months = moment.fn.month, moment.fn.weeks = moment.fn.week, 
    moment.fn.isoWeeks = moment.fn.isoWeek, moment.fn.quarters = moment.fn.quarter, 
    moment.fn.toJSON = moment.fn.toISOString, moment.fn.isUTC = moment.fn.isUtc, extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
            var seconds, minutes, hours, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, years = 0;
            data.milliseconds = milliseconds % 1e3, seconds = absRound(milliseconds / 1e3), 
            data.seconds = seconds % 60, minutes = absRound(seconds / 60), data.minutes = minutes % 60, 
            hours = absRound(minutes / 60), data.hours = hours % 24, days += absRound(hours / 24), 
            years = absRound(daysToYears(days)), days -= absRound(yearsToDays(years)), months += absRound(days / 30), 
            days %= 30, years += absRound(months / 12), months %= 12, data.days = days, data.months = months, 
            data.years = years;
        },
        abs: function() {
            return this._milliseconds = Math.abs(this._milliseconds), this._days = Math.abs(this._days), 
            this._months = Math.abs(this._months), this._data.milliseconds = Math.abs(this._data.milliseconds), 
            this._data.seconds = Math.abs(this._data.seconds), this._data.minutes = Math.abs(this._data.minutes), 
            this._data.hours = Math.abs(this._data.hours), this._data.months = Math.abs(this._data.months), 
            this._data.years = Math.abs(this._data.years), this;
        },
        weeks: function() {
            return absRound(this.days() / 7);
        },
        valueOf: function() {
            return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12);
        },
        humanize: function(withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());
            return withSuffix && (output = this.localeData().pastFuture(+this, output)), this.localeData().postformat(output);
        },
        add: function(input, val) {
            var dur = moment.duration(input, val);
            return this._milliseconds += dur._milliseconds, this._days += dur._days, this._months += dur._months, 
            this._bubble(), this;
        },
        subtract: function(input, val) {
            var dur = moment.duration(input, val);
            return this._milliseconds -= dur._milliseconds, this._days -= dur._days, this._months -= dur._months, 
            this._bubble(), this;
        },
        get: function(units) {
            return units = normalizeUnits(units), this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
            var days, months;
            if (units = normalizeUnits(units), "month" === units || "year" === units) return days = this._days + this._milliseconds / 864e5, 
            months = this._months + 12 * daysToYears(days), "month" === units ? months : months / 12;
            switch (days = this._days + Math.round(yearsToDays(this._months / 12)), units) {
              case "week":
                return days / 7 + this._milliseconds / 6048e5;

              case "day":
                return days + this._milliseconds / 864e5;

              case "hour":
                return 24 * days + this._milliseconds / 36e5;

              case "minute":
                return 24 * days * 60 + this._milliseconds / 6e4;

              case "second":
                return 24 * days * 60 * 60 + this._milliseconds / 1e3;

              case "millisecond":
                return Math.floor(24 * days * 60 * 60 * 1e3) + this._milliseconds;

              default:
                throw new Error("Unknown unit " + units);
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", function() {
            return this.toISOString();
        }),
        toISOString: function() {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            return this.asSeconds() ? (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "") : "P0D";
        },
        localeData: function() {
            return this._locale;
        },
        toJSON: function() {
            return this.toISOString();
        }
    }), moment.duration.fn.toString = moment.duration.fn.toISOString;
    for (i in unitMillisecondFactors) hasOwnProp(unitMillisecondFactors, i) && makeDurationGetter(i.toLowerCase());
    moment.duration.fn.asMilliseconds = function() {
        return this.as("ms");
    }, moment.duration.fn.asSeconds = function() {
        return this.as("s");
    }, moment.duration.fn.asMinutes = function() {
        return this.as("m");
    }, moment.duration.fn.asHours = function() {
        return this.as("h");
    }, moment.duration.fn.asDays = function() {
        return this.as("d");
    }, moment.duration.fn.asWeeks = function() {
        return this.as("weeks");
    }, moment.duration.fn.asMonths = function() {
        return this.as("M");
    }, moment.duration.fn.asYears = function() {
        return this.as("y");
    }, moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = 1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
            return number + output;
        }
    }), hasModule ? module.exports = moment : "function" == typeof define && define.amd ? (define(function(require, exports, module) {
        return module.config && module.config() && module.config().noGlobal === !0 && (globalScope.moment = oldGlobalMoment), 
        moment;
    }), makeGlobal(!0)) : makeGlobal();
}.call(this), function(window, document, undefined) {
    function minErr(module) {
        return function() {
            var message, i, code = arguments[0], prefix = "[" + (module ? module + ":" : "") + code + "] ", template = arguments[1], templateArgs = arguments, stringify = function(obj) {
                return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof obj ? "undefined" : "string" != typeof obj ? JSON.stringify(obj) : obj;
            };
            for (message = prefix + template.replace(/\{\d+\}/g, function(match) {
                var arg, index = +match.slice(1, -1);
                return index + 2 < templateArgs.length ? (arg = templateArgs[index + 2], "function" == typeof arg ? arg.toString().replace(/ ?\{[\s\S]*$/, "") : "undefined" == typeof arg ? "undefined" : "string" != typeof arg ? toJson(arg) : arg) : match;
            }), message = message + "\nhttp://errors.angularjs.org/1.2.20/" + (module ? module + "/" : "") + code, 
            i = 2; i < arguments.length; i++) message = message + (2 == i ? "?" : "&") + "p" + (i - 2) + "=" + encodeURIComponent(stringify(arguments[i]));
            return new Error(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        var length = obj.length;
        return 1 === obj.nodeType && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key); else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context); else if (isArrayLike(obj)) for (key = 0; key < obj.length; key++) iterator.call(context, obj[key], key); else for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key);
        return obj;
    }
    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys.sort();
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        for (var digit, index = uid.length; index; ) {
            if (index--, digit = uid[index].charCodeAt(0), 57 == digit) return uid[index] = "A", 
            uid.join("");
            if (90 != digit) return uid[index] = String.fromCharCode(digit + 1), uid.join("");
            uid[index] = "0";
        }
        return uid.unshift("0"), uid.join("");
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function extend(dst) {
        var h = dst.$$hashKey;
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst[key] = value;
            });
        }), setHashKey(dst, h), dst;
    }
    function int(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null != value && "object" == typeof value;
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function map(obj, iterator, context) {
        var results = [];
        return forEach(obj, function(value, index, list) {
            results.push(iterator.call(context, value, index, list));
        }), results;
    }
    function includes(array, obj) {
        return -1 != indexOf(array, obj);
    }
    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);
        for (var i = 0; i < array.length; i++) if (obj === array[i]) return i;
        return -1;
    }
    function arrayRemove(array, value) {
        var index = indexOf(array, value);
        return index >= 0 && array.splice(index, 1), value;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (destination) {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            if (stackSource = stackSource || [], stackDest = stackDest || [], isObject(source)) {
                var index = indexOf(stackSource, source);
                if (-1 !== index) return stackDest[index];
                stackSource.push(source), stackDest.push(destination);
            }
            var result;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) result = copy(source[i], null, stackSource, stackDest), 
                isObject(source[i]) && (stackSource.push(source[i]), stackDest.push(result)), destination.push(result);
            } else {
                var h = destination.$$hashKey;
                forEach(destination, function(value, key) {
                    delete destination[key];
                });
                for (var key in source) result = copy(source[key], null, stackSource, stackDest), 
                isObject(source[key]) && (stackSource.push(source[key]), stackDest.push(result)), 
                destination[key] = result;
                setHashKey(destination, h);
            }
        } else destination = source, source && (isArray(source) ? destination = copy(source, [], stackSource, stackDest) : isDate(source) ? destination = new Date(source.getTime()) : isRegExp(source) ? destination = new RegExp(source.source) : isObject(source) && (destination = copy(source, {}, stackSource, stackDest)));
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0; i < src.length; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) !hasOwnProperty.call(src, key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) && o1.getTime() == o2.getTime();
                if (isRegExp(o1) && isRegExp(o2)) return o1.toString() == o2.toString();
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return !1;
                keySet = {};
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!keySet.hasOwnProperty(key) && "$" !== key.charAt(0) && o2[key] !== undefined && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function csp() {
        return document.securityPolicy && document.securityPolicy.isActive || document.querySelector && !(!document.querySelector("[ng-csp]") && !document.querySelector("[data-ng-csp]"));
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0))) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return "undefined" == typeof obj ? undefined : JSON.stringify(obj, toJsonReplacer, pretty ? "  " : null);
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function toBoolean(value) {
        if ("function" == typeof value) value = !0; else if (value && 0 !== value.length) {
            var v = lowercase("" + value);
            value = !("f" == v || "0" == v || "false" == v || "no" == v || "n" == v || "[]" == v);
        } else value = !1;
        return value;
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var TEXT_NODE = 3, elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var key_value, key, obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            if (keyValue && (key_value = keyValue.split("="), key = tryDecodeURIComponent(key_value[0]), 
            isDefined(key))) {
                var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : !0;
                hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val;
            }
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function angularInit(element, bootstrap) {
        function append(element) {
            element && elements.push(element);
        }
        var appElement, module, elements = [ element ], names = [ "ng:app", "ng-app", "x-ng-app", "data-ng-app" ], NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;
        forEach(names, function(name) {
            names[name] = !0, append(document.getElementById(name)), name = name.replace(":", "\\:"), 
            element.querySelectorAll && (forEach(element.querySelectorAll("." + name), append), 
            forEach(element.querySelectorAll("." + name + "\\:"), append), forEach(element.querySelectorAll("[" + name + "]"), append));
        }), forEach(elements, function(element) {
            if (!appElement) {
                var className = " " + element.className + " ", match = NG_APP_CLASS_REGEXP.exec(className);
                match ? (appElement = element, module = (match[2] || "").replace(/\s+/g, ",")) : forEach(element.attributes, function(attr) {
                    !appElement && names[attr.name] && (appElement = element, module = attr.value);
                });
            }
        }), appElement && bootstrap(appElement, module ? [ module ] : []);
    }
    function bootstrap(element, modules) {
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag);
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", "$animate", function(scope, element, compile, injector, animate) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        void (angular.resumeBootstrap = function(extraModules) {
            forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }));
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        jQuery = window.jQuery, jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
            scope: JQLitePrototype.scope,
            isolateScope: JQLitePrototype.isolateScope,
            controller: JQLitePrototype.controller,
            injector: JQLitePrototype.injector,
            inheritedData: JQLitePrototype.inheritedData
        }), jqLitePatchJQueryRemove("remove", !0, !0, !1), jqLitePatchJQueryRemove("empty", !1, !1, !1), 
        jqLitePatchJQueryRemove("html", !1, !1, !0)) : jqLite = JQLite, angular.element = jqLite;
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockElements(nodes) {
        var startNode = nodes[0], endNode = nodes[nodes.length - 1];
        if (startNode === endNode) return jqLite(startNode);
        var element = startNode, elements = [ element ];
        do {
            if (element = element.nextSibling, !element) break;
            elements.push(element);
        } while (element !== endNode);
        return jqLite(elements);
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod) {
                        return function() {
                            return invokeQueue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], runBlocks = [], config = invokeLater("$injector", "invoke"), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLater("$provide", "provider"),
                        factory: invokeLater("$provide", "factory"),
                        service: invokeLater("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        animation: invokeLater("$animateProvider", "register"),
                        filter: invokeLater("$filterProvider", "register"),
                        controller: invokeLater("$controllerProvider", "register"),
                        directive: invokeLater("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            $$minErr: minErr,
            $$csp: csp
        }), angularModule = setupModuleLoader(window);
        try {
            angularModule("ngLocale");
        } catch (e) {
            angularModule("ngLocale", []).provider("$locale", $LocaleProvider);
        }
        angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                ngValue: ngValueDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpBackend: $HttpBackendProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$asyncCallback: $$AsyncCallbackProvider
            });
        } ]);
    }
    function jqNextId() {
        return ++jqId;
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    function jqLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {
        function removePatch(param) {
            var set, setIndex, setLength, element, childIndex, childLength, children, list = filterElems && param ? [ this.filter(param) ] : [ this ], fireEvent = dispatchThis;
            if (!getterIfNoArguments || null != param) for (;list.length; ) for (set = list.shift(), 
            setIndex = 0, setLength = set.length; setLength > setIndex; setIndex++) for (element = jqLite(set[setIndex]), 
            fireEvent ? element.triggerHandler("$destroy") : fireEvent = !fireEvent, childIndex = 0, 
            childLength = (children = element.children()).length; childLength > childIndex; childIndex++) list.push(jQuery(children[childIndex]));
            return originalJqFn.apply(this, arguments);
        }
        var originalJqFn = jQuery.fn[name];
        originalJqFn = originalJqFn.$original || originalJqFn, removePatch.$original = originalJqFn, 
        jQuery.fn[name] = removePatch;
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, j, jj, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = "<div>&#160;</div>" + wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            tmp.removeChild(tmp.firstChild), i = wrap[0]; i--; ) tmp = tmp.lastChild;
            for (j = 0, jj = tmp.childNodes.length; jj > j; ++j) nodes.push(tmp.childNodes[j]);
            tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", nodes;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : jqLiteBuildFragment(html, context);
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        if (isString(element) && (element = trim(element)), !(this instanceof JQLite)) {
            if (isString(element) && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        if (isString(element)) {
            jqLiteAddNodes(this, jqLiteParseHTML(element));
            var fragment = jqLite(document.createDocumentFragment());
            fragment.append(this);
        } else jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element) {
        jqLiteRemoveData(element);
        for (var i = 0, children = element.childNodes || []; i < children.length; i++) jqLiteDealoc(children[i]);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
        handle && (isUndefined(type) ? forEach(events, function(eventHandler, type) {
            removeEventListenerFn(element, type, eventHandler), delete events[type];
        }) : forEach(type.split(" "), function(type) {
            isUndefined(fn) ? (removeEventListenerFn(element, type, events[type]), delete events[type]) : arrayRemove(events[type] || [], fn);
        }));
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete jqCache[expandoId].data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, key, value) {
        var expandoId = element.ng339, expandoStore = jqCache[expandoId || -1];
        return isDefined(value) ? (expandoStore || (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {}), void (expandoStore[key] = value)) : expandoStore && expandoStore[key];
    }
    function jqLiteData(element, key, value) {
        var data = jqLiteExpandoStore(element, "data"), isSetter = isDefined(value), keyDefined = !isSetter && isDefined(key), isSimpleGetter = keyDefined && !isObject(key);
        if (data || isSimpleGetter || jqLiteExpandoStore(element, "data", data = {}), isSetter) data[key] = value; else {
            if (!keyDefined) return data;
            if (isSimpleGetter) return data && data[key];
            extend(data, key);
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) {
            elements = elements.nodeName || !isDefined(elements.length) || isWindow(elements) ? [ elements ] : elements;
            for (var i = 0; i < elements.length; i++) root.push(elements[i]);
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element = jqLite(element), 9 == element[0].nodeType && (element = element.find("html"));
        for (var names = isArray(name) ? name : [ name ]; element.length; ) {
            for (var node = element[0], i = 0, ii = names.length; ii > i; i++) if ((value = element.data(names[i])) !== undefined) return value;
            element = jqLite(node.parentNode || 11 === node.nodeType && node.host);
        }
    }
    function jqLiteEmpty(element) {
        for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
        for (;element.firstChild; ) element.removeChild(element.firstChild);
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            if (event.preventDefault || (event.preventDefault = function() {
                event.returnValue = !1;
            }), event.stopPropagation || (event.stopPropagation = function() {
                event.cancelBubble = !0;
            }), event.target || (event.target = event.srcElement || document), isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault;
                event.preventDefault = function() {
                    event.defaultPrevented = !0, prevent.call(event);
                }, event.defaultPrevented = !1;
            }
            event.isDefaultPrevented = function() {
                return event.defaultPrevented || event.returnValue === !1;
            };
            var eventHandlersCopy = shallowCopy(events[type || event.type] || []);
            forEach(eventHandlersCopy, function(fn) {
                fn.call(element, event);
            }), 8 >= msie ? (event.preventDefault = null, event.stopPropagation = null, event.isDefaultPrevented = null) : (delete event.preventDefault, 
            delete event.stopPropagation, delete event.isDefaultPrevented);
        };
        return eventHandler.elem = element, eventHandler;
    }
    function hashKey(obj, nextUidFn) {
        var key, objType = typeof obj;
        return "function" == objType || "object" == objType && null !== obj ? "function" == typeof (key = obj.$$hashKey) ? key = obj.$$hashKey() : key === undefined && (key = obj.$$hashKey = (nextUidFn || nextUid)()) : key = obj, 
        objType + ":" + key;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    function annotate(fn) {
        var $inject, fnText, argDecl, last;
        return "function" == typeof fn ? ($inject = fn.$inject) || ($inject = [], fn.length && (fnText = fn.toString().replace(STRIP_COMMENTS, ""), 
        argDecl = fnText.match(FN_ARGS), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
            arg.replace(FN_ARG, function(all, underscore, name) {
                $inject.push(name);
            });
        })), fn.$inject = $inject) : isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), 
        $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0), $inject;
    }
    function createInjector(modulesToLoad) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function factory(name, factoryFn) {
            return provider(name, {
                $get: factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val));
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            var moduleFn, invokeQueue, i, ii, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        if (isString(module)) for (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; ii > i; i++) {
                            var invokeArgs = invokeQueue[i], provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        } else isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName);
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function invoke(fn, self, locals) {
                var length, i, key, args = [], $inject = annotate(fn);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key));
                }
                return isArray(fn) && (fn = fn[length]), fn.apply(self, args);
            }
            function instantiate(Type, locals) {
                var instance, returnedValue, Constructor = function() {};
                return Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype, 
                instance = new Constructor(), returnedValue = invoke(Type, instance, locals), isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function() {
            throw $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
        });
        return forEach(loadModules(modulesToLoad), function(fn) {
            instanceInjector.invoke(fn || noop);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return forEach(list, function(element) {
                    result || "a" !== lowercase(element.nodeName) || (result = element);
                }), result;
            }
            function scroll() {
                var elm, hash = $location.hash();
                hash ? (elm = document.getElementById(hash)) ? elm.scrollIntoView() : (elm = getFirstAnchor(document.getElementsByName(hash))) ? elm.scrollIntoView() : "top" === hash && $window.scrollTo(0, 0) : $window.scrollTo(0, 0);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function() {
                $rootScope.$evalAsync(scroll);
            }), scroll;
        } ];
    }
    function $$AsyncCallbackProvider() {
        this.$get = [ "$$rAF", "$timeout", function($$rAF, $timeout) {
            return $$rAF.supported ? function(fn) {
                return $$rAF(fn);
            } : function(fn) {
                return $timeout(fn, 0, !1);
            };
        } ];
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function startPoller(interval, setTimeout) {
            !function check() {
                forEach(pollFns, function(pollFn) {
                    pollFn();
                }), pollTimeout = setTimeout(check, interval);
            }();
        }
        function fireUrlChange() {
            newLocation = null, lastBrowserUrl != self.url() && (lastBrowserUrl = self.url(), 
            forEach(urlChangeListeners, function(listener) {
                listener(self.url());
            }));
        }
        var self = this, rawDocument = document[0], location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            forEach(pollFns, function(pollFn) {
                pollFn();
            }), 0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var pollTimeout, pollFns = [];
        self.addPollFn = function(fn) {
            return isUndefined(pollTimeout) && startPoller(100, setTimeout), pollFns.push(fn), 
            fn;
        };
        var lastBrowserUrl = location.href, baseElement = document.find("base"), newLocation = null;
        self.url = function(url, replace) {
            if (location !== window.location && (location = window.location), history !== window.history && (history = window.history), 
            url) {
                if (lastBrowserUrl == url) return;
                return lastBrowserUrl = url, $sniffer.history ? replace ? history.replaceState(null, "", url) : (history.pushState(null, "", url), 
                baseElement.attr("href", baseElement.attr("href"))) : (newLocation = url, replace ? location.replace(url) : location.href = url), 
                self;
            }
            return newLocation || location.href.replace(/%27/g, "'");
        };
        var urlChangeListeners = [], urlChangeInit = !1;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", fireUrlChange), 
            $sniffer.hashchange ? jqLite(window).on("hashchange", fireUrlChange) : self.addPollFn(fireUrlChange), 
            urlChangeInit = !0), urlChangeListeners.push(callback), callback;
        }, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        var lastCookies = {}, lastCookieString = "", cookiePath = self.baseHref();
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, index;
            if (!name) {
                if (rawDocument.cookie !== lastCookieString) for (lastCookieString = rawDocument.cookie, 
                cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
                index = cookie.indexOf("="), index > 0 && (name = unescape(cookie.substring(0, index)), 
                lastCookies[name] === undefined && (lastCookies[name] = unescape(cookie.substring(index + 1))));
                return lastCookies;
            }
            value === undefined ? rawDocument.cookie = escape(name) + "=;path=" + cookiePath + ";expires=Thu, 01 Jan 1970 00:00:00 GMT" : isString(value) && (cookieLength = (rawDocument.cookie = escape(name) + "=" + escape(value) + ";path=" + cookiePath).length + 1, 
            cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"));
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key] || (lruHash[key] = {
                                key: key
                            });
                            refresh(lruEntry);
                        }
                        if (!isUndefined(value)) return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                        value;
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        delete data[key], size--;
                    },
                    removeAll: function() {
                        data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w_\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\d\w_\-]+)(?:\:([^;]+))?;?)/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertArg(directiveFactory, "directiveFactory"), 
            hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = directive.require || directive.controller && directive.name, 
                        directive.restrict = directive.restrict || "A", directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$http", "$templateCache", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $http, $templateCache, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function(node, index) {
                    3 == node.nodeType && node.nodeValue.match(/\S+/) && ($compileNodes[index] = node = jqLite(node).wrap("<span></span>").parent()[0]);
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                return safeAddClass($compileNodes, "ng-scope"), function(scope, cloneConnectFn, transcludeControllers, parentBoundTranscludeFn) {
                    assertArg(scope, "scope");
                    var $linkNode = cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes;
                    forEach(transcludeControllers, function(instance, name) {
                        $linkNode.data("$" + name + "Controller", instance);
                    });
                    for (var i = 0, ii = $linkNode.length; ii > i; i++) {
                        var node = $linkNode[i], nodeType = node.nodeType;
                        (1 === nodeType || 9 === nodeType) && $linkNode.eq(i).data("$scope", scope);
                    }
                    return cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    $linkNode;
                };
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, $node, childScope, i, ii, n, childBoundTranscludeFn, nodeListLength = nodeList.length, stableNodeList = new Array(nodeListLength);
                    for (i = 0; nodeListLength > i; i++) stableNodeList[i] = nodeList[i];
                    for (i = 0, n = 0, ii = linkFns.length; ii > i; n++) node = stableNodeList[n], nodeLinkFn = linkFns[i++], 
                    childLinkFn = linkFns[i++], $node = jqLite(node), nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    $node.data("$scope", childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && safeAddClass(jqLite(nodeList[i]), "ng-scope"), 
                childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                linkFns.push(nodeLinkFn, childLinkFn), linkFnFound = linkFnFound || nodeLinkFn || childLinkFn, 
                previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers) {
                    var scopeCreated = !1;
                    transcludedScope || (transcludedScope = scope.$new(), transcludedScope.$$transcluded = !0, 
                    scopeCreated = !0);
                    var clone = transcludeFn(transcludedScope, cloneFn, controllers, previousBoundTranscludeFn);
                    return scopeCreated && clone.on("$destroy", function() {
                        transcludedScope.$destroy();
                    }), clone;
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case 1:
                    addDirective(directives, directiveNormalize(nodeName_(node).toLowerCase()), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        if (attr = nAttrs[j], !msie || msie >= 8 || attr.specified) {
                            name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), 
                            (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = snake_case(ngAttrName.substr(6), "-"));
                            var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                            ngAttrName === directiveNName + "Start" && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", 
                            name = name.substr(0, name.length - 6)), nName = directiveNormalize(name.toLowerCase()), 
                            attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                            getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName), 
                            addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                        }
                    }
                    if (className = node.className, isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case 3:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case 8:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), 
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
                    } catch (e) {}
                }
                return directives.sort(byPriority), directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        1 == node.nodeType && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), 
                        nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value, retrievalMethod = "data", optional = !1;
                    if (isString(require)) {
                        for (;"^" == (value = require.charAt(0)) || "?" == value; ) require = require.substr(1), 
                        "^" == value && (retrievalMethod = "inheritedData"), optional = optional || "?" == value;
                        if (value = null, elementControllers && "data" === retrievalMethod && (value = elementControllers[require]), 
                        value = value || $element[retrievalMethod]("$" + require + "Controller"), !value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", require, directiveName);
                        return value;
                    }
                    return isArray(require) && (value = [], forEach(require, function(require) {
                        value.push(getControllers(directiveName, require, $element, elementControllers));
                    })), value;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn) {
                        var transcludeControllers;
                        return arguments.length < 2 && (cloneAttachFn = scope, scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        boundTranscludeFn(scope, cloneAttachFn, transcludeControllers);
                    }
                    var attrs, $element, i, ii, linkFn, controller, isolateScope, transcludeFn, elementControllers = {};
                    if (attrs = compileNode === linkNode ? templateAttrs : shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr)), 
                    $element = attrs.$$element, newIsolateScopeDirective) {
                        var LOCAL_REGEXP = /^\s*([@=&])(\??)\s*(\w*)\s*$/, $linkNode = jqLite(linkNode);
                        isolateScope = scope.$new(!0), !templateDirective || templateDirective !== newIsolateScopeDirective && templateDirective !== newIsolateScopeDirective.$$originalDirective ? $linkNode.data("$isolateScopeNoTemplate", isolateScope) : $linkNode.data("$isolateScope", isolateScope), 
                        safeAddClass($linkNode, "ng-isolate-scope"), forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, match = definition.match(LOCAL_REGEXP) || [], attrName = match[3] || scopeName, optional = "?" == match[2], mode = match[1];
                            switch (isolateScope.$$isolateBindings[scopeName] = mode + attrName, mode) {
                              case "@":
                                attrs.$observe(attrName, function(value) {
                                    isolateScope[scopeName] = value;
                                }), attrs.$$observers[attrName].$$scope = scope, attrs[attrName] && (isolateScope[scopeName] = $interpolate(attrs[attrName])(scope));
                                break;

                              case "=":
                                if (optional && !attrs[attrName]) return;
                                parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function(a, b) {
                                    return a === b;
                                }, parentSet = parentGet.assign || function() {
                                    throw lastValue = isolateScope[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], newIsolateScopeDirective.name);
                                }, lastValue = isolateScope[scopeName] = parentGet(scope), isolateScope.$watch(function() {
                                    var parentValue = parentGet(scope);
                                    return compare(parentValue, isolateScope[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = isolateScope[scopeName]) : isolateScope[scopeName] = parentValue), 
                                    lastValue = parentValue;
                                }, null, parentGet.literal);
                                break;

                              case "&":
                                parentGet = $parse(attrs[attrName]), isolateScope[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                                break;

                              default:
                                throw $compileMinErr("iscp", "Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}", newIsolateScopeDirective.name, scopeName, definition);
                            }
                        });
                    }
                    for (transcludeFn = boundTranscludeFn && controllersBoundTransclude, controllerDirectives && forEach(controllerDirectives, function(directive) {
                        var controllerInstance, locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        };
                        controller = directive.controller, "@" == controller && (controller = attrs[directive.name]), 
                        controllerInstance = $controller(controller, locals), elementControllers[directive.name] = controllerInstance, 
                        hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance), 
                        directive.controllerAs && (locals.$scope[directive.controllerAs] = controllerInstance);
                    }), i = 0, ii = preLinkFns.length; ii > i; i++) try {
                        linkFn = preLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($element));
                    }
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) try {
                        linkFn = postLinkFns[i], linkFn(linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($element));
                    }
                }
                previousCompileContext = previousCompileContext || {};
                for (var newScopeDirective, directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, 
                    terminalPriority > directive.priority) break;
                    if ((directiveValue = directive.scope) && (newScopeDirective = newScopeDirective || directive, 
                    directive.templateUrl || (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode), 
                    isObject(directiveValue) && (newIsolateScopeDirective = directive))), directiveName = directive.name, 
                    !directive.templateUrl && directive.controller && (directiveValue = directive.controller, 
                    controllerDirectives = controllerDirectives || {}, assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = groupScan(compileNode, attrStart, attrEnd), 
                    $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode), 
                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), 
                    childTranscludeFn = compile($template, transcludeFn))), directive.template) if (hasTemplate = !0, 
                    assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, 
                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : jqLite(trim(directiveValue)), 
                        compileNode = $template[0], 1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: !0
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                    directive = directives[i], (maxPriority === undefined || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), tDirectives.push(directive), match = directive);
                } catch (e) {
                    $exceptionHandler(e);
                }
                return match;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), 
                    dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, 
                    dstAttr[key] = srcAttr[key]);
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = extend({}, origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl;
                return $compileNode.empty(), $http.get($sce.getTrustedResourceUrl(templateUrl), {
                    cache: $templateCache
                }).success(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : jqLite(trim(content)), compileNode = $template[0], 
                        1 != $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node == compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                            var oldClasses = beforeTemplateLinkNode.className;
                            previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                            replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                        }
                        childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                        afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                    }
                    linkQueue = null;
                }).error(function(response, code, headers, config) {
                    throw $compileMinErr("tpload", "Failed to load template: {0}", config.url);
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    linkQueue ? (linkQueue.push(scope), linkQueue.push(node), linkQueue.push(rootElement), 
                    linkQueue.push(childBoundTranscludeFn)) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}, {1}] asking for {2} on: {3}", previousDirective.name, directive.name, what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var parent = templateNode.parent(), hasCompileParent = parent.length;
                        return hasCompileParent && safeAddClass(templateNode.parent(), "ng-binding"), function(scope, node) {
                            var parent = node.parent(), bindings = parent.data("$binding") || [];
                            bindings.push(interpolateFn), parent.data("$binding", bindings), hasCompileParent || safeAddClass(parent, "ng-binding"), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                return "xlinkHref" == attrNormalizedName || "FORM" == tag && "action" == attrNormalizedName || "IMG" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0;
            }
            function addAttrInterpolateDirective(node, directives, value, name) {
                var interpolateFn = $interpolate(value, !0);
                if (interpolateFn) {
                    if ("multiple" === name && "SELECT" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = {});
                                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                    interpolateFn = $interpolate(attr[name], !0, getTrustedContext(node, name)), interpolateFn && (attr[name] = interpolateFn(scope), 
                                    ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] == firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1;
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove), newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];
                for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            var Attributes = function(element, attr) {
                this.$$element = element, this.$attr = attr || {};
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses), toRemove = tokenDifference(oldClasses, newClasses);
                    0 === toAdd.length ? $animate.removeClass(this.$$element, toRemove) : 0 === toRemove.length ? $animate.addClass(this.$$element, toAdd) : $animate.setClass(this.$$element, toAdd, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, booleanKey = getBooleanAttrName(this.$$element[0], key);
                    booleanKey && (this.$$element.prop(key, value), attrName = booleanKey), this[key] = value, 
                    attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), 
                    nodeName = nodeName_(this.$$element), ("A" === nodeName && "href" === key || "IMG" === nodeName && "src" === key) && (this[key] = value = $$sanitizeUri(value, "src" === key)), 
                    writeAttr !== !1 && (null === value || value === undefined ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[key], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = {}), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        listeners.$$inter || fn(attrs[key]);
                    }), fn;
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile;
        } ];
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function $ControllerProvider() {
        var controllers = {}, CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            return function(expression, locals) {
                var instance, match, constructor, identifier;
                if (isString(expression) && (match = expression.match(CNTRL_REG), constructor = match[1], 
                identifier = match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || getter($window, constructor, !0), 
                assertArgFn(expression, constructor, !0)), instance = $injector.instantiate(expression, locals), 
                identifier) {
                    if (!locals || "object" != typeof locals.$scope) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", constructor || expression.name, identifier);
                    locals.$scope[identifier] = instance;
                }
                return instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function parseHeaders(headers) {
        var key, val, i, parsed = {};
        return headers ? (forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), key = lowercase(trim(line.substr(0, i))), val = trim(line.substr(i + 1)), 
            key && (parsed[key] ? parsed[key] += ", " + val : parsed[key] = val);
        }), parsed) : parsed;
    }
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;
        return function(name) {
            return headersObj || (headersObj = parseHeaders(headers)), name ? headersObj[lowercase(name)] || null : headersObj;
        };
    }
    function transformData(data, headers, fns) {
        return isFunction(fns) ? fns(data, headers) : (forEach(fns, function(fn) {
            data = fn(data, headers);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/, JSON_END = /[\}\]]\s*$/, PROTECTION_PREFIX = /^\)\]\}',?\n/, CONTENT_TYPE_APPLICATION_JSON = {
            "Content-Type": "application/json;charset=utf-8"
        }, defaults = this.defaults = {
            transformResponse: [ function(data) {
                return isString(data) && (data = data.replace(PROTECTION_PREFIX, ""), JSON_START.test(data) && JSON_END.test(data) && (data = fromJson(data))), 
                data;
            } ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN"
        }, interceptorFactories = this.interceptors = [], responseInterceptorFactories = this.responseInterceptors = [];
        this.$get = [ "$httpBackend", "$browser", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {
            function $http(requestConfig) {
                function transformResponse(response) {
                    var resp = extend({}, response, {
                        data: transformData(response.data, response.headers, config.transformResponse)
                    });
                    return isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function mergeHeaders(config) {
                    function execHeaders(headers) {
                        var headerContent;
                        forEach(headers, function(headerFn, header) {
                            isFunction(headerFn) && (headerContent = headerFn(), null != headerContent ? headers[header] = headerContent : delete headers[header]);
                        });
                    }
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return execHeaders(reqHeaders), reqHeaders;
                }
                var config = {
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse
                }, headers = mergeHeaders(requestConfig);
                extend(config, requestConfig), config.headers = headers, config.method = uppercase(config.method);
                var serverRequest = function(config) {
                    headers = config.headers;
                    var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData, headers).then(transformResponse, transformResponse);
                }, chain = [ serverRequest, undefined ], promise = $q.when(config);
                for (forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError);
                }); chain.length; ) {
                    var thenFn = chain.shift(), rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                return promise.success = function(fn) {
                    return promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise.error = function(fn) {
                    return promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise;
            }
            function createShortMethods(names) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData(name) {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend(config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData, reqHeaders) {
                function done(status, response, headersString, statusText) {
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    resolvePromise(response, status, headersString, statusText), $rootScope.$$phase || $rootScope.$apply();
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = Math.max(status, 0), (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function removePendingReq() {
                    var idx = indexOf($http.pendingRequests, config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, url = buildUrl(config.url, config.params);
                if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                (config.cache || defaults.cache) && config.cache !== !1 && "GET" == config.method && (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache) if (cachedResp = cache.get(url), isDefined(cachedResp)) {
                    if (cachedResp.then) return cachedResp.then(removePendingReq, removePendingReq), 
                    cachedResp;
                    isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK");
                } else cache.put(url, promise);
                if (isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
            }
            function buildUrl(url, params) {
                if (!params) return url;
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) || (value = [ value ]), 
                    forEach(value, function(v) {
                        isObject(v) && (v = toJson(v)), parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v));
                    }));
                }), parts.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + parts.join("&")), 
                url;
            }
            var defaultCache = $cacheFactory("$http"), reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), forEach(responseInterceptorFactories, function(interceptorFactory, index) {
                var responseFn = isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory);
                reversedInterceptors.splice(index, 0, {
                    response: function(response) {
                        return responseFn($q.when(response));
                    },
                    responseError: function(response) {
                        return responseFn($q.reject(response));
                    }
                });
            }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put"), $http.defaults = defaults, $http;
        } ];
    }
    function createXhr(method) {
        if (8 >= msie && (!method.match(/^(get|post|head|put|delete|options)$/i) || !window.XMLHttpRequest)) return new window.ActiveXObject("Microsoft.XMLHTTP");
        if (window.XMLHttpRequest) return new window.XMLHttpRequest();
        throw minErr("$httpBackend")("noxhr", "This browser does not support XMLHttpRequest.");
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", function($browser, $window, $document) {
            return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), 
            8 >= msie && (script.onreadystatechange = function() {
                isString(script.readyState) && /loaded|complete/.test(script.readyState) && (script.onreadystatechange = null, 
                callback({
                    type: "load"
                }));
            }), rawDocument.body.appendChild(script), callback;
        }
        var ABORTED = -1;
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                status = ABORTED, jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                timeoutId && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), 
                status = 1223 === status ? 204 : status, statusText = statusText || "", callback(status, response, headersString, statusText), 
                $browser.$$completeOutstandingRequest(noop);
            }
            var status;
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data, callbacks[callbackId].called = !0;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr(method);
                if (xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onreadystatechange = function() {
                    if (xhr && 4 == xhr.readyState) {
                        var responseHeaders = null, response = null, statusText = "";
                        status !== ABORTED && (responseHeaders = xhr.getAllResponseHeaders(), response = "response" in xhr ? xhr.response : xhr.responseText), 
                        status === ABORTED && 10 > msie || (statusText = xhr.statusText), completeRequest(callback, status || xhr.status, response, responseHeaders, statusText);
                    }
                }, withCredentials && (xhr.withCredentials = !0), responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(post || null);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else timeout && timeout.then && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function $interpolate(text, mustHaveExpression, trustedContext) {
                for (var startIndex, endIndex, fn, exp, index = 0, parts = [], length = text.length, hasInterpolation = !1, concat = []; length > index; ) -1 != (startIndex = text.indexOf(startSymbol, index)) && -1 != (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) ? (index != startIndex && parts.push(text.substring(index, startIndex)), 
                parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex))), 
                fn.exp = exp, index = endIndex + endSymbolLength, hasInterpolation = !0) : (index != length && parts.push(text.substring(index)), 
                index = length);
                if ((length = parts.length) || (parts.push(""), length = 1), trustedContext && parts.length > 1) throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
                return !mustHaveExpression || hasInterpolation ? (concat.length = length, fn = function(context) {
                    try {
                        for (var part, i = 0, ii = length; ii > i; i++) {
                            if ("function" == typeof (part = parts[i])) if (part = part(context), part = trustedContext ? $sce.getTrusted(trustedContext, part) : $sce.valueOf(part), 
                            null == part) part = ""; else switch (typeof part) {
                              case "string":
                                break;

                              case "number":
                                part = "" + part;
                                break;

                              default:
                                part = toJson(part);
                            }
                            concat[i] = part;
                        }
                        return concat.join("");
                    } catch (err) {
                        var newErr = $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
                        $exceptionHandler(newErr);
                    }
                }, fn.exp = text, fn.parts = parts, fn) : void 0;
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length;
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", function($rootScope, $window, $q) {
            function interval(fn, delay, count, invokeApply) {
                var setInterval = $window.setInterval, clearInterval = $window.clearInterval, deferred = $q.defer(), promise = deferred.promise, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply;
                return count = isDefined(count) ? count : 0, promise.then(null, null, fn), promise.$$intervalId = setInterval(function() {
                    deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), 
                    clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), 
                $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], 
                !0) : !1;
            }, interval;
        } ];
    }
    function $LocaleProvider() {
        this.$get = function() {
            return {
                id: "en-us",
                NUMBER_FORMATS: {
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [ {
                        minInt: 1,
                        minFrac: 0,
                        maxFrac: 3,
                        posPre: "",
                        posSuf: "",
                        negPre: "-",
                        negSuf: "",
                        gSize: 3,
                        lgSize: 3
                    }, {
                        minInt: 1,
                        minFrac: 2,
                        maxFrac: 2,
                        posPre: "",
                        posSuf: "",
                        negPre: "(",
                        negSuf: ")",
                        gSize: 3,
                        lgSize: 3
                    } ],
                    CURRENCY_SYM: "$"
                },
                DATETIME_FORMATS: {
                    MONTH: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
                    SHORTMONTH: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
                    DAY: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
                    SHORTDAY: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(","),
                    AMPMS: [ "AM", "PM" ],
                    medium: "MMM d, y h:mm:ss a",
                    "short": "M/d/yy h:mm a",
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    mediumDate: "MMM d, y",
                    shortDate: "M/d/yy",
                    mediumTime: "h:mm:ss a",
                    shortTime: "h:mm a"
                },
                pluralCat: function(num) {
                    return 1 === num ? "one" : "other";
                }
            };
        };
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj, appBase) {
        var parsedUrl = urlResolve(absoluteUrl, appBase);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = int(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj, appBase) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl, appBase);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index);
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "";
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this, appBase), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        }, this.$$rewrite = function(url) {
            var appUrl, prevAppUrl;
            return (appUrl = beginsWith(appBase, url)) !== undefined ? (prevAppUrl = appUrl, 
            (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ? appBaseNoFile + appUrl : appBaseNoFile == url + "/" ? appBaseNoFile : void 0;
        };
    }
    function LocationHashbangUrl(appBase, hashPrefix) {
        var appBaseNoFile = stripFile(appBase);
        parseAbsoluteUrl(appBase, this, appBase), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url), withoutHashUrl = "#" == withoutBaseUrl.charAt(0) ? beginsWith(hashPrefix, withoutBaseUrl) : this.$$html5 ? withoutBaseUrl : "";
            if (!isString(withoutHashUrl)) throw $locationMinErr("ihshprfx", 'Invalid url "{0}", missing hash prefix "{1}".', url, hashPrefix);
            parseAppUrl(withoutHashUrl, this, appBase), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), 
            this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        }, this.$$rewrite = function(url) {
            return stripHash(appBase) == stripHash(url) ? url : void 0;
        };
    }
    function LocationHashbangInHtml5Url(appBase, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments);
        var appBaseNoFile = stripFile(appBase);
        this.$$rewrite = function(url) {
            var appUrl;
            return appBase == stripHash(url) ? url : (appUrl = beginsWith(appBaseNoFile, url)) ? appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" ? appBaseNoFile : void 0;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = !1;
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isDefined(mode) ? (html5Mode = mode, this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", function($rootScope, $browser, $sniffer, $rootElement) {
            function afterLocationChange(oldUrl) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            html5Mode ? (appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url) : (appBase = stripHash(initialUrl), 
            LocationMode = LocationHashbangUrl), $location = new LocationMode(appBase, "#" + hashPrefix), 
            $location.$$parse($location.$$rewrite(initialUrl)), $rootElement.on("click", function(event) {
                if (!event.ctrlKey && !event.metaKey && 2 != event.which) {
                    for (var elm = jqLite(event.target); "a" !== lowercase(elm[0].nodeName); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    var absHref = elm.prop("href");
                    if (isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                    LocationMode === LocationHashbangInHtml5Url) {
                        var href = elm.attr("href") || elm.attr("xlink:href");
                        if (href.indexOf("://") < 0) {
                            var prefix = "#" + hashPrefix;
                            if ("/" == href[0]) absHref = appBase + prefix + href; else if ("#" == href[0]) absHref = appBase + prefix + ($location.path() || "/") + href; else {
                                for (var stack = $location.path().split("/"), parts = href.split("/"), i = 0; i < parts.length; i++) "." != parts[i] && (".." == parts[i] ? stack.pop() : parts[i].length && stack.push(parts[i]));
                                absHref = appBase + prefix + stack.join("/");
                            }
                        }
                    }
                    var rewrittenUrl = $location.$$rewrite(absHref);
                    absHref && !elm.attr("target") && rewrittenUrl && !event.isDefaultPrevented() && (event.preventDefault(), 
                    rewrittenUrl != $browser.url() && ($location.$$parse(rewrittenUrl), $rootScope.$apply(), 
                    window.angular["ff-684208-preventDefault"] = !0));
                }
            }), $location.absUrl() != initialUrl && $browser.url($location.absUrl(), !0), $browser.onUrlChange(function(newUrl) {
                $location.absUrl() != newUrl && ($rootScope.$evalAsync(function() {
                    var oldUrl = $location.absUrl();
                    $location.$$parse(newUrl), $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl).defaultPrevented ? ($location.$$parse(oldUrl), 
                    $browser.url(oldUrl)) : afterLocationChange(oldUrl);
                }), $rootScope.$$phase || $rootScope.$digest());
            });
            var changeCounter = 0;
            return $rootScope.$watch(function() {
                var oldUrl = $browser.url(), currentReplace = $location.$$replace;
                return changeCounter && oldUrl == $location.absUrl() || (changeCounter++, $rootScope.$evalAsync(function() {
                    $rootScope.$broadcast("$locationChangeStart", $location.absUrl(), oldUrl).defaultPrevented ? $location.$$parse(oldUrl) : ($browser.url($location.absUrl(), currentReplace), 
                    afterLocationChange(oldUrl));
                })), $location.$$replace = !1, changeCounter;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name) throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.document && obj.location && obj.alert && obj.setInterval) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object) throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
        return obj;
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || BIND && obj === BIND) throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
    }
    function setter(obj, path, setValue, fullExp, options) {
        options = options || {};
        for (var key, element = path.split("."), i = 0; element.length > 1; i++) {
            key = ensureSafeMemberName(element.shift(), fullExp);
            var propertyObj = obj[key];
            propertyObj || (propertyObj = {}, obj[key] = propertyObj), obj = propertyObj, obj.then && options.unwrapPromises && (promiseWarning(fullExp), 
            "$$v" in obj || !function(promise) {
                promise.then(function(val) {
                    promise.$$v = val;
                });
            }(obj), obj.$$v === undefined && (obj.$$v = {}), obj = obj.$$v);
        }
        return key = ensureSafeMemberName(element.shift(), fullExp), ensureSafeObject(obj, fullExp), 
        ensureSafeObject(obj[key], fullExp), obj[key] = setValue, setValue;
    }
    function cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp, options) {
        return ensureSafeMemberName(key0, fullExp), ensureSafeMemberName(key1, fullExp), 
        ensureSafeMemberName(key2, fullExp), ensureSafeMemberName(key3, fullExp), ensureSafeMemberName(key4, fullExp), 
        options.unwrapPromises ? function(scope, locals) {
            var promise, pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = pathVal[key0], pathVal && pathVal.then && (promiseWarning(fullExp), 
            "$$v" in pathVal || (promise = pathVal, promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key1 ? null == pathVal ? undefined : (pathVal = pathVal[key1], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key2 ? null == pathVal ? undefined : (pathVal = pathVal[key2], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key3 ? null == pathVal ? undefined : (pathVal = pathVal[key3], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), key4 ? null == pathVal ? undefined : (pathVal = pathVal[key4], 
            pathVal && pathVal.then && (promiseWarning(fullExp), "$$v" in pathVal || (promise = pathVal, 
            promise.$$v = undefined, promise.then(function(val) {
                promise.$$v = val;
            })), pathVal = pathVal.$$v), pathVal) : pathVal) : pathVal) : pathVal) : pathVal);
        } : function(scope, locals) {
            var pathVal = locals && locals.hasOwnProperty(key0) ? locals : scope;
            return null == pathVal ? pathVal : (pathVal = pathVal[key0], key1 ? null == pathVal ? undefined : (pathVal = pathVal[key1], 
            key2 ? null == pathVal ? undefined : (pathVal = pathVal[key2], key3 ? null == pathVal ? undefined : (pathVal = pathVal[key3], 
            key4 ? null == pathVal ? undefined : pathVal = pathVal[key4] : pathVal) : pathVal) : pathVal) : pathVal);
        };
    }
    function getterFn(path, options, fullExp) {
        if (getterFnCache.hasOwnProperty(path)) return getterFnCache[path];
        var fn, pathKeys = path.split("."), pathKeysLength = pathKeys.length;
        if (options.csp) fn = 6 > pathKeysLength ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp, options) : function(scope, locals) {
            var val, i = 0;
            do val = cspSafeGetterFn(pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp, options)(scope, locals), 
            locals = undefined, scope = val; while (pathKeysLength > i);
            return val;
        }; else {
            var code = "var p;\n";
            forEach(pathKeys, function(key, index) {
                ensureSafeMemberName(key, fullExp), code += "if(s == null) return undefined;\ns=" + (index ? "s" : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"];\n' + (options.unwrapPromises ? 'if (s && s.then) {\n pw("' + fullExp.replace(/(["\r\n])/g, "\\$1") + '");\n if (!("$$v" in s)) {\n p=s;\n p.$$v = undefined;\n p.then(function(v) {p.$$v=v;});\n}\n s=s.$$v\n}\n' : "");
            }), code += "return s;";
            var evaledFnGetter = new Function("s", "k", "pw", code);
            evaledFnGetter.toString = valueFn(code), fn = options.unwrapPromises ? function(scope, locals) {
                return evaledFnGetter(scope, locals, promiseWarning);
            } : evaledFnGetter;
        }
        return "hasOwnProperty" !== path && (getterFnCache[path] = fn), fn;
    }
    function $ParseProvider() {
        var cache = {}, $parseOptions = {
            csp: !1,
            unwrapPromises: !1,
            logPromiseWarnings: !0
        };
        this.unwrapPromises = function(value) {
            return isDefined(value) ? ($parseOptions.unwrapPromises = !!value, this) : $parseOptions.unwrapPromises;
        }, this.logPromiseWarnings = function(value) {
            return isDefined(value) ? ($parseOptions.logPromiseWarnings = value, this) : $parseOptions.logPromiseWarnings;
        }, this.$get = [ "$filter", "$sniffer", "$log", function($filter, $sniffer, $log) {
            return $parseOptions.csp = $sniffer.csp, promiseWarning = function(fullExp) {
                $parseOptions.logPromiseWarnings && !promiseWarningCache.hasOwnProperty(fullExp) && (promiseWarningCache[fullExp] = !0, 
                $log.warn("[$parse] Promise found in the expression `" + fullExp + "`. Automatic unwrapping of promises in Angular expressions is deprecated."));
            }, function(exp) {
                var parsedExpression;
                switch (typeof exp) {
                  case "string":
                    if (cache.hasOwnProperty(exp)) return cache[exp];
                    var lexer = new Lexer($parseOptions), parser = new Parser(lexer, $filter, $parseOptions);
                    return parsedExpression = parser.parse(exp), "hasOwnProperty" !== exp && (cache[exp] = parsedExpression), 
                    parsedExpression;

                  case "function":
                    return exp;

                  default:
                    return noop;
                }
            };
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        function defaultCallback(value) {
            return value;
        }
        function defaultErrback(reason) {
            return reject(reason);
        }
        function all(promises) {
            var deferred = defer(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, ref(promise).then(function(value) {
                    results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results));
                }, function(reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason);
                });
            }), 0 === counter && deferred.resolve(results), deferred.promise;
        }
        var defer = function() {
            var value, deferred, pending = [];
            return deferred = {
                resolve: function(val) {
                    if (pending) {
                        var callbacks = pending;
                        pending = undefined, value = ref(val), callbacks.length && nextTick(function() {
                            for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], 
                            value.then(callback[0], callback[1], callback[2]);
                        });
                    }
                },
                reject: function(reason) {
                    deferred.resolve(createInternalRejectedPromise(reason));
                },
                notify: function(progress) {
                    if (pending) {
                        var callbacks = pending;
                        pending.length && nextTick(function() {
                            for (var callback, i = 0, ii = callbacks.length; ii > i; i++) callback = callbacks[i], 
                            callback[2](progress);
                        });
                    }
                },
                promise: {
                    then: function(callback, errback, progressback) {
                        var result = defer(), wrappedCallback = function(value) {
                            try {
                                result.resolve((isFunction(callback) ? callback : defaultCallback)(value));
                            } catch (e) {
                                result.reject(e), exceptionHandler(e);
                            }
                        }, wrappedErrback = function(reason) {
                            try {
                                result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
                            } catch (e) {
                                result.reject(e), exceptionHandler(e);
                            }
                        }, wrappedProgressback = function(progress) {
                            try {
                                result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        };
                        return pending ? pending.push([ wrappedCallback, wrappedErrback, wrappedProgressback ]) : value.then(wrappedCallback, wrappedErrback, wrappedProgressback), 
                        result.promise;
                    },
                    "catch": function(callback) {
                        return this.then(null, callback);
                    },
                    "finally": function(callback) {
                        function makePromise(value, resolved) {
                            var result = defer();
                            return resolved ? result.resolve(value) : result.reject(value), result.promise;
                        }
                        function handleCallback(value, isResolved) {
                            var callbackOutput = null;
                            try {
                                callbackOutput = (callback || defaultCallback)();
                            } catch (e) {
                                return makePromise(e, !1);
                            }
                            return callbackOutput && isFunction(callbackOutput.then) ? callbackOutput.then(function() {
                                return makePromise(value, isResolved);
                            }, function(error) {
                                return makePromise(error, !1);
                            }) : makePromise(value, isResolved);
                        }
                        return this.then(function(value) {
                            return handleCallback(value, !0);
                        }, function(error) {
                            return handleCallback(error, !1);
                        });
                    }
                }
            };
        }, ref = function(value) {
            return value && isFunction(value.then) ? value : {
                then: function(callback) {
                    var result = defer();
                    return nextTick(function() {
                        result.resolve(callback(value));
                    }), result.promise;
                }
            };
        }, reject = function(reason) {
            var result = defer();
            return result.reject(reason), result.promise;
        }, createInternalRejectedPromise = function(reason) {
            return {
                then: function(callback, errback) {
                    var result = defer();
                    return nextTick(function() {
                        try {
                            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));
                        } catch (e) {
                            result.reject(e), exceptionHandler(e);
                        }
                    }), result.promise;
                }
            };
        }, when = function(value, callback, errback, progressback) {
            var done, result = defer(), wrappedCallback = function(value) {
                try {
                    return (isFunction(callback) ? callback : defaultCallback)(value);
                } catch (e) {
                    return exceptionHandler(e), reject(e);
                }
            }, wrappedErrback = function(reason) {
                try {
                    return (isFunction(errback) ? errback : defaultErrback)(reason);
                } catch (e) {
                    return exceptionHandler(e), reject(e);
                }
            }, wrappedProgressback = function(progress) {
                try {
                    return (isFunction(progressback) ? progressback : defaultCallback)(progress);
                } catch (e) {
                    exceptionHandler(e);
                }
            };
            return nextTick(function() {
                ref(value).then(function(value) {
                    done || (done = !0, result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback)));
                }, function(reason) {
                    done || (done = !0, result.resolve(wrappedErrback(reason)));
                }, function(progress) {
                    done || result.notify(wrappedProgressback(progress));
                });
            }), result.promise;
        };
        return {
            defer: defer,
            reject: reject,
            when: when,
            all: all
        };
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.mozCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this["this"] = this.$root = this, this.$$destroyed = !1, this.$$asyncQueue = [], 
                this.$$postDigestQueue = [], this.$$listeners = {}, this.$$listenerCount = {}, this.$$isolateBindings = {};
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function compileToFn(exp, name) {
                var fn = $parse(exp);
                return assertArgFn(fn, name), fn;
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate) {
                    var child;
                    return isolate ? (child = new Scope(), child.$root = this.$root, child.$$asyncQueue = this.$$asyncQueue, 
                    child.$$postDigestQueue = this.$$postDigestQueue) : (this.$$childScopeClass || (this.$$childScopeClass = function() {
                        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                        this.$$listeners = {}, this.$$listenerCount = {}, this.$id = nextUid(), this.$$childScopeClass = null;
                    }, this.$$childScopeClass.prototype = this), child = new this.$$childScopeClass()), 
                    child["this"] = child, child.$parent = this, child.$$prevSibling = this.$$childTail, 
                    this.$$childHead ? (this.$$childTail.$$nextSibling = child, this.$$childTail = child) : this.$$childHead = this.$$childTail = child, 
                    child;
                },
                $watch: function(watchExp, listener, objectEquality) {
                    var scope = this, get = compileToFn(watchExp, "watch"), array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: watchExp,
                        eq: !!objectEquality
                    };
                    if (lastDirtyWatch = null, !isFunction(listener)) {
                        var listenFn = compileToFn(listener || noop, "listener");
                        watcher.fn = function(newVal, oldVal, scope) {
                            listenFn(scope);
                        };
                    }
                    if ("string" == typeof watchExp && get.constant) {
                        var originalFn = watcher.fn;
                        watcher.fn = function(newVal, oldVal, scope) {
                            originalFn.call(this, newVal, oldVal, scope), arrayRemove(array, watcher);
                        };
                    }
                    return array || (array = scope.$$watchers = []), array.unshift(watcher), function() {
                        arrayRemove(array, watcher), lastDirtyWatch = null;
                    };
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionWatch() {
                        newValue = objGetter(self);
                        var newLength, key;
                        if (isObject(newValue)) if (isArrayLike(newValue)) {
                            oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                            changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                            oldValue.length = oldLength = newLength);
                            for (var i = 0; newLength > i; i++) {
                                var bothNaN = oldValue[i] !== oldValue[i] && newValue[i] !== newValue[i];
                                bothNaN || oldValue[i] === newValue[i] || (changeDetected++, oldValue[i] = newValue[i]);
                            }
                        } else {
                            oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                            newLength = 0;
                            for (key in newValue) newValue.hasOwnProperty(key) && (newLength++, oldValue.hasOwnProperty(key) ? oldValue[key] !== newValue[key] && (changeDetected++, 
                            oldValue[key] = newValue[key]) : (oldLength++, oldValue[key] = newValue[key], changeDetected++));
                            if (oldLength > newLength) {
                                changeDetected++;
                                for (key in oldValue) oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key) && (oldLength--, 
                                delete oldValue[key]);
                            }
                        } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                        return changeDetected;
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, objGetter = $parse(obj), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch($watchCollectionWatch, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, next, current, logIdx, logMsg, asyncTask, asyncQueue = this.$$asyncQueue, postDigestQueue = this.$$postDigestQueue, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), lastDirtyWatch = null;
                    do {
                        for (dirty = !1, current = target; asyncQueue.length; ) {
                            try {
                                asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression);
                            } catch (e) {
                                clearPhase(), $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (length = watchers.length; length--; ) try {
                                if (watch = watchers[length]) if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), logMsg = isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp, 
                                logMsg += "; newVal: " + toJson(value) + "; oldVal: " + toJson(last), watchLog[logIdx].push(logMsg));
                            } catch (e) {
                                clearPhase(), $exceptionHandler(e);
                            }
                            if (!(next = current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, toJson(watchLog));
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueue.length; ) try {
                        postDigestQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this !== $rootScope && (forEach(this.$$listenerCount, bind(null, decrementListenerCount, this)), 
                        parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = null, 
                        this.$$listeners = {}, this.$$watchers = this.$$asyncQueue = this.$$postDigestQueue = [], 
                        this.$destroy = this.$digest = this.$apply = noop, this.$on = this.$watch = function() {
                            return noop;
                        });
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr) {
                    $rootScope.$$phase || $rootScope.$$asyncQueue.length || $browser.defer(function() {
                        $rootScope.$$asyncQueue.length && $rootScope.$digest();
                    }), this.$$asyncQueue.push({
                        scope: this,
                        expression: expr
                    });
                },
                $$postDigest: function(fn) {
                    this.$$postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        return beginPhase("$apply"), this.$eval(expr);
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        clearPhase();
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        namedListeners[indexOf(namedListeners, listener)] = null, decrementListenerCount(self, 1, name);
                    };
                },
                $emit: function(name, args) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event;
                        scope = scope.$parent;
                    } while (scope);
                    return event;
                },
                $broadcast: function(name, args) {
                    for (var listeners, i, length, target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event;
                }
            };
            var $rootScope = new Scope();
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*(https?|ftp|file):|data:image\//;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return msie && !(msie >= 8) || (normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex)) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function escapeForRegexp(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || trustedValue === undefined || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || maybeTrusted === undefined || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function(html) {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sniffer", "$sceDelegate", function($parse, $sniffer, $sceDelegate) {
            if (enabled && $sniffer.msie && $sniffer.msieDocumentMode < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : function(self, locals) {
                    return sce.getTrusted(type, parsed(self, locals));
                };
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var vendorPrefix, match, eventSupport = {}, android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, documentMode = document.documentMode, vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            if (bodyStyle) {
                for (var prop in bodyStyle) if (match = vendorRegex.exec(prop)) {
                    vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                    break;
                }
                vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), 
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), 
                !android || transitions && animations || (transitions = isString(document.body.style.webkitTransition), 
                animations = isString(document.body.style.webkitAnimation));
            }
            return {
                history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                hashchange: "onhashchange" in $window && (!documentMode || documentMode > 7),
                hasEvent: function(event) {
                    if ("input" == event && 9 == msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android,
                msie: msie,
                msieDocumentMode: documentMode
            };
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$exceptionHandler", function($rootScope, $browser, $q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                var timeoutId, deferred = $q.defer(), promise = deferred.promise, skipApply = isDefined(invokeApply) && !invokeApply;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn());
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), 
                delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1;
            }, timeout;
        } ];
    }
    function urlResolve(url, base) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArray(array)) return array;
            var comparatorType = typeof comparator, predicates = [];
            predicates.check = function(value) {
                for (var j = 0; j < predicates.length; j++) if (!predicates[j](value)) return !1;
                return !0;
            }, "function" !== comparatorType && (comparator = "boolean" === comparatorType && comparator ? function(obj, text) {
                return angular.equals(obj, text);
            } : function(obj, text) {
                if (obj && text && "object" == typeof obj && "object" == typeof text) {
                    for (var objKey in obj) if ("$" !== objKey.charAt(0) && hasOwnProperty.call(obj, objKey) && comparator(obj[objKey], text[objKey])) return !0;
                    return !1;
                }
                return text = ("" + text).toLowerCase(), ("" + obj).toLowerCase().indexOf(text) > -1;
            });
            var search = function(obj, text) {
                if ("string" == typeof text && "!" === text.charAt(0)) return !search(obj, text.substr(1));
                switch (typeof obj) {
                  case "boolean":
                  case "number":
                  case "string":
                    return comparator(obj, text);

                  case "object":
                    switch (typeof text) {
                      case "object":
                        return comparator(obj, text);

                      default:
                        for (var objKey in obj) if ("$" !== objKey.charAt(0) && search(obj[objKey], text)) return !0;
                    }
                    return !1;

                  case "array":
                    for (var i = 0; i < obj.length; i++) if (search(obj[i], text)) return !0;
                    return !1;

                  default:
                    return !1;
                }
            };
            switch (typeof expression) {
              case "boolean":
              case "number":
              case "string":
                expression = {
                    $: expression
                };

              case "object":
                for (var key in expression) !function(path) {
                    "undefined" != typeof expression[path] && predicates.push(function(value) {
                        return search("$" == path ? value : value && value[path], expression[path]);
                    });
                }(key);
                break;

              case "function":
                predicates.push(expression);
                break;

              default:
                return array;
            }
            for (var filtered = [], j = 0; j < array.length; j++) {
                var value = array[j];
                predicates.check(value) && filtered.push(value);
            }
            return filtered;
        };
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (null == number || !isFinite(number) || isObject(number)) return "";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var numStr = number + "", formatedText = "", parts = [], hasExponent = !1;
        if (-1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? (numStr = "0", number = 0) : (formatedText = numStr, 
            hasExponent = !0);
        }
        if (hasExponent) fractionSize > 0 && number > -1 && 1 > number && (formatedText = number.toFixed(fractionSize)); else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), 
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) for (pos = whole.length - lgroup, i = 0; pos > i; i++) (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++) (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (;fraction.length < fractionSize; ) fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize));
        }
        return parts.push(isNegative ? pattern.negPre : pattern.posPre), parts.push(formatedText), 
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf), parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits; ) num = "0" + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), 
            padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date) {
        var zone = -1 * date.getTimezoneOffset(), paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = int(match[9] + match[10]), tzMin = int(match[9] + match[11])), 
                dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
                var h = int(match[4] || 0) - tzHour, m = int(match[5] || 0) - tzMin, s = int(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? int(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date)) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            return forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object) {
            return toJson(object, !0);
        };
    }
    function limitToFilter() {
        return function(input, limit) {
            if (!isArray(input) && !isString(input)) return input;
            if (limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : int(limit), isString(input)) return limit ? limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length) : "";
            var i, n, out = [];
            for (limit > input.length ? limit = input.length : limit < -input.length && (limit = -input.length), 
            limit > 0 ? (i = 0, n = limit) : (i = input.length + limit, n = input.length); n > i; i++) out.push(input[i]);
            return out;
        };
    }
    function orderByFilter($parse) {
        return function(array, sortPredicate, reverseOrder) {
            function comparator(o1, o2) {
                for (var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (0 !== comp) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return toBoolean(descending) ? function(a, b) {
                    return comp(b, a);
                } : comp;
            }
            function compare(v1, v2) {
                var t1 = typeof v1, t2 = typeof v2;
                return t1 == t2 ? ("string" == t1 && (v1 = v1.toLowerCase(), v2 = v2.toLowerCase()), 
                v1 === v2 ? 0 : v2 > v1 ? -1 : 1) : t2 > t1 ? -1 : 1;
            }
            if (!isArray(array)) return array;
            if (!sortPredicate) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate : [ sortPredicate ], sortPredicate = map(sortPredicate, function(predicate) {
                var descending = !1, get = predicate || identity;
                if (isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0), 
                predicate = predicate.substring(1)), get = $parse(predicate), get.constant)) {
                    var key = get();
                    return reverseComparator(function(a, b) {
                        return compare(a[key], b[key]);
                    }, descending);
                }
                return reverseComparator(function(a, b) {
                    return compare(get(a), get(b));
                }, descending);
            });
            for (var arrayCopy = [], i = 0; i < array.length; i++) arrayCopy.push(array[i]);
            return arrayCopy.sort(reverseComparator(comparator, reverseOrder));
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function FormController(element, attrs, $scope, $animate) {
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            $animate.removeClass(element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey), 
            $animate.addClass(element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        var form = this, parentForm = element.parent().controller("form") || nullFormCtrl, invalidCount = 0, errors = form.$error = {}, controls = [];
        form.$name = attrs.name || attrs.ngForm, form.$dirty = !1, form.$pristine = !0, 
        form.$valid = !0, form.$invalid = !1, parentForm.$addControl(form), element.addClass(PRISTINE_CLASS), 
        toggleValidCss(!0), form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control);
        }, form.$removeControl = function(control) {
            control.$name && form[control.$name] === control && delete form[control.$name], 
            forEach(errors, function(queue, validationToken) {
                form.$setValidity(validationToken, !0, control);
            }), arrayRemove(controls, control);
        }, form.$setValidity = function(validationToken, isValid, control) {
            var queue = errors[validationToken];
            if (isValid) queue && (arrayRemove(queue, control), queue.length || (invalidCount--, 
            invalidCount || (toggleValidCss(isValid), form.$valid = !0, form.$invalid = !1), 
            errors[validationToken] = !1, toggleValidCss(!0, validationToken), parentForm.$setValidity(validationToken, !0, form))); else {
                if (invalidCount || toggleValidCss(isValid), queue) {
                    if (includes(queue, control)) return;
                } else errors[validationToken] = queue = [], invalidCount++, toggleValidCss(!1, validationToken), 
                parentForm.$setValidity(validationToken, !1, form);
                queue.push(control), form.$valid = !1, form.$invalid = !0;
            }
        }, form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), 
            form.$dirty = !0, form.$pristine = !1, parentForm.$setDirty();
        }, form.$setPristine = function() {
            $animate.removeClass(element, DIRTY_CLASS), $animate.addClass(element, PRISTINE_CLASS), 
            form.$dirty = !1, form.$pristine = !0, forEach(controls, function(control) {
                control.$setPristine();
            });
        };
    }
    function validate(ctrl, validatorName, validity, value) {
        return ctrl.$setValidity(validatorName, validity), validity ? value : undefined;
    }
    function testFlags(validity, flags) {
        var i, flag;
        if (flags) for (i = 0; i < flags.length; ++i) if (flag = flags[i], validity[flag]) return !0;
        return !1;
    }
    function addNativeHtml5Validators(ctrl, validatorName, badFlags, ignoreFlags, validity) {
        if (isObject(validity)) {
            ctrl.$$hasNativeValidators = !0;
            var validator = function(value) {
                return ctrl.$error[validatorName] || testFlags(validity, ignoreFlags) || !testFlags(validity, badFlags) ? value : void ctrl.$setValidity(validatorName, !1);
            };
            ctrl.$parsers.push(validator);
        }
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var validity = element.prop(VALIDITY_STATE_PROPERTY), placeholder = element[0].placeholder, noevent = {};
        if (ctrl.$$validityState = validity, !$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function(data) {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var listener = function(ev) {
            if (!composing) {
                var value = element.val();
                if (msie && "input" === (ev || noevent).type && element[0].placeholder !== placeholder) return void (placeholder = element[0].placeholder);
                toBoolean(attr.ngTrim || "T") && (value = trim(value));
                var revalidate = validity && ctrl.$$hasNativeValidators;
                (ctrl.$viewValue !== value || "" === value && revalidate) && (scope.$$phase ? ctrl.$setViewValue(value) : scope.$apply(function() {
                    ctrl.$setViewValue(value);
                }));
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var timeout, deferListener = function() {
                timeout || (timeout = $browser.defer(function() {
                    listener(), timeout = null;
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener();
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), ctrl.$render = function() {
            element.val(ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue);
        };
        var patternValidator, match, pattern = attr.ngPattern;
        if (pattern) {
            var validateRegex = function(regexp, value) {
                return validate(ctrl, "pattern", ctrl.$isEmpty(value) || regexp.test(value), value);
            };
            match = pattern.match(/^\/(.*)\/([gim]*)$/), match ? (pattern = new RegExp(match[1], match[2]), 
            patternValidator = function(value) {
                return validateRegex(pattern, value);
            }) : patternValidator = function(value) {
                var patternObj = scope.$eval(pattern);
                if (!patternObj || !patternObj.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", pattern, patternObj, startingTag(element));
                return validateRegex(patternObj, value);
            }, ctrl.$formatters.push(patternValidator), ctrl.$parsers.push(patternValidator);
        }
        if (attr.ngMinlength) {
            var minlength = int(attr.ngMinlength), minLengthValidator = function(value) {
                return validate(ctrl, "minlength", ctrl.$isEmpty(value) || value.length >= minlength, value);
            };
            ctrl.$parsers.push(minLengthValidator), ctrl.$formatters.push(minLengthValidator);
        }
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength), maxLengthValidator = function(value) {
                return validate(ctrl, "maxlength", ctrl.$isEmpty(value) || value.length <= maxlength, value);
            };
            ctrl.$parsers.push(maxLengthValidator), ctrl.$formatters.push(maxLengthValidator);
        }
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (textInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$parsers.push(function(value) {
            var empty = ctrl.$isEmpty(value);
            return empty || NUMBER_REGEXP.test(value) ? (ctrl.$setValidity("number", !0), "" === value ? null : empty ? value : parseFloat(value)) : (ctrl.$setValidity("number", !1), 
            undefined);
        }), addNativeHtml5Validators(ctrl, "number", numberBadFlags, null, ctrl.$$validityState), 
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? "" : "" + value;
        }), attr.min) {
            var minValidator = function(value) {
                var min = parseFloat(attr.min);
                return validate(ctrl, "min", ctrl.$isEmpty(value) || value >= min, value);
            };
            ctrl.$parsers.push(minValidator), ctrl.$formatters.push(minValidator);
        }
        if (attr.max) {
            var maxValidator = function(value) {
                var max = parseFloat(attr.max);
                return validate(ctrl, "max", ctrl.$isEmpty(value) || max >= value, value);
            };
            ctrl.$parsers.push(maxValidator), ctrl.$formatters.push(maxValidator);
        }
        ctrl.$formatters.push(function(value) {
            return validate(ctrl, "number", ctrl.$isEmpty(value) || isNumber(value), value);
        });
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var urlValidator = function(value) {
            return validate(ctrl, "url", ctrl.$isEmpty(value) || URL_REGEXP.test(value), value);
        };
        ctrl.$formatters.push(urlValidator), ctrl.$parsers.push(urlValidator);
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        textInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var emailValidator = function(value) {
            return validate(ctrl, "email", ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value), value);
        };
        ctrl.$formatters.push(emailValidator), ctrl.$parsers.push(emailValidator);
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid()), element.on("click", function() {
            element[0].checked && scope.$apply(function() {
                ctrl.$setViewValue(attr.value);
            });
        }), ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue, falseValue = attr.ngFalseValue;
        isString(trueValue) || (trueValue = !0), isString(falseValue) || (falseValue = !1), 
        element.on("click", function() {
            scope.$apply(function() {
                ctrl.$setViewValue(element[0].checked);
            });
        }), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value !== trueValue;
        }, ctrl.$formatters.push(function(value) {
            return value === trueValue;
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name, [ "$animate", function($animate) {
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                if (isArray(classVal)) return classVal;
                if (isString(classVal)) return classVal.split(" ");
                if (isObject(classVal)) {
                    var classes = [];
                    return forEach(classVal, function(v, k) {
                        v && (classes = classes.concat(k.split(" ")));
                    }), classes;
                }
                return classVal;
            }
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || {}, classesToUpdate = [];
                        return forEach(classes, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), element.data("$classCounts", classCounts), classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                        toRemove = digestClassCounts(toRemove, -1), toAdd = digestClassCounts(toAdd, 1), 
                        0 === toAdd.length ? $animate.removeClass(element, toRemove) : 0 === toRemove.length ? $animate.addClass(element, toAdd) : $animate.setClass(element, toAdd, toRemove);
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === !0 || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (oldVal) {
                                if (!equals(newVal, oldVal)) {
                                    var oldClasses = arrayClasses(oldVal);
                                    updateClasses(oldClasses, newClasses);
                                }
                            } else addClasses(newClasses);
                        }
                        oldVal = shallowCopy(newVal);
                    }
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function(value) {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    }), "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
                        var mod = 1 & $index;
                        if (mod !== (1 & old$index)) {
                            var classes = arrayClasses(scope.$eval(attr[name]));
                            mod === selector ? addClasses(classes) : removeClasses(classes);
                        }
                    });
                }
            };
        } ];
    }
    var VALIDITY_STATE_PROPERTY = "validity", lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, nodeName_, slice = [].slice, push = [].push, toString = Object.prototype.toString, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = [ "0", "0", "0" ];
    msie = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]), isNaN(msie) && (msie = int((/trident\/.*; rv:(\d+)/.exec(lowercase(navigator.userAgent)) || [])[1])), 
    noop.$inject = [], identity.$inject = [];
    var isArray = function() {
        return isFunction(Array.isArray) ? Array.isArray : function(value) {
            return "[object Array]" === toString.call(value);
        };
    }(), trim = function() {
        return String.prototype.trim ? function(value) {
            return isString(value) ? value.trim() : value;
        } : function(value) {
            return isString(value) ? value.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : value;
        };
    }();
    nodeName_ = 9 > msie ? function(element) {
        return element = element.nodeName ? element : element[0], element.scopeName && "HTML" != element.scopeName ? uppercase(element.scopeName + ":" + element.nodeName) : element.nodeName;
    } : function(element) {
        return element.nodeName ? element.nodeName : element[0].nodeName;
    };
    var SNAKE_CASE_REGEXP = /[A-Z]/g, version = {
        full: "1.2.20",
        major: 1,
        minor: 2,
        dot: 20,
        codeName: "accidental-beautification"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = window.document.addEventListener ? function(element, type, fn) {
        element.addEventListener(type, fn, !1);
    } : function(element, type, fn) {
        element.attachEvent("on" + type, fn);
    }, removeEventListenerFn = window.document.removeEventListener ? function(element, type, fn) {
        element.removeEventListener(type, fn, !1);
    } : function(element, type, fn) {
        element.detachEvent("on" + type, fn);
    }, SPECIAL_CHARS_REGEXP = (JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    }, /([\:\-\_]+(.))/g), MOZ_HACK_REGEXP = /^moz([A-Z])/, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            function trigger() {
                fired || (fired = !0, fn());
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), 
            JQLite(window).on("load", trigger));
        },
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[uppercase(value)] = !0;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite(element).data("$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite(element).data("$isolateScope") || jqLite(element).data("$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            if (name = camelCase(name), !isDefined(value)) {
                var val;
                return 8 >= msie && (val = element.currentStyle && element.currentStyle[name], "" === val && (val = "auto")), 
                val = val || element.style[name], 8 >= msie && (val = "" === val ? undefined : val), 
                val;
            }
            element.style[name] = value;
        },
        attr: function(element, name, value) {
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, 
                element.removeAttribute(lowercasedName));
            } else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
                var ret = element.getAttribute(name, 2);
                return null === ret ? undefined : ret;
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType];
                return isUndefined(value) ? textProp ? element[textProp] : "" : void (element[textProp] = value);
            }
            var NODE_TYPE_TEXT_PROPERTY = [];
            return 9 > msie ? (NODE_TYPE_TEXT_PROPERTY[1] = "innerText", NODE_TYPE_TEXT_PROPERTY[3] = "nodeValue") : NODE_TYPE_TEXT_PROPERTY[1] = NODE_TYPE_TEXT_PROPERTY[3] = "textContent", 
            getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if ("SELECT" === nodeName_(element) && element.multiple) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), 0 === result.length ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            if (isUndefined(value)) return element.innerHTML;
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) jqLiteDealoc(childNodes[i]);
            element.innerHTML = value;
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && (2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = value === undefined ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        dealoc: jqLiteDealoc,
        on: function onFn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            var events = jqLiteExpandoStore(element, "events"), handle = jqLiteExpandoStore(element, "handle");
            events || jqLiteExpandoStore(element, "events", events = {}), handle || jqLiteExpandoStore(element, "handle", handle = createEventHandler(element, events)), 
            forEach(type.split(" "), function(type) {
                var eventFns = events[type];
                if (!eventFns) {
                    if ("mouseenter" == type || "mouseleave" == type) {
                        var contains = document.body.contains || document.body.compareDocumentPosition ? function(a, b) {
                            var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                            return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
                        } : function(a, b) {
                            if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                            return !1;
                        };
                        events[type] = [];
                        var eventmap = {
                            mouseleave: "mouseout",
                            mouseenter: "mouseover"
                        };
                        onFn(element, eventmap[type], function(event) {
                            var target = this, related = event.relatedTarget;
                            (!related || related !== target && !contains(target, related)) && handle(event, type);
                        });
                    } else addEventListenerFn(element, type, handle), events[type] = [];
                    eventFns = events[type];
                }
                eventFns.push(fn);
            });
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                1 === element.nodeType && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            forEach(new JQLite(node), function(child) {
                (1 === element.nodeType || 11 === element.nodeType) && element.appendChild(child);
            });
        },
        prepend: function(element, node) {
            if (1 === element.nodeType) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode)[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element);
        },
        remove: function(element) {
            jqLiteDealoc(element);
            var parent = element.parentNode;
            parent && parent.removeChild(element);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            forEach(new JQLite(newElement), function(node) {
                parent.insertBefore(node, index.nextSibling), index = node;
            });
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        next: function(element) {
            if (element.nextElementSibling) return element.nextElementSibling;
            for (var elm = element.nextSibling; null != elm && 1 !== elm.nodeType; ) elm = elm.nextSibling;
            return elm;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, eventName, eventData) {
            var eventFns = (jqLiteExpandoStore(element, "events") || {})[eventName];
            eventData = eventData || [];
            var event = [ {
                preventDefault: noop,
                stopPropagation: noop
            } ];
            forEach(eventFns, function(fn) {
                fn.apply(element, event.concat(eventData));
            });
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0; i < this.length; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    }), HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value;
        }
    };
    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector"), $animateMinErr = minErr("$animate"), $AnimateProvider = [ "$provide", function($provide) {
        this.$$selectors = {}, this.register = function(name, factory) {
            var key = name + "-animation";
            if (name && "." != name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            this.$$selectors[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            return 1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null), 
            this.$$classNameFilter;
        }, this.$get = [ "$timeout", "$$asyncCallback", function($timeout, $$asyncCallback) {
            function async(fn) {
                fn && $$asyncCallback(fn);
            }
            return {
                enter: function(element, parent, after, done) {
                    after ? after.after(element) : (parent && parent[0] || (parent = after.parent()), 
                    parent.append(element)), async(done);
                },
                leave: function(element, done) {
                    element.remove(), async(done);
                },
                move: function(element, parent, after, done) {
                    this.enter(element, parent, after, done);
                },
                addClass: function(element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "", 
                    forEach(element, function(element) {
                        jqLiteAddClass(element, className);
                    }), async(done);
                },
                removeClass: function(element, className, done) {
                    className = isString(className) ? className : isArray(className) ? className.join(" ") : "", 
                    forEach(element, function(element) {
                        jqLiteRemoveClass(element, className);
                    }), async(done);
                },
                setClass: function(element, add, remove, done) {
                    forEach(element, function(element) {
                        jqLiteAddClass(element, add), jqLiteRemoveClass(element, remove);
                    }), async(done);
                },
                enabled: noop
            };
        } ];
    } ], $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i, $interpolateMinErr = minErr("$interpolate"), PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location");
    LocationHashbangInHtml5Url.prototype = LocationHashbangUrl.prototype = LocationHtml5Url.prototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url, replace) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return match[1] && this.path(decodeURIComponent(match[1])), (match[2] || match[1]) && this.search(match[3] || ""), 
            this.hash(match[5] || "", replace), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return "/" == path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search)) this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", identity),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    var promiseWarning, $parseMinErr = minErr("$parse"), promiseWarningCache = {}, CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, OPERATORS = {
        "null": function() {
            return null;
        },
        "true": function() {
            return !0;
        },
        "false": function() {
            return !1;
        },
        undefined: noop,
        "+": function(self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), isDefined(a) ? isDefined(b) ? a + b : a : isDefined(b) ? b : undefined;
        },
        "-": function(self, locals, a, b) {
            return a = a(self, locals), b = b(self, locals), (isDefined(a) ? a : 0) - (isDefined(b) ? b : 0);
        },
        "*": function(self, locals, a, b) {
            return a(self, locals) * b(self, locals);
        },
        "/": function(self, locals, a, b) {
            return a(self, locals) / b(self, locals);
        },
        "%": function(self, locals, a, b) {
            return a(self, locals) % b(self, locals);
        },
        "^": function(self, locals, a, b) {
            return a(self, locals) ^ b(self, locals);
        },
        "=": noop,
        "===": function(self, locals, a, b) {
            return a(self, locals) === b(self, locals);
        },
        "!==": function(self, locals, a, b) {
            return a(self, locals) !== b(self, locals);
        },
        "==": function(self, locals, a, b) {
            return a(self, locals) == b(self, locals);
        },
        "!=": function(self, locals, a, b) {
            return a(self, locals) != b(self, locals);
        },
        "<": function(self, locals, a, b) {
            return a(self, locals) < b(self, locals);
        },
        ">": function(self, locals, a, b) {
            return a(self, locals) > b(self, locals);
        },
        "<=": function(self, locals, a, b) {
            return a(self, locals) <= b(self, locals);
        },
        ">=": function(self, locals, a, b) {
            return a(self, locals) >= b(self, locals);
        },
        "&&": function(self, locals, a, b) {
            return a(self, locals) && b(self, locals);
        },
        "||": function(self, locals, a, b) {
            return a(self, locals) || b(self, locals);
        },
        "&": function(self, locals, a, b) {
            return a(self, locals) & b(self, locals);
        },
        "|": function(self, locals, a, b) {
            return b(self, locals)(self, locals, a(self, locals));
        },
        "!": function(self, locals, a) {
            return !a(self, locals);
        }
    }, ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.ch = undefined, this.lastCh = ":", this.tokens = []; this.index < this.text.length; ) {
                if (this.ch = this.text.charAt(this.index), this.is("\"'")) this.readString(this.ch); else if (this.isNumber(this.ch) || this.is(".") && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(this.ch)) this.readIdent(); else if (this.is("(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: this.ch
                }), this.index++; else {
                    if (this.isWhitespace(this.ch)) {
                        this.index++;
                        continue;
                    }
                    var ch2 = this.ch + this.peek(), ch3 = ch2 + this.peek(2), fn = OPERATORS[this.ch], fn2 = OPERATORS[ch2], fn3 = OPERATORS[ch3];
                    fn3 ? (this.tokens.push({
                        index: this.index,
                        text: ch3,
                        fn: fn3
                    }), this.index += 3) : fn2 ? (this.tokens.push({
                        index: this.index,
                        text: ch2,
                        fn: fn2
                    }), this.index += 2) : fn ? (this.tokens.push({
                        index: this.index,
                        text: this.ch,
                        fn: fn
                    }), this.index += 1) : this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
                this.lastCh = this.ch;
            }
            return this.tokens;
        },
        is: function(chars) {
            return -1 !== chars.indexOf(this.ch);
        },
        was: function(chars) {
            return -1 !== chars.indexOf(this.lastCh);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "" === ch;
        },
        isIdent: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            number = 1 * number, this.tokens.push({
                index: start,
                text: number,
                literal: !0,
                constant: !0,
                fn: function() {
                    return number;
                }
            });
        },
        readIdent: function() {
            for (var lastDot, peekIndex, methodName, ch, parser = this, ident = "", start = this.index; this.index < this.text.length && (ch = this.text.charAt(this.index), 
            "." === ch || this.isIdent(ch) || this.isNumber(ch)); ) "." === ch && (lastDot = this.index), 
            ident += ch, this.index++;
            if (lastDot) for (peekIndex = this.index; peekIndex < this.text.length; ) {
                if (ch = this.text.charAt(peekIndex), "(" === ch) {
                    methodName = ident.substr(lastDot - start + 1), ident = ident.substr(0, lastDot - start), 
                    this.index = peekIndex;
                    break;
                }
                if (!this.isWhitespace(ch)) break;
                peekIndex++;
            }
            var token = {
                index: start,
                text: ident
            };
            if (OPERATORS.hasOwnProperty(ident)) token.fn = OPERATORS[ident], token.literal = !0, 
            token.constant = !0; else {
                var getter = getterFn(ident, this.options, this.text);
                token.fn = extend(function(self, locals) {
                    return getter(self, locals);
                }, {
                    assign: function(self, value) {
                        return setter(self, ident, value, parser.text, parser.options);
                    }
                });
            }
            this.tokens.push(token), methodName && (this.tokens.push({
                index: lastDot,
                text: "."
            }), this.tokens.push({
                index: lastDot + 1,
                text: methodName
            }));
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep ? rep : ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        string: string,
                        literal: !0,
                        constant: !0,
                        fn: function() {
                            return string;
                        }
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options;
    };
    Parser.ZERO = extend(function() {
        return 0;
    }, {
        constant: !0
    }), Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.statements();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value.literal = !!value.literal, value.constant = !!value.constant, value;
        },
        primary: function() {
            var primary;
            if (this.expect("(")) primary = this.filterChain(), this.consume(")"); else if (this.expect("[")) primary = this.arrayDeclaration(); else if (this.expect("{")) primary = this.object(); else {
                var token = this.expect();
                primary = token.fn, primary || this.throwError("not a primary expression", token), 
                primary.literal = !!token.literal, primary.constant = !!token.constant;
            }
            for (var next, context; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = this.functionCall(primary, context), 
            context = null) : "[" === next.text ? (context = primary, primary = this.objectIndex(primary)) : "." === next.text ? (context = primary, 
            primary = this.fieldAccess(primary)) : this.throwError("IMPOSSIBLE");
            return primary;
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            if (this.tokens.length > 0) {
                var token = this.tokens[0], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        consume: function(e1) {
            this.expect(e1) || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek());
        },
        unaryFn: function(fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, right);
            }, {
                constant: right.constant
            });
        },
        ternaryFn: function(left, middle, right) {
            return extend(function(self, locals) {
                return left(self, locals) ? middle(self, locals) : right(self, locals);
            }, {
                constant: left.constant && middle.constant && right.constant
            });
        },
        binaryFn: function(left, fn, right) {
            return extend(function(self, locals) {
                return fn(self, locals, left, right);
            }, {
                constant: left.constant && right.constant
            });
        },
        statements: function() {
            for (var statements = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && statements.push(this.filterChain()), 
            !this.expect(";")) return 1 === statements.length ? statements[0] : function(self, locals) {
                for (var value, i = 0; i < statements.length; i++) {
                    var statement = statements[i];
                    statement && (value = statement(self, locals));
                }
                return value;
            };
        },
        filterChain: function() {
            for (var token, left = this.expression(); ;) {
                if (!(token = this.expect("|"))) return left;
                left = this.binaryFn(left, token.fn, this.filter());
            }
        },
        filter: function() {
            for (var token = this.expect(), fn = this.$filter(token.text), argsFn = []; ;) {
                if (!(token = this.expect(":"))) {
                    var fnInvoke = function(self, locals, input) {
                        for (var args = [ input ], i = 0; i < argsFn.length; i++) args.push(argsFn[i](self, locals));
                        return fn.apply(self, args);
                    };
                    return function() {
                        return fnInvoke;
                    };
                }
                argsFn.push(this.expression());
            }
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var right, token, left = this.ternary();
            return (token = this.expect("=")) ? (left.assign || this.throwError("implies assignment but [" + this.text.substring(0, token.index) + "] can not be assigned to", token), 
            right = this.ternary(), function(scope, locals) {
                return left.assign(scope, right(scope, locals), locals);
            }) : left;
        },
        ternary: function() {
            var middle, token, left = this.logicalOR();
            return (token = this.expect("?")) ? (middle = this.ternary(), (token = this.expect(":")) ? this.ternaryFn(left, middle, this.ternary()) : void this.throwError("expected :", token)) : left;
        },
        logicalOR: function() {
            for (var token, left = this.logicalAND(); ;) {
                if (!(token = this.expect("||"))) return left;
                left = this.binaryFn(left, token.fn, this.logicalAND());
            }
        },
        logicalAND: function() {
            var token, left = this.equality();
            return (token = this.expect("&&")) && (left = this.binaryFn(left, token.fn, this.logicalAND())), 
            left;
        },
        equality: function() {
            var token, left = this.relational();
            return (token = this.expect("==", "!=", "===", "!==")) && (left = this.binaryFn(left, token.fn, this.equality())), 
            left;
        },
        relational: function() {
            var token, left = this.additive();
            return (token = this.expect("<", ">", "<=", ">=")) && (left = this.binaryFn(left, token.fn, this.relational())), 
            left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = this.binaryFn(left, token.fn, this.multiplicative());
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = this.binaryFn(left, token.fn, this.unary());
            return left;
        },
        unary: function() {
            var token;
            return this.expect("+") ? this.primary() : (token = this.expect("-")) ? this.binaryFn(Parser.ZERO, token.fn, this.unary()) : (token = this.expect("!")) ? this.unaryFn(token.fn, this.unary()) : this.primary();
        },
        fieldAccess: function(object) {
            var parser = this, field = this.expect().text, getter = getterFn(field, this.options, this.text);
            return extend(function(scope, locals, self) {
                return getter(self || object(scope, locals));
            }, {
                assign: function(scope, value, locals) {
                    return setter(object(scope, locals), field, value, parser.text, parser.options);
                }
            });
        },
        objectIndex: function(obj) {
            var parser = this, indexFn = this.expression();
            return this.consume("]"), extend(function(self, locals) {
                var v, p, o = obj(self, locals), i = indexFn(self, locals);
                return ensureSafeMemberName(i, parser.text), o ? (v = ensureSafeObject(o[i], parser.text), 
                v && v.then && parser.options.unwrapPromises && (p = v, "$$v" in v || (p.$$v = undefined, 
                p.then(function(val) {
                    p.$$v = val;
                })), v = v.$$v), v) : undefined;
            }, {
                assign: function(self, value, locals) {
                    var key = indexFn(self, locals), safe = ensureSafeObject(obj(self, locals), parser.text);
                    return safe[key] = value;
                }
            });
        },
        functionCall: function(fn, contextGetter) {
            var argsFn = [];
            if (")" !== this.peekToken().text) do argsFn.push(this.expression()); while (this.expect(","));
            this.consume(")");
            var parser = this;
            return function(scope, locals) {
                for (var args = [], context = contextGetter ? contextGetter(scope, locals) : scope, i = 0; i < argsFn.length; i++) args.push(argsFn[i](scope, locals));
                var fnPtr = fn(scope, locals, context) || noop;
                ensureSafeObject(context, parser.text), ensureSafeFunction(fnPtr, parser.text);
                var v = fnPtr.apply ? fnPtr.apply(context, args) : fnPtr(args[0], args[1], args[2], args[3], args[4]);
                return ensureSafeObject(v, parser.text);
            };
        },
        arrayDeclaration: function() {
            var elementFns = [], allConstant = !0;
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                var elementFn = this.expression();
                elementFns.push(elementFn), elementFn.constant || (allConstant = !1);
            } while (this.expect(","));
            return this.consume("]"), extend(function(self, locals) {
                for (var array = [], i = 0; i < elementFns.length; i++) array.push(elementFns[i](self, locals));
                return array;
            }, {
                literal: !0,
                constant: allConstant
            });
        },
        object: function() {
            var keyValues = [], allConstant = !0;
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                var token = this.expect(), key = token.string || token.text;
                this.consume(":");
                var value = this.expression();
                keyValues.push({
                    key: key,
                    value: value
                }), value.constant || (allConstant = !1);
            } while (this.expect(","));
            return this.consume("}"), extend(function(self, locals) {
                for (var object = {}, i = 0; i < keyValues.length; i++) {
                    var keyValue = keyValues[i];
                    object[keyValue.key] = keyValue.value(self, locals);
                }
                return object;
            }, {
                literal: !0,
                constant: allConstant
            });
        }
    };
    var getterFnCache = {}, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href, !0);
    $FilterProvider.$inject = [ "$provide" ], currencyFilter.$inject = [ "$locale" ], 
    numberFilter.$inject = [ "$locale" ];
    var DECIMAL_SEP = ".", DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, !0),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return 8 >= msie && (attr.href || attr.name || attr.$set("href", ""), element.append(document.createComment("IE fix"))), 
            attr.href || attr.xlinkHref || attr.name ? void 0 : function(scope, element) {
                var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                element.on("click", function(event) {
                    element.attr(href) || event.preventDefault();
                });
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function() {
                return {
                    priority: 100,
                    link: function(scope, element, attr) {
                        scope.$watch(attr[normalized], function(value) {
                            attr.$set(attrName, !!value);
                        });
                    }
                };
            };
        }
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        value && (attr.$set(name, value), msie && propName && element.prop(propName, attr[name]));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop
    };
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate" ];
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", function($timeout) {
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                controller: FormController,
                compile: function() {
                    return {
                        pre: function(scope, formElement, attr, controller) {
                            if (!attr.action) {
                                var preventDefaultListener = function(event) {
                                    event.preventDefault ? event.preventDefault() : event.returnValue = !1;
                                };
                                addEventListenerFn(formElement[0], "submit", preventDefaultListener), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", preventDefaultListener);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = formElement.parent().controller("form"), alias = attr.name || attr.ngForm;
                            alias && setter(scope, alias, controller, alias), parentFormCtrl && formElement.on("$destroy", function() {
                                parentFormCtrl.$removeControl(controller), alias && setter(scope, alias, undefined, alias), 
                                extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/, inputType = {
        text: textInputType,
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, numberBadFlags = [ "badInput" ], inputDirective = [ "$browser", "$sniffer", function($browser, $sniffer) {
        return {
            restrict: "E",
            require: "?ngModel",
            link: function(scope, element, attr, ctrl) {
                ctrl && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer, $browser);
            }
        };
    } ], VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate) {
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            $animate.removeClass($element, (isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey), 
            $animate.addClass($element, (isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$parsers = [], 
        this.$formatters = [], this.$viewChangeListeners = [], this.$pristine = !0, this.$dirty = !1, 
        this.$valid = !0, this.$invalid = !1, this.$name = $attr.name;
        var ngModelGet = $parse($attr.ngModel), ngModelSet = ngModelGet.assign;
        if (!ngModelSet) throw minErr("ngModel")("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        this.$render = noop, this.$isEmpty = function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        };
        var parentForm = $element.inheritedData("$formController") || nullFormCtrl, invalidCount = 0, $error = this.$error = {};
        $element.addClass(PRISTINE_CLASS), toggleValidCss(!0), this.$setValidity = function(validationErrorKey, isValid) {
            $error[validationErrorKey] !== !isValid && (isValid ? ($error[validationErrorKey] && invalidCount--, 
            invalidCount || (toggleValidCss(!0), this.$valid = !0, this.$invalid = !1)) : (toggleValidCss(!1), 
            this.$invalid = !0, this.$valid = !1, invalidCount++), $error[validationErrorKey] = !isValid, 
            toggleValidCss(isValid, validationErrorKey), parentForm.$setValidity(validationErrorKey, isValid, this));
        }, this.$setPristine = function() {
            this.$dirty = !1, this.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), 
            $animate.addClass($element, PRISTINE_CLASS);
        }, this.$setViewValue = function(value) {
            this.$viewValue = value, this.$pristine && (this.$dirty = !0, this.$pristine = !1, 
            $animate.removeClass($element, PRISTINE_CLASS), $animate.addClass($element, DIRTY_CLASS), 
            parentForm.$setDirty()), forEach(this.$parsers, function(fn) {
                value = fn(value);
            }), this.$modelValue !== value && (this.$modelValue = value, ngModelSet($scope, value), 
            forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            }));
        };
        var ctrl = this;
        $scope.$watch(function() {
            var value = ngModelGet($scope);
            if (ctrl.$modelValue !== value) {
                var formatters = ctrl.$formatters, idx = formatters.length;
                for (ctrl.$modelValue = value; idx--; ) value = formatters[idx](value);
                ctrl.$viewValue !== value && (ctrl.$viewValue = value, ctrl.$render());
            }
            return value;
        });
    } ], ngModelDirective = function() {
        return {
            require: [ "ngModel", "^?form" ],
            controller: NgModelController,
            link: function(scope, element, attr, ctrls) {
                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || nullFormCtrl;
                formCtrl.$addControl(modelCtrl), scope.$on("$destroy", function() {
                    formCtrl.$removeControl(modelCtrl);
                });
            }
        };
    }, ngChangeDirective = valueFn({
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), requiredDirective = function() {
        return {
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    attr.required = !0;
                    var validator = function(value) {
                        return attr.required && ctrl.$isEmpty(value) ? void ctrl.$setValidity("required", !1) : (ctrl.$setValidity("required", !0), 
                        value);
                    };
                    ctrl.$formatters.push(validator), ctrl.$parsers.unshift(validator), attr.$observe("required", function() {
                        validator(ctrl.$viewValue);
                    });
                }
            }
        };
    }, ngListDirective = function() {
        return {
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var match = /\/(.*)\//.exec(attr.ngList), separator = match && new RegExp(match[1]) || attr.ngList || ",", parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trim(value));
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(", ") : undefined;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        return {
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        attr.$set("value", value);
                    });
                };
            }
        };
    }, ngBindDirective = ngDirective({
        compile: function(templateElement) {
            return templateElement.addClass("ng-binding"), function(scope, element, attr) {
                element.data("$binding", attr.ngBind), scope.$watch(attr.ngBind, function(value) {
                    element.text(value == undefined ? "" : value);
                });
            };
        }
    }), ngBindTemplateDirective = [ "$interpolate", function($interpolate) {
        return function(scope, element, attr) {
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            element.addClass("ng-binding").data("$binding", interpolateFn), attr.$observe("ngBindTemplate", function(value) {
                element.text(value);
            });
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", function($sce, $parse) {
        return function(scope, element, attr) {
            function getStringValue() {
                return (parsed(scope) || "").toString();
            }
            element.addClass("ng-binding").data("$binding", attr.ngBindHtml);
            var parsed = $parse(attr.ngBindHtml);
            scope.$watch(getStringValue, function(value) {
                element.html($sce.getTrustedHtml(parsed(scope)) || "");
            });
        };
    } ], ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {};
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(name) {
        var directiveName = directiveNormalize("ng-" + name);
        ngEventDirectives[directiveName] = [ "$parse", function($parse) {
            return {
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function(scope, element) {
                        element.on(lowercase(name), function(event) {
                            scope.$apply(function() {
                                fn(scope, {
                                    $event: event
                                });
                            });
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    toBoolean(value) ? childScope || (childScope = $scope.$new(), $transclude(childScope, function(clone) {
                        clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    })) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockElements(block.clone), 
                    $animate.leave(previousElements, function() {
                        previousElements = null;
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$http", "$templateCache", "$anchorScroll", "$animate", "$sce", function($http, $templateCache, $anchorScroll, $animate, $sce) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement, function() {
                            previousElement = null;
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch($sce.parseAsResourceUrl(srcExp), function(src) {
                        var afterAnimation = function() {
                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($http.get(src, {
                            cache: $templateCache
                        }).success(function(response) {
                            if (thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element, afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded"), 
                                scope.$eval(onloadExp);
                            }
                        }).error(function() {
                            thisChangeId === changeCounter && cleanupLastIncludeContent();
                        }), scope.$emit("$includeContentRequested")) : (cleanupLastIncludeContent(), ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                $element.html(ctrl.template), $compile($element.contents())(scope);
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngPluralizeDirective = [ "$locale", "$interpolate", function($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
            restrict: "EA",
            link: function(scope, element, attr) {
                var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), isWhen = /^when(Minus)?(.+)$/;
                forEach(attr, function(expression, attributeName) {
                    isWhen.test(attributeName) && (whens[lowercase(attributeName.replace("when", "").replace("Minus", "-"))] = element.attr(attr.$attr[attributeName]));
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, startSymbol + numberExp + "-" + offset + endSymbol));
                }), scope.$watch(function() {
                    var value = parseFloat(scope.$eval(numberExp));
                    return isNaN(value) ? "" : (value in whens || (value = $locale.pluralCat(value - offset)), 
                    whensExpFns[value](scope, element, !0));
                }, function(newVal) {
                    element.text(newVal);
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        function getBlockStart(block) {
            return block.clone[0];
        }
        function getBlockEnd(block) {
            return block.clone[block.clone.length - 1];
        }
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat");
        return {
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var trackByExp, trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier, expression = $attr.ngRepeat, match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/), hashFnLocals = {
                    $id: hashKey
                };
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                if (lhs = match[1], rhs = match[2], trackByExp = match[3], trackByExp ? (trackByExpGetter = $parse(trackByExp), 
                trackByIdExpFn = function(key, value, index) {
                    return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                    hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                }) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                var lastBlockMap = {};
                $scope.$watchCollection(rhs, function(collection) {
                    var index, length, nextNode, arrayLength, childScope, key, value, trackById, trackByIdFn, collectionKeys, block, elementsToRemove, previousNode = $element[0], nextBlockMap = {}, nextBlockOrder = [];
                    if (isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                        trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                        for (key in collection) collection.hasOwnProperty(key) && "$" != key.charAt(0) && collectionKeys.push(key);
                        collectionKeys.sort();
                    }
                    for (arrayLength = collectionKeys.length, length = nextBlockOrder.length = collectionKeys.length, 
                    index = 0; length > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                    value = collection[key], trackById = trackByIdFn(key, value, index), assertNotHasOwnProperty(trackById, "`track by` id"), 
                    lastBlockMap.hasOwnProperty(trackById)) block = lastBlockMap[trackById], delete lastBlockMap[trackById], 
                    nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                        if (nextBlockMap.hasOwnProperty(trackById)) throw forEach(nextBlockOrder, function(block) {
                            block && block.scope && (lastBlockMap[block.id] = block);
                        }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}", expression, trackById);
                        nextBlockOrder[index] = {
                            id: trackById
                        }, nextBlockMap[trackById] = !1;
                    }
                    for (key in lastBlockMap) lastBlockMap.hasOwnProperty(key) && (block = lastBlockMap[key], 
                    elementsToRemove = getBlockElements(block.clone), $animate.leave(elementsToRemove), 
                    forEach(elementsToRemove, function(element) {
                        element[NG_REMOVED] = !0;
                    }), block.scope.$destroy());
                    for (index = 0, length = collectionKeys.length; length > index; index++) {
                        if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], 
                        block = nextBlockOrder[index], nextBlockOrder[index - 1] && (previousNode = getBlockEnd(nextBlockOrder[index - 1])), 
                        block.scope) {
                            childScope = block.scope, nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) != nextNode && $animate.move(getBlockElements(block.clone), null, jqLite(previousNode)), 
                            previousNode = getBlockEnd(block);
                        } else childScope = $scope.$new();
                        childScope[valueIdentifier] = value, keyIdentifier && (childScope[keyIdentifier] = key), 
                        childScope.$index = index, childScope.$first = 0 === index, childScope.$last = index === arrayLength - 1, 
                        childScope.$middle = !(childScope.$first || childScope.$last), childScope.$odd = !(childScope.$even = 0 === (1 & index)), 
                        block.scope || $transclude(childScope, function(clone) {
                            clone[clone.length++] = document.createComment(" end ngRepeat: " + expression + " "), 
                            $animate.enter(clone, null, jqLite(previousNode)), previousNode = clone, block.scope = childScope, 
                            block.clone = clone, nextBlockMap[block.id] = block;
                        });
                    }
                    lastBlockMap = nextBlockMap;
                });
            }
        };
    } ], ngShowDirective = [ "$animate", function($animate) {
        return function(scope, element, attr) {
            scope.$watch(attr.ngShow, function(value) {
                $animate[toBoolean(value) ? "removeClass" : "addClass"](element, "ng-hide");
            });
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return function(scope, element, attr) {
            scope.$watch(attr.ngHide, function(value) {
                $animate[toBoolean(value) ? "addClass" : "removeClass"](element, "ng-hide");
            });
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", function($animate) {
        return {
            restrict: "EA",
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousElements = [], selectedScopes = [];
                scope.$watch(watchExpr, function(value) {
                    var i, ii;
                    for (i = 0, ii = previousElements.length; ii > i; ++i) previousElements[i].remove();
                    for (previousElements.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = selectedElements[i];
                        selectedScopes[i].$destroy(), previousElements[i] = selected, $animate.leave(selected, function() {
                            previousElements.splice(i, 1);
                        });
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && (scope.$eval(attr.change), 
                    forEach(selectedTranscludes, function(selectedTransclude) {
                        var selectedScope = scope.$new();
                        selectedScopes.push(selectedScope), selectedTransclude.transclude(selectedScope, function(caseElement) {
                            var anchor = selectedTransclude.element;
                            selectedElements.push(caseElement), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    }));
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], 
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 800,
        require: "^ngSwitch",
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeDirective = ngDirective({
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    }), scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" == attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], ngOptionsMinErr = minErr("ngOptions"), ngOptionsDirective = valueFn({
        terminal: !0
    }), selectDirective = [ "$compile", "$parse", function($compile, $parse) {
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, nullModelCtrl = {
            $setViewValue: noop
        };
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: [ "$element", "$scope", "$attrs", function($element, $scope, $attrs) {
                var nullOption, unknownOption, self = this, optionsMap = {}, ngModelCtrl = nullModelCtrl;
                self.databound = $attrs.ngModel, self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
                    ngModelCtrl = ngModelCtrl_, nullOption = nullOption_, unknownOption = unknownOption_;
                }, self.addOption = function(value) {
                    assertNotHasOwnProperty(value, '"option value"'), optionsMap[value] = !0, ngModelCtrl.$viewValue == value && ($element.val(value), 
                    unknownOption.parent() && unknownOption.remove());
                }, self.removeOption = function(value) {
                    this.hasOption(value) && (delete optionsMap[value], ngModelCtrl.$viewValue == value && this.renderUnknownOption(value));
                }, self.renderUnknownOption = function(val) {
                    var unknownVal = "? " + hashKey(val) + " ?";
                    unknownOption.val(unknownVal), $element.prepend(unknownOption), $element.val(unknownVal), 
                    unknownOption.prop("selected", !0);
                }, self.hasOption = function(value) {
                    return optionsMap.hasOwnProperty(value);
                }, $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop;
                });
            } ],
            link: function(scope, element, attr, ctrls) {
                function setupAsSingle(scope, selectElement, ngModelCtrl, selectCtrl) {
                    ngModelCtrl.$render = function() {
                        var viewValue = ngModelCtrl.$viewValue;
                        selectCtrl.hasOption(viewValue) ? (unknownOption.parent() && unknownOption.remove(), 
                        selectElement.val(viewValue), "" === viewValue && emptyOption.prop("selected", !0)) : isUndefined(viewValue) && emptyOption ? selectElement.val("") : selectCtrl.renderUnknownOption(viewValue);
                    }, selectElement.on("change", function() {
                        scope.$apply(function() {
                            unknownOption.parent() && unknownOption.remove(), ngModelCtrl.$setViewValue(selectElement.val());
                        });
                    });
                }
                function setupAsMultiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.find("option"), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    }, scope.$watch(function() {
                        equals(lastView, ctrl.$viewValue) || (lastView = shallowCopy(ctrl.$viewValue), ctrl.$render());
                    }), selectElement.on("change", function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.find("option"), function(option) {
                                option.selected && array.push(option.value);
                            }), ctrl.$setViewValue(array);
                        });
                    });
                }
                function setupAsOptions(scope, selectElement, ctrl) {
                    function render() {
                        var optionGroupName, optionGroup, option, existingParent, existingOptions, existingOption, key, groupLength, length, groupIndex, index, selected, lastElement, element, label, optionGroups = {
                            "": []
                        }, optionGroupNames = [ "" ], modelValue = ctrl.$modelValue, values = valuesFn(scope) || [], keys = keyName ? sortedKeys(values) : values, locals = {}, selectedSet = !1;
                        if (multiple) if (trackFn && isArray(modelValue)) {
                            selectedSet = new HashMap([]);
                            for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) locals[valueName] = modelValue[trackIndex], 
                            selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
                        } else selectedSet = new HashMap(modelValue);
                        for (index = 0; length = keys.length, length > index; index++) {
                            if (key = index, keyName) {
                                if (key = keys[index], "$" === key.charAt(0)) continue;
                                locals[keyName] = key;
                            }
                            if (locals[valueName] = values[key], optionGroupName = groupByFn(scope, locals) || "", 
                            (optionGroup = optionGroups[optionGroupName]) || (optionGroup = optionGroups[optionGroupName] = [], 
                            optionGroupNames.push(optionGroupName)), multiple) selected = isDefined(selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals))); else {
                                if (trackFn) {
                                    var modelCast = {};
                                    modelCast[valueName] = modelValue, selected = trackFn(scope, modelCast) === trackFn(scope, locals);
                                } else selected = modelValue === valueFn(scope, locals);
                                selectedSet = selectedSet || selected;
                            }
                            label = displayFn(scope, locals), label = isDefined(label) ? label : "", optionGroup.push({
                                id: trackFn ? trackFn(scope, locals) : keyName ? keys[index] : index,
                                label: label,
                                selected: selected
                            });
                        }
                        for (multiple || (nullOption || null === modelValue ? optionGroups[""].unshift({
                            id: "",
                            label: "",
                            selected: !selectedSet
                        }) : selectedSet || optionGroups[""].unshift({
                            id: "?",
                            label: "",
                            selected: !0
                        })), groupIndex = 0, groupLength = optionGroupNames.length; groupLength > groupIndex; groupIndex++) {
                            for (optionGroupName = optionGroupNames[groupIndex], optionGroup = optionGroups[optionGroupName], 
                            optionGroupsCache.length <= groupIndex ? (existingParent = {
                                element: optGroupTemplate.clone().attr("label", optionGroupName),
                                label: optionGroup.label
                            }, existingOptions = [ existingParent ], optionGroupsCache.push(existingOptions), 
                            selectElement.append(existingParent.element)) : (existingOptions = optionGroupsCache[groupIndex], 
                            existingParent = existingOptions[0], existingParent.label != optionGroupName && existingParent.element.attr("label", existingParent.label = optionGroupName)), 
                            lastElement = null, index = 0, length = optionGroup.length; length > index; index++) option = optionGroup[index], 
                            (existingOption = existingOptions[index + 1]) ? (lastElement = existingOption.element, 
                            existingOption.label !== option.label && lastElement.text(existingOption.label = option.label), 
                            existingOption.id !== option.id && lastElement.val(existingOption.id = option.id), 
                            existingOption.selected !== option.selected && lastElement.prop("selected", existingOption.selected = option.selected)) : ("" === option.id && nullOption ? element = nullOption : (element = optionTemplate.clone()).val(option.id).prop("selected", option.selected).text(option.label), 
                            existingOptions.push(existingOption = {
                                element: element,
                                label: option.label,
                                id: option.id,
                                selected: option.selected
                            }), lastElement ? lastElement.after(element) : existingParent.element.append(element), 
                            lastElement = element);
                            for (index++; existingOptions.length > index; ) existingOptions.pop().element.remove();
                        }
                        for (;optionGroupsCache.length > groupIndex; ) optionGroupsCache.pop()[0].element.remove();
                    }
                    var match;
                    if (!(match = optionsExp.match(NG_OPTIONS_REGEXP))) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    var displayFn = $parse(match[2] || match[1]), valueName = match[4] || match[6], keyName = match[5], groupByFn = $parse(match[3] || ""), valueFn = $parse(match[2] ? match[1] : valueName), valuesFn = $parse(match[7]), track = match[8], trackFn = track ? $parse(match[8]) : null, optionGroupsCache = [ [ {
                        element: selectElement,
                        label: ""
                    } ] ];
                    nullOption && ($compile(nullOption)(scope), nullOption.removeClass("ng-scope"), 
                    nullOption.remove()), selectElement.empty(), selectElement.on("change", function() {
                        scope.$apply(function() {
                            var optionGroup, key, value, optionElement, index, groupIndex, length, groupLength, trackIndex, collection = valuesFn(scope) || [], locals = {};
                            if (multiple) {
                                for (value = [], groupIndex = 0, groupLength = optionGroupsCache.length; groupLength > groupIndex; groupIndex++) for (optionGroup = optionGroupsCache[groupIndex], 
                                index = 1, length = optionGroup.length; length > index; index++) if ((optionElement = optionGroup[index].element)[0].selected) {
                                    if (key = optionElement.val(), keyName && (locals[keyName] = key), trackFn) for (trackIndex = 0; trackIndex < collection.length && (locals[valueName] = collection[trackIndex], 
                                    trackFn(scope, locals) != key); trackIndex++) ; else locals[valueName] = collection[key];
                                    value.push(valueFn(scope, locals));
                                }
                            } else {
                                if (key = selectElement.val(), "?" == key) value = undefined; else if ("" === key) value = null; else if (trackFn) {
                                    for (trackIndex = 0; trackIndex < collection.length; trackIndex++) if (locals[valueName] = collection[trackIndex], 
                                    trackFn(scope, locals) == key) {
                                        value = valueFn(scope, locals);
                                        break;
                                    }
                                } else locals[valueName] = collection[key], keyName && (locals[keyName] = key), 
                                value = valueFn(scope, locals);
                                optionGroupsCache[0].length > 1 && optionGroupsCache[0][1].id !== key && (optionGroupsCache[0][1].selected = !1);
                            }
                            ctrl.$setViewValue(value);
                        });
                    }), ctrl.$render = render, scope.$watch(render);
                }
                if (ctrls[1]) {
                    for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, optionsExp = attr.ngOptions, nullOption = !1, optionTemplate = jqLite(document.createElement("option")), optGroupTemplate = jqLite(document.createElement("optgroup")), unknownOption = optionTemplate.clone(), i = 0, children = element.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                        emptyOption = nullOption = children.eq(i);
                        break;
                    }
                    selectCtrl.init(ngModelCtrl, nullOption, unknownOption), multiple && (ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length;
                    }), optionsExp ? setupAsOptions(scope, element, ngModelCtrl) : multiple ? setupAsMultiple(scope, element, ngModelCtrl) : setupAsSingle(scope, element, ngModelCtrl, selectCtrl);
                }
            }
        };
    } ], optionDirective = [ "$interpolate", function($interpolate) {
        var nullSelectCtrl = {
            addOption: noop,
            removeOption: noop
        };
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), !0);
                    interpolateFn || attr.$set("value", element.text());
                }
                return function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    selectCtrl && selectCtrl.databound ? element.prop("selected", !1) : selectCtrl = nullSelectCtrl, 
                    interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
                        attr.$set("value", newVal), newVal !== oldVal && selectCtrl.removeOption(oldVal), 
                        selectCtrl.addOption(newVal);
                    }) : selectCtrl.addOption(attr.value), element.on("$destroy", function() {
                        selectCtrl.removeOption(attr.value);
                    });
                };
            }
        };
    } ], styleDirective = valueFn({
        restrict: "E",
        terminal: !0
    });
    return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), 
    publishExternalAPI(angular), void jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    }));
}(window, document), !window.angular.$$csp() && window.angular.element(document).find("head").prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\:form{display:block;}.ng-animate-block-transitions{transition:0s all!important;-webkit-transition:0s all!important;}.ng-hide-add-active,.ng-hide-remove{display:block!important;}</style>'), 
function(window, angular, undefined) {
    function $RouteProvider() {
        function inherit(parent, extra) {
            return angular.extend(new (angular.extend(function() {}, {
                prototype: parent
            }))(), extra);
        }
        function pathRegExp(path, opts) {
            var insensitive = opts.caseInsensitiveMatch, ret = {
                originalPath: path,
                regexp: path
            }, keys = ret.keys = [];
            return path = path.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)([\?\*])?/g, function(_, slash, key, option) {
                var optional = "?" === option ? option : null, star = "*" === option ? option : null;
                return keys.push({
                    name: key,
                    optional: !!optional
                }), slash = slash || "", "" + (optional ? "" : slash) + "(?:" + (optional ? slash : "") + (star && "(.+?)" || "([^/]+)") + (optional || "") + ")" + (optional || "");
            }).replace(/([\/$\*])/g, "\\$1"), ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" : ""), 
            ret;
        }
        var routes = {};
        this.when = function(path, route) {
            if (routes[path] = angular.extend({
                reloadOnSearch: !0
            }, route, path && pathRegExp(path, route)), path) {
                var redirectPath = "/" == path[path.length - 1] ? path.substr(0, path.length - 1) : path + "/";
                routes[redirectPath] = angular.extend({
                    redirectTo: path
                }, pathRegExp(redirectPath, route));
            }
            return this;
        }, this.otherwise = function(params) {
            return this.when(null, params), this;
        }, this.$get = [ "$rootScope", "$location", "$routeParams", "$q", "$injector", "$http", "$templateCache", "$sce", function($rootScope, $location, $routeParams, $q, $injector, $http, $templateCache, $sce) {
            function switchRouteMatcher(on, route) {
                var keys = route.keys, params = {};
                if (!route.regexp) return null;
                var m = route.regexp.exec(on);
                if (!m) return null;
                for (var i = 1, len = m.length; len > i; ++i) {
                    var key = keys[i - 1], val = "string" == typeof m[i] ? decodeURIComponent(m[i]) : m[i];
                    key && val && (params[key.name] = val);
                }
                return params;
            }
            function updateRoute() {
                var next = parseRoute(), last = $route.current;
                next && last && next.$$route === last.$$route && angular.equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload ? (last.params = next.params, 
                angular.copy(last.params, $routeParams), $rootScope.$broadcast("$routeUpdate", last)) : (next || last) && (forceReload = !1, 
                $rootScope.$broadcast("$routeChangeStart", next, last), $route.current = next, next && next.redirectTo && (angular.isString(next.redirectTo) ? $location.path(interpolate(next.redirectTo, next.params)).search(next.params).replace() : $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search())).replace()), 
                $q.when(next).then(function() {
                    if (next) {
                        var template, templateUrl, locals = angular.extend({}, next.resolve);
                        return angular.forEach(locals, function(value, key) {
                            locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value);
                        }), angular.isDefined(template = next.template) ? angular.isFunction(template) && (template = template(next.params)) : angular.isDefined(templateUrl = next.templateUrl) && (angular.isFunction(templateUrl) && (templateUrl = templateUrl(next.params)), 
                        templateUrl = $sce.getTrustedResourceUrl(templateUrl), angular.isDefined(templateUrl) && (next.loadedTemplateUrl = templateUrl, 
                        template = $http.get(templateUrl, {
                            cache: $templateCache
                        }).then(function(response) {
                            return response.data;
                        }))), angular.isDefined(template) && (locals.$template = template), $q.all(locals);
                    }
                }).then(function(locals) {
                    next == $route.current && (next && (next.locals = locals, angular.copy(next.params, $routeParams)), 
                    $rootScope.$broadcast("$routeChangeSuccess", next, last));
                }, function(error) {
                    next == $route.current && $rootScope.$broadcast("$routeChangeError", next, last, error);
                }));
            }
            function parseRoute() {
                var params, match;
                return angular.forEach(routes, function(route, path) {
                    !match && (params = switchRouteMatcher($location.path(), route)) && (match = inherit(route, {
                        params: angular.extend({}, $location.search(), params),
                        pathParams: params
                    }), match.$$route = route);
                }), match || routes[null] && inherit(routes[null], {
                    params: {},
                    pathParams: {}
                });
            }
            function interpolate(string, params) {
                var result = [];
                return angular.forEach((string || "").split(":"), function(segment, i) {
                    if (0 === i) result.push(segment); else {
                        var segmentMatch = segment.match(/(\w+)(.*)/), key = segmentMatch[1];
                        result.push(params[key]), result.push(segmentMatch[2] || ""), delete params[key];
                    }
                }), result.join("");
            }
            var forceReload = !1, $route = {
                routes: routes,
                reload: function() {
                    forceReload = !0, $rootScope.$evalAsync(updateRoute);
                }
            };
            return $rootScope.$on("$locationChangeSuccess", updateRoute), $route;
        } ];
    }
    function $RouteParamsProvider() {
        this.$get = function() {
            return {};
        };
    }
    function ngViewFactory($route, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            link: function(scope, $element, attr, ctrl, $transclude) {
                function cleanupLastView() {
                    previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                    currentScope = null), currentElement && ($animate.leave(currentElement, function() {
                        previousElement = null;
                    }), previousElement = currentElement, currentElement = null);
                }
                function update() {
                    var locals = $route.current && $route.current.locals, template = locals && locals.$template;
                    if (angular.isDefined(template)) {
                        var newScope = scope.$new(), current = $route.current, clone = $transclude(newScope, function(clone) {
                            $animate.enter(clone, null, currentElement || $element, function() {
                                !angular.isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                            }), cleanupLastView();
                        });
                        currentElement = clone, currentScope = current.scope = newScope, currentScope.$emit("$viewContentLoaded"), 
                        currentScope.$eval(onloadExp);
                    } else cleanupLastView();
                }
                var currentScope, currentElement, previousElement, autoScrollExp = attr.autoscroll, onloadExp = attr.onload || "";
                scope.$on("$routeChangeSuccess", update), update();
            }
        };
    }
    function ngViewFillContentFactory($compile, $controller, $route) {
        return {
            restrict: "ECA",
            priority: -400,
            link: function(scope, $element) {
                var current = $route.current, locals = current.locals;
                $element.html(locals.$template);
                var link = $compile($element.contents());
                if (current.controller) {
                    locals.$scope = scope;
                    var controller = $controller(current.controller, locals);
                    current.controllerAs && (scope[current.controllerAs] = controller), $element.data("$ngControllerController", controller), 
                    $element.children().data("$ngControllerController", controller);
                }
                link(scope);
            }
        };
    }
    var ngRouteModule = angular.module("ngRoute", [ "ng" ]).provider("$route", $RouteProvider);
    ngRouteModule.provider("$routeParams", $RouteParamsProvider), ngRouteModule.directive("ngView", ngViewFactory), 
    ngRouteModule.directive("ngView", ngViewFillContentFactory), ngViewFactory.$inject = [ "$route", "$anchorScroll", "$animate" ], 
    ngViewFillContentFactory.$inject = [ "$compile", "$controller", "$route" ];
}(window, window.angular), function(window, angular, undefined) {
    angular.module("ngAnimate", [ "ng" ]).directive("ngAnimateChildren", function() {
        var NG_ANIMATE_CHILDREN = "$$ngAnimateChildren";
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            angular.isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN, !0) : scope.$watch(val, function(value) {
                element.data(NG_ANIMATE_CHILDREN, !!value);
            });
        };
    }).factory("$$animateReflow", [ "$$rAF", "$document", function($$rAF, $document) {
        var bod = $document[0].body;
        return function(fn) {
            return $$rAF(function() {
                bod.offsetWidth + 1;
                fn();
            });
        };
    } ]).config([ "$provide", "$animateProvider", function($provide, $animateProvider) {
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType == ELEMENT_NODE) return elm;
            }
        }
        function prepareElement(element) {
            return element && angular.element(element);
        }
        function stripCommentsFromElement(element) {
            return angular.element(extractElementNode(element));
        }
        function isMatchingElement(elm1, elm2) {
            return extractElementNode(elm1) == extractElementNode(elm2);
        }
        var noop = angular.noop, forEach = angular.forEach, selectors = $animateProvider.$$selectors, ELEMENT_NODE = 1, NG_ANIMATE_STATE = "$$ngAnimateState", NG_ANIMATE_CHILDREN = "$$ngAnimateChildren", NG_ANIMATE_CLASS_NAME = "ng-animate", rootAnimateState = {
            running: !0
        };
        $provide.decorator("$animate", [ "$delegate", "$injector", "$sniffer", "$rootElement", "$$asyncCallback", "$rootScope", "$document", function($delegate, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document) {
            function blockElementAnimations(element) {
                var data = element.data(NG_ANIMATE_STATE) || {};
                data.running = !0, element.data(NG_ANIMATE_STATE, data);
            }
            function lookup(name) {
                if (name) {
                    var matches = [], flagMap = {}, classes = name.substr(1).split(".");
                    ($sniffer.transitions || $sniffer.animations) && matches.push($injector.get(selectors[""]));
                    for (var i = 0; i < classes.length; i++) {
                        var klass = classes[i], selectorFactoryName = selectors[klass];
                        selectorFactoryName && !flagMap[klass] && (matches.push($injector.get(selectorFactoryName)), 
                        flagMap[klass] = !0);
                    }
                    return matches;
                }
            }
            function animationRunner(element, animationEvent, className) {
                function registerAnimation(animationFactory, event) {
                    var afterFn = animationFactory[event], beforeFn = animationFactory["before" + event.charAt(0).toUpperCase() + event.substr(1)];
                    return afterFn || beforeFn ? ("leave" == event && (beforeFn = afterFn, afterFn = null), 
                    after.push({
                        event: event,
                        fn: afterFn
                    }), before.push({
                        event: event,
                        fn: beforeFn
                    }), !0) : void 0;
                }
                function run(fns, cancellations, allCompleteFn) {
                    function afterAnimationComplete(index) {
                        if (cancellations) {
                            if ((cancellations[index] || noop)(), ++count < animations.length) return;
                            cancellations = null;
                        }
                        allCompleteFn();
                    }
                    var animations = [];
                    forEach(fns, function(animation) {
                        animation.fn && animations.push(animation);
                    });
                    var count = 0;
                    forEach(animations, function(animation, index) {
                        var progress = function() {
                            afterAnimationComplete(index);
                        };
                        switch (animation.event) {
                          case "setClass":
                            cancellations.push(animation.fn(element, classNameAdd, classNameRemove, progress));
                            break;

                          case "addClass":
                            cancellations.push(animation.fn(element, classNameAdd || className, progress));
                            break;

                          case "removeClass":
                            cancellations.push(animation.fn(element, classNameRemove || className, progress));
                            break;

                          default:
                            cancellations.push(animation.fn(element, progress));
                        }
                    }), cancellations && 0 === cancellations.length && allCompleteFn();
                }
                var node = element[0];
                if (node) {
                    var classNameAdd, classNameRemove, isSetClassOperation = "setClass" == animationEvent, isClassBased = isSetClassOperation || "addClass" == animationEvent || "removeClass" == animationEvent;
                    angular.isArray(className) && (classNameAdd = className[0], classNameRemove = className[1], 
                    className = classNameAdd + " " + classNameRemove);
                    var currentClassName = element.attr("class"), classes = currentClassName + " " + className;
                    if (isAnimatableClassName(classes)) {
                        var beforeComplete = noop, beforeCancel = [], before = [], afterComplete = noop, afterCancel = [], after = [], animationLookup = (" " + classes).replace(/\s+/g, ".");
                        return forEach(lookup(animationLookup), function(animationFactory) {
                            var created = registerAnimation(animationFactory, animationEvent);
                            !created && isSetClassOperation && (registerAnimation(animationFactory, "addClass"), 
                            registerAnimation(animationFactory, "removeClass"));
                        }), {
                            node: node,
                            event: animationEvent,
                            className: className,
                            isClassBased: isClassBased,
                            isSetClassOperation: isSetClassOperation,
                            before: function(allCompleteFn) {
                                beforeComplete = allCompleteFn, run(before, beforeCancel, function() {
                                    beforeComplete = noop, allCompleteFn();
                                });
                            },
                            after: function(allCompleteFn) {
                                afterComplete = allCompleteFn, run(after, afterCancel, function() {
                                    afterComplete = noop, allCompleteFn();
                                });
                            },
                            cancel: function() {
                                beforeCancel && (forEach(beforeCancel, function(cancelFn) {
                                    (cancelFn || noop)(!0);
                                }), beforeComplete(!0)), afterCancel && (forEach(afterCancel, function(cancelFn) {
                                    (cancelFn || noop)(!0);
                                }), afterComplete(!0));
                            }
                        };
                    }
                }
            }
            function performAnimation(animationEvent, className, element, parentElement, afterElement, domOperation, doneCallback) {
                function fireDOMCallback(animationPhase) {
                    var eventName = "$animate:" + animationPhase;
                    elementEvents && elementEvents[eventName] && elementEvents[eventName].length > 0 && $$asyncCallback(function() {
                        element.triggerHandler(eventName, {
                            event: animationEvent,
                            className: className
                        });
                    });
                }
                function fireBeforeCallbackAsync() {
                    fireDOMCallback("before");
                }
                function fireAfterCallbackAsync() {
                    fireDOMCallback("after");
                }
                function fireDoneCallbackAsync() {
                    fireDOMCallback("close"), doneCallback && $$asyncCallback(function() {
                        doneCallback();
                    });
                }
                function fireDOMOperation() {
                    fireDOMOperation.hasBeenRun || (fireDOMOperation.hasBeenRun = !0, domOperation());
                }
                function closeAnimation() {
                    if (!closeAnimation.hasBeenRun) {
                        closeAnimation.hasBeenRun = !0;
                        var data = element.data(NG_ANIMATE_STATE);
                        data && (runner && runner.isClassBased ? cleanup(element, className) : ($$asyncCallback(function() {
                            var data = element.data(NG_ANIMATE_STATE) || {};
                            localAnimationCount == data.index && cleanup(element, className, animationEvent);
                        }), element.data(NG_ANIMATE_STATE, data))), fireDoneCallbackAsync();
                    }
                }
                var runner = animationRunner(element, animationEvent, className);
                if (!runner) return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), 
                void closeAnimation();
                className = runner.className;
                var elementEvents = angular.element._data(runner.node);
                elementEvents = elementEvents && elementEvents.events, parentElement || (parentElement = afterElement ? afterElement.parent() : element.parent());
                var skipAnimations, ngAnimateState = element.data(NG_ANIMATE_STATE) || {}, runningAnimations = ngAnimateState.active || {}, totalActiveAnimations = ngAnimateState.totalActive || 0, lastAnimation = ngAnimateState.last;
                if (runner.isClassBased && (skipAnimations = ngAnimateState.running || ngAnimateState.disabled || lastAnimation && !lastAnimation.isClassBased), 
                skipAnimations || animationsDisabled(element, parentElement)) return fireDOMOperation(), 
                fireBeforeCallbackAsync(), fireAfterCallbackAsync(), void closeAnimation();
                var skipAnimation = !1;
                if (totalActiveAnimations > 0) {
                    var animationsToCancel = [];
                    if (runner.isClassBased) {
                        if ("setClass" == lastAnimation.event) animationsToCancel.push(lastAnimation), cleanup(element, className); else if (runningAnimations[className]) {
                            var current = runningAnimations[className];
                            current.event == animationEvent ? skipAnimation = !0 : (animationsToCancel.push(current), 
                            cleanup(element, className));
                        }
                    } else if ("leave" == animationEvent && runningAnimations["ng-leave"]) skipAnimation = !0; else {
                        for (var klass in runningAnimations) animationsToCancel.push(runningAnimations[klass]), 
                        cleanup(element, klass);
                        runningAnimations = {}, totalActiveAnimations = 0;
                    }
                    animationsToCancel.length > 0 && forEach(animationsToCancel, function(operation) {
                        operation.cancel();
                    });
                }
                if (!runner.isClassBased || runner.isSetClassOperation || skipAnimation || (skipAnimation = "addClass" == animationEvent == element.hasClass(className)), 
                skipAnimation) return fireDOMOperation(), fireBeforeCallbackAsync(), fireAfterCallbackAsync(), 
                void fireDoneCallbackAsync();
                "leave" == animationEvent && element.one("$destroy", function(e) {
                    var element = angular.element(this), state = element.data(NG_ANIMATE_STATE);
                    if (state) {
                        var activeLeaveAnimation = state.active["ng-leave"];
                        activeLeaveAnimation && (activeLeaveAnimation.cancel(), cleanup(element, "ng-leave"));
                    }
                }), element.addClass(NG_ANIMATE_CLASS_NAME);
                var localAnimationCount = globalAnimationCounter++;
                totalActiveAnimations++, runningAnimations[className] = runner, element.data(NG_ANIMATE_STATE, {
                    last: runner,
                    active: runningAnimations,
                    index: localAnimationCount,
                    totalActive: totalActiveAnimations
                }), fireBeforeCallbackAsync(), runner.before(function(cancelled) {
                    var data = element.data(NG_ANIMATE_STATE);
                    cancelled = cancelled || !data || !data.active[className] || runner.isClassBased && data.active[className].event != animationEvent, 
                    fireDOMOperation(), cancelled === !0 ? closeAnimation() : (fireAfterCallbackAsync(), 
                    runner.after(closeAnimation));
                });
            }
            function cancelChildAnimations(element) {
                var node = extractElementNode(element);
                if (node) {
                    var nodes = angular.isFunction(node.getElementsByClassName) ? node.getElementsByClassName(NG_ANIMATE_CLASS_NAME) : node.querySelectorAll("." + NG_ANIMATE_CLASS_NAME);
                    forEach(nodes, function(element) {
                        element = angular.element(element);
                        var data = element.data(NG_ANIMATE_STATE);
                        data && data.active && forEach(data.active, function(runner) {
                            runner.cancel();
                        });
                    });
                }
            }
            function cleanup(element, className) {
                if (isMatchingElement(element, $rootElement)) rootAnimateState.disabled || (rootAnimateState.running = !1, 
                rootAnimateState.structural = !1); else if (className) {
                    var data = element.data(NG_ANIMATE_STATE) || {}, removeAnimations = className === !0;
                    !removeAnimations && data.active && data.active[className] && (data.totalActive--, 
                    delete data.active[className]), (removeAnimations || !data.totalActive) && (element.removeClass(NG_ANIMATE_CLASS_NAME), 
                    element.removeData(NG_ANIMATE_STATE));
                }
            }
            function animationsDisabled(element, parentElement) {
                if (rootAnimateState.disabled) return !0;
                if (isMatchingElement(element, $rootElement)) return rootAnimateState.running;
                var allowChildAnimations, parentRunningAnimation, hasParent;
                do {
                    if (0 === parentElement.length) break;
                    var isRoot = isMatchingElement(parentElement, $rootElement), state = isRoot ? rootAnimateState : parentElement.data(NG_ANIMATE_STATE) || {};
                    if (state.disabled) return !0;
                    if (isRoot && (hasParent = !0), allowChildAnimations !== !1) {
                        var animateChildrenFlag = parentElement.data(NG_ANIMATE_CHILDREN);
                        angular.isDefined(animateChildrenFlag) && (allowChildAnimations = animateChildrenFlag);
                    }
                    parentRunningAnimation = parentRunningAnimation || state.running || state.last && !state.last.isClassBased;
                } while (parentElement = parentElement.parent());
                return !hasParent || !allowChildAnimations && parentRunningAnimation;
            }
            var globalAnimationCounter = 0;
            $rootElement.data(NG_ANIMATE_STATE, rootAnimateState), $rootScope.$$postDigest(function() {
                $rootScope.$$postDigest(function() {
                    rootAnimateState.running = !1;
                });
            });
            var classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function(className) {
                return classNameFilter.test(className);
            } : function() {
                return !0;
            };
            return {
                enter: function(element, parentElement, afterElement, doneCallback) {
                    element = angular.element(element), parentElement = prepareElement(parentElement), 
                    afterElement = prepareElement(afterElement), blockElementAnimations(element), $delegate.enter(element, parentElement, afterElement), 
                    $rootScope.$$postDigest(function() {
                        element = stripCommentsFromElement(element), performAnimation("enter", "ng-enter", element, parentElement, afterElement, noop, doneCallback);
                    });
                },
                leave: function(element, doneCallback) {
                    element = angular.element(element), cancelChildAnimations(element), blockElementAnimations(element), 
                    $rootScope.$$postDigest(function() {
                        performAnimation("leave", "ng-leave", stripCommentsFromElement(element), null, null, function() {
                            $delegate.leave(element);
                        }, doneCallback);
                    });
                },
                move: function(element, parentElement, afterElement, doneCallback) {
                    element = angular.element(element), parentElement = prepareElement(parentElement), 
                    afterElement = prepareElement(afterElement), cancelChildAnimations(element), blockElementAnimations(element), 
                    $delegate.move(element, parentElement, afterElement), $rootScope.$$postDigest(function() {
                        element = stripCommentsFromElement(element), performAnimation("move", "ng-move", element, parentElement, afterElement, noop, doneCallback);
                    });
                },
                addClass: function(element, className, doneCallback) {
                    element = angular.element(element), element = stripCommentsFromElement(element), 
                    performAnimation("addClass", className, element, null, null, function() {
                        $delegate.addClass(element, className);
                    }, doneCallback);
                },
                removeClass: function(element, className, doneCallback) {
                    element = angular.element(element), element = stripCommentsFromElement(element), 
                    performAnimation("removeClass", className, element, null, null, function() {
                        $delegate.removeClass(element, className);
                    }, doneCallback);
                },
                setClass: function(element, add, remove, doneCallback) {
                    element = angular.element(element), element = stripCommentsFromElement(element), 
                    performAnimation("setClass", [ add, remove ], element, null, null, function() {
                        $delegate.setClass(element, add, remove);
                    }, doneCallback);
                },
                enabled: function(value, element) {
                    switch (arguments.length) {
                      case 2:
                        if (value) cleanup(element); else {
                            var data = element.data(NG_ANIMATE_STATE) || {};
                            data.disabled = !0, element.data(NG_ANIMATE_STATE, data);
                        }
                        break;

                      case 1:
                        rootAnimateState.disabled = !value;
                        break;

                      default:
                        value = !rootAnimateState.disabled;
                    }
                    return !!value;
                }
            };
        } ]), $animateProvider.register("", [ "$window", "$sniffer", "$timeout", "$$animateReflow", function($window, $sniffer, $timeout, $$animateReflow) {
            function afterReflow(element, callback) {
                cancelAnimationReflow && cancelAnimationReflow(), animationReflowQueue.push(callback), 
                cancelAnimationReflow = $$animateReflow(function() {
                    forEach(animationReflowQueue, function(fn) {
                        fn();
                    }), animationReflowQueue = [], cancelAnimationReflow = null, lookupCache = {};
                });
            }
            function animationCloseHandler(element, totalTime) {
                var node = extractElementNode(element);
                element = angular.element(node), animationElementQueue.push(element);
                var futureTimestamp = Date.now() + totalTime;
                closingTimestamp >= futureTimestamp || ($timeout.cancel(closingTimer), closingTimestamp = futureTimestamp, 
                closingTimer = $timeout(function() {
                    closeAllAnimations(animationElementQueue), animationElementQueue = [];
                }, totalTime, !1));
            }
            function closeAllAnimations(elements) {
                forEach(elements, function(element) {
                    var elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                    elementData && (elementData.closeAnimationFn || noop)();
                });
            }
            function getElementAnimationDetails(element, cacheKey) {
                var data = cacheKey ? lookupCache[cacheKey] : null;
                if (!data) {
                    var transitionDelayStyle, animationDelayStyle, transitionDurationStyle, transitionPropertyStyle, transitionDuration = 0, transitionDelay = 0, animationDuration = 0, animationDelay = 0;
                    forEach(element, function(element) {
                        if (element.nodeType == ELEMENT_NODE) {
                            var elementStyles = $window.getComputedStyle(element) || {};
                            transitionDurationStyle = elementStyles[TRANSITION_PROP + DURATION_KEY], transitionDuration = Math.max(parseMaxTime(transitionDurationStyle), transitionDuration), 
                            transitionPropertyStyle = elementStyles[TRANSITION_PROP + PROPERTY_KEY], transitionDelayStyle = elementStyles[TRANSITION_PROP + DELAY_KEY], 
                            transitionDelay = Math.max(parseMaxTime(transitionDelayStyle), transitionDelay), 
                            animationDelayStyle = elementStyles[ANIMATION_PROP + DELAY_KEY], animationDelay = Math.max(parseMaxTime(animationDelayStyle), animationDelay);
                            var aDuration = parseMaxTime(elementStyles[ANIMATION_PROP + DURATION_KEY]);
                            aDuration > 0 && (aDuration *= parseInt(elementStyles[ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY], 10) || 1), 
                            animationDuration = Math.max(aDuration, animationDuration);
                        }
                    }), data = {
                        total: 0,
                        transitionPropertyStyle: transitionPropertyStyle,
                        transitionDurationStyle: transitionDurationStyle,
                        transitionDelayStyle: transitionDelayStyle,
                        transitionDelay: transitionDelay,
                        transitionDuration: transitionDuration,
                        animationDelayStyle: animationDelayStyle,
                        animationDelay: animationDelay,
                        animationDuration: animationDuration
                    }, cacheKey && (lookupCache[cacheKey] = data);
                }
                return data;
            }
            function parseMaxTime(str) {
                var maxValue = 0, values = angular.isString(str) ? str.split(/\s*,\s*/) : [];
                return forEach(values, function(value) {
                    maxValue = Math.max(parseFloat(value) || 0, maxValue);
                }), maxValue;
            }
            function getCacheKey(element) {
                var parentElement = element.parent(), parentID = parentElement.data(NG_ANIMATE_PARENT_KEY);
                return parentID || (parentElement.data(NG_ANIMATE_PARENT_KEY, ++parentCounter), 
                parentID = parentCounter), parentID + "-" + extractElementNode(element).getAttribute("class");
            }
            function animateSetup(animationEvent, element, className, calculationDecorator) {
                var cacheKey = getCacheKey(element), eventCacheKey = cacheKey + " " + className, itemIndex = lookupCache[eventCacheKey] ? ++lookupCache[eventCacheKey].total : 0, stagger = {};
                if (itemIndex > 0) {
                    var staggerClassName = className + "-stagger", staggerCacheKey = cacheKey + " " + staggerClassName, applyClasses = !lookupCache[staggerCacheKey];
                    applyClasses && element.addClass(staggerClassName), stagger = getElementAnimationDetails(element, staggerCacheKey), 
                    applyClasses && element.removeClass(staggerClassName);
                }
                calculationDecorator = calculationDecorator || function(fn) {
                    return fn();
                }, element.addClass(className);
                var formerData = element.data(NG_ANIMATE_CSS_DATA_KEY) || {}, timings = calculationDecorator(function() {
                    return getElementAnimationDetails(element, eventCacheKey);
                }), transitionDuration = timings.transitionDuration, animationDuration = timings.animationDuration;
                if (0 === transitionDuration && 0 === animationDuration) return element.removeClass(className), 
                !1;
                element.data(NG_ANIMATE_CSS_DATA_KEY, {
                    running: formerData.running || 0,
                    itemIndex: itemIndex,
                    stagger: stagger,
                    timings: timings,
                    closeAnimationFn: noop
                });
                var isCurrentlyAnimating = formerData.running > 0 || "setClass" == animationEvent;
                return transitionDuration > 0 && blockTransitions(element, className, isCurrentlyAnimating), 
                animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration && blockKeyframeAnimations(element), 
                !0;
            }
            function isStructuralAnimation(className) {
                return "ng-enter" == className || "ng-move" == className || "ng-leave" == className;
            }
            function blockTransitions(element, className, isAnimating) {
                isStructuralAnimation(className) || !isAnimating ? extractElementNode(element).style[TRANSITION_PROP + PROPERTY_KEY] = "none" : element.addClass(NG_ANIMATE_BLOCK_CLASS_NAME);
            }
            function blockKeyframeAnimations(element) {
                extractElementNode(element).style[ANIMATION_PROP] = "none 0s";
            }
            function unblockTransitions(element, className) {
                var prop = TRANSITION_PROP + PROPERTY_KEY, node = extractElementNode(element);
                node.style[prop] && node.style[prop].length > 0 && (node.style[prop] = ""), element.removeClass(NG_ANIMATE_BLOCK_CLASS_NAME);
            }
            function unblockKeyframeAnimations(element) {
                var prop = ANIMATION_PROP, node = extractElementNode(element);
                node.style[prop] && node.style[prop].length > 0 && (node.style[prop] = "");
            }
            function animateRun(animationEvent, element, className, activeAnimationComplete) {
                function onEnd(cancelled) {
                    element.off(css3AnimationEvents, onAnimationProgress), element.removeClass(activeClassName), 
                    animateClose(element, className);
                    var node = extractElementNode(element);
                    for (var i in appliedStyles) node.style.removeProperty(appliedStyles[i]);
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && activeAnimationComplete();
                }
                var node = extractElementNode(element), elementData = element.data(NG_ANIMATE_CSS_DATA_KEY);
                if (-1 == node.getAttribute("class").indexOf(className) || !elementData) return void activeAnimationComplete();
                var activeClassName = "";
                forEach(className.split(" "), function(klass, i) {
                    activeClassName += (i > 0 ? " " : "") + klass + "-active";
                });
                var stagger = elementData.stagger, timings = elementData.timings, itemIndex = elementData.itemIndex, maxDuration = Math.max(timings.transitionDuration, timings.animationDuration), maxDelay = Math.max(timings.transitionDelay, timings.animationDelay), maxDelayTime = maxDelay * ONE_SECOND, startTime = Date.now(), css3AnimationEvents = ANIMATIONEND_EVENT + " " + TRANSITIONEND_EVENT, style = "", appliedStyles = [];
                if (timings.transitionDuration > 0) {
                    var propertyStyle = timings.transitionPropertyStyle;
                    -1 == propertyStyle.indexOf("all") && (style += CSS_PREFIX + "transition-property: " + propertyStyle + ";", 
                    style += CSS_PREFIX + "transition-duration: " + timings.transitionDurationStyle + ";", 
                    appliedStyles.push(CSS_PREFIX + "transition-property"), appliedStyles.push(CSS_PREFIX + "transition-duration"));
                }
                if (itemIndex > 0) {
                    if (stagger.transitionDelay > 0 && 0 === stagger.transitionDuration) {
                        var delayStyle = timings.transitionDelayStyle;
                        style += CSS_PREFIX + "transition-delay: " + prepareStaggerDelay(delayStyle, stagger.transitionDelay, itemIndex) + "; ", 
                        appliedStyles.push(CSS_PREFIX + "transition-delay");
                    }
                    stagger.animationDelay > 0 && 0 === stagger.animationDuration && (style += CSS_PREFIX + "animation-delay: " + prepareStaggerDelay(timings.animationDelayStyle, stagger.animationDelay, itemIndex) + "; ", 
                    appliedStyles.push(CSS_PREFIX + "animation-delay"));
                }
                if (appliedStyles.length > 0) {
                    var oldStyle = node.getAttribute("style") || "";
                    node.setAttribute("style", oldStyle + "; " + style);
                }
                element.on(css3AnimationEvents, onAnimationProgress), element.addClass(activeClassName), 
                elementData.closeAnimationFn = function() {
                    onEnd(), activeAnimationComplete();
                };
                var staggerTime = itemIndex * (Math.max(stagger.animationDelay, stagger.transitionDelay) || 0), animationTime = (maxDelay + maxDuration) * CLOSING_TIME_BUFFER, totalTime = (staggerTime + animationTime) * ONE_SECOND;
                return elementData.running++, animationCloseHandler(element, totalTime), onEnd;
            }
            function prepareStaggerDelay(delayStyle, staggerDelay, index) {
                var style = "";
                return forEach(delayStyle.split(","), function(val, i) {
                    style += (i > 0 ? "," : "") + (index * staggerDelay + parseInt(val, 10)) + "s";
                }), style;
            }
            function animateBefore(animationEvent, element, className, calculationDecorator) {
                return animateSetup(animationEvent, element, className, calculationDecorator) ? function(cancelled) {
                    cancelled && animateClose(element, className);
                } : void 0;
            }
            function animateAfter(animationEvent, element, className, afterAnimationComplete) {
                return element.data(NG_ANIMATE_CSS_DATA_KEY) ? animateRun(animationEvent, element, className, afterAnimationComplete) : (animateClose(element, className), 
                void afterAnimationComplete());
            }
            function animate(animationEvent, element, className, animationComplete) {
                var preReflowCancellation = animateBefore(animationEvent, element, className);
                if (!preReflowCancellation) return void animationComplete();
                var cancel = preReflowCancellation;
                return afterReflow(element, function() {
                    unblockTransitions(element, className), unblockKeyframeAnimations(element), cancel = animateAfter(animationEvent, element, className, animationComplete);
                }), function(cancelled) {
                    (cancel || noop)(cancelled);
                };
            }
            function animateClose(element, className) {
                element.removeClass(className);
                var data = element.data(NG_ANIMATE_CSS_DATA_KEY);
                data && (data.running && data.running--, data.running && 0 !== data.running || element.removeData(NG_ANIMATE_CSS_DATA_KEY));
            }
            function suffixClasses(classes, suffix) {
                var className = "";
                return classes = angular.isArray(classes) ? classes : classes.split(/\s+/), forEach(classes, function(klass, i) {
                    klass && klass.length > 0 && (className += (i > 0 ? " " : "") + klass + suffix);
                }), className;
            }
            var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, CSS_PREFIX = "";
            window.ontransitionend === undefined && window.onwebkittransitionend !== undefined ? (CSS_PREFIX = "-webkit-", 
            TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
            TRANSITIONEND_EVENT = "transitionend"), window.onanimationend === undefined && window.onwebkitanimationend !== undefined ? (CSS_PREFIX = "-webkit-", 
            ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
            ANIMATIONEND_EVENT = "animationend");
            var cancelAnimationReflow, DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", NG_ANIMATE_PARENT_KEY = "$$ngAnimateKey", NG_ANIMATE_CSS_DATA_KEY = "$$ngAnimateCSS3Data", NG_ANIMATE_BLOCK_CLASS_NAME = "ng-animate-block-transitions", ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, ONE_SECOND = 1e3, lookupCache = {}, parentCounter = 0, animationReflowQueue = [], closingTimer = null, closingTimestamp = 0, animationElementQueue = [];
            return {
                enter: function(element, animationCompleted) {
                    return animate("enter", element, "ng-enter", animationCompleted);
                },
                leave: function(element, animationCompleted) {
                    return animate("leave", element, "ng-leave", animationCompleted);
                },
                move: function(element, animationCompleted) {
                    return animate("move", element, "ng-move", animationCompleted);
                },
                beforeSetClass: function(element, add, remove, animationCompleted) {
                    var className = suffixClasses(remove, "-remove") + " " + suffixClasses(add, "-add"), cancellationMethod = animateBefore("setClass", element, className, function(fn) {
                        var klass = element.attr("class");
                        element.removeClass(remove), element.addClass(add);
                        var timings = fn();
                        return element.attr("class", klass), timings;
                    });
                    return cancellationMethod ? (afterReflow(element, function() {
                        unblockTransitions(element, className), unblockKeyframeAnimations(element), animationCompleted();
                    }), cancellationMethod) : void animationCompleted();
                },
                beforeAddClass: function(element, className, animationCompleted) {
                    var cancellationMethod = animateBefore("addClass", element, suffixClasses(className, "-add"), function(fn) {
                        element.addClass(className);
                        var timings = fn();
                        return element.removeClass(className), timings;
                    });
                    return cancellationMethod ? (afterReflow(element, function() {
                        unblockTransitions(element, className), unblockKeyframeAnimations(element), animationCompleted();
                    }), cancellationMethod) : void animationCompleted();
                },
                setClass: function(element, add, remove, animationCompleted) {
                    remove = suffixClasses(remove, "-remove"), add = suffixClasses(add, "-add");
                    var className = remove + " " + add;
                    return animateAfter("setClass", element, className, animationCompleted);
                },
                addClass: function(element, className, animationCompleted) {
                    return animateAfter("addClass", element, suffixClasses(className, "-add"), animationCompleted);
                },
                beforeRemoveClass: function(element, className, animationCompleted) {
                    var cancellationMethod = animateBefore("removeClass", element, suffixClasses(className, "-remove"), function(fn) {
                        var klass = element.attr("class");
                        element.removeClass(className);
                        var timings = fn();
                        return element.attr("class", klass), timings;
                    });
                    return cancellationMethod ? (afterReflow(element, function() {
                        unblockTransitions(element, className), unblockKeyframeAnimations(element), animationCompleted();
                    }), cancellationMethod) : void animationCompleted();
                },
                removeClass: function(element, className, animationCompleted) {
                    return animateAfter("removeClass", element, suffixClasses(className, "-remove"), animationCompleted);
                }
            };
        } ]);
    } ]);
}(window, window.angular), function(window, angular, undefined) {
    function $SanitizeProvider() {
        this.$get = [ "$$sanitizeUri", function($$sanitizeUri) {
            return function(html) {
                var buf = [];
                return htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                    return !/^unsafe/.test($$sanitizeUri(uri, isImage));
                })), buf.join("");
            };
        } ];
    }
    function sanitizeText(chars) {
        var buf = [], writer = htmlSanitizeWriter(buf, angular.noop);
        return writer.chars(chars), buf.join("");
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function htmlParser(html, handler) {
        function parseStartTag(tag, tagName, rest, unary) {
            if (tagName = angular.lowercase(tagName), blockElements[tagName]) for (;stack.last() && inlineElements[stack.last()]; ) parseEndTag("", stack.last());
            optionalEndTagElements[tagName] && stack.last() == tagName && parseEndTag("", tagName), 
            unary = voidElements[tagName] || !!unary, unary || stack.push(tagName);
            var attrs = {};
            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || "";
                attrs[name] = decodeEntities(value);
            }), handler.start && handler.start(tagName, attrs, unary);
        }
        function parseEndTag(tag, tagName) {
            var i, pos = 0;
            if (tagName = angular.lowercase(tagName)) for (pos = stack.length - 1; pos >= 0 && stack[pos] != tagName; pos--) ;
            if (pos >= 0) {
                for (i = stack.length - 1; i >= pos; i--) handler.end && handler.end(stack[i]);
                stack.length = pos;
            }
        }
        var index, chars, match, stack = [], last = html;
        for (stack.last = function() {
            return stack[stack.length - 1];
        }; html; ) {
            if (chars = !0, stack.last() && specialElements[stack.last()]) html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", "i"), function(all, text) {
                return text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1"), handler.chars && handler.chars(decodeEntities(text)), 
                "";
            }), parseEndTag("", stack.last()); else if (0 === html.indexOf("<!--") ? (index = html.indexOf("--", 4), 
            index >= 0 && html.lastIndexOf("-->", index) === index && (handler.comment && handler.comment(html.substring(4, index)), 
            html = html.substring(index + 3), chars = !1)) : DOCTYPE_REGEXP.test(html) ? (match = html.match(DOCTYPE_REGEXP), 
            match && (html = html.replace(match[0], ""), chars = !1)) : BEGING_END_TAGE_REGEXP.test(html) ? (match = html.match(END_TAG_REGEXP), 
            match && (html = html.substring(match[0].length), match[0].replace(END_TAG_REGEXP, parseEndTag), 
            chars = !1)) : BEGIN_TAG_REGEXP.test(html) && (match = html.match(START_TAG_REGEXP), 
            match && (html = html.substring(match[0].length), match[0].replace(START_TAG_REGEXP, parseStartTag), 
            chars = !1)), chars) {
                index = html.indexOf("<");
                var text = 0 > index ? html : html.substring(0, index);
                html = 0 > index ? "" : html.substring(index), handler.chars && handler.chars(decodeEntities(text));
            }
            if (html == last) throw $sanitizeMinErr("badparse", "The sanitizer was unable to parse the following block of html: {0}", html);
            last = html;
        }
        parseEndTag();
    }
    function decodeEntities(value) {
        if (!value) return "";
        var parts = spaceRe.exec(value), spaceBefore = parts[1], spaceAfter = parts[3], content = parts[2];
        return content && (hiddenPre.innerHTML = content.replace(/</g, "&lt;"), content = "textContent" in hiddenPre ? hiddenPre.textContent : hiddenPre.innerText), 
        spaceBefore + content + spaceAfter;
    }
    function encodeEntities(value) {
        return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
            var hi = value.charCodeAt(0), low = value.charCodeAt(1);
            return "&#" + (1024 * (hi - 55296) + (low - 56320) + 65536) + ";";
        }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
            return "&#" + value.charCodeAt(0) + ";";
        }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function htmlSanitizeWriter(buf, uriValidator) {
        var ignore = !1, out = angular.bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary) {
                tag = angular.lowercase(tag), !ignore && specialElements[tag] && (ignore = tag), 
                ignore || validElements[tag] !== !0 || (out("<"), out(tag), angular.forEach(attrs, function(value, key) {
                    var lkey = angular.lowercase(key), isImage = "img" === tag && "src" === lkey || "background" === lkey;
                    validAttrs[lkey] !== !0 || uriAttrs[lkey] === !0 && !uriValidator(value, isImage) || (out(" "), 
                    out(key), out('="'), out(encodeEntities(value)), out('"'));
                }), out(unary ? "/>" : ">"));
            },
            end: function(tag) {
                tag = angular.lowercase(tag), ignore || validElements[tag] !== !0 || (out("</"), 
                out(tag), out(">")), tag == ignore && (ignore = !1);
            },
            chars: function(chars) {
                ignore || out(encodeEntities(chars));
            }
        };
    }
    var $sanitizeMinErr = angular.$$minErr("$sanitize"), START_TAG_REGEXP = /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/, END_TAG_REGEXP = /^<\s*\/\s*([\w:-]+)[^>]*>/, ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, BEGIN_TAG_REGEXP = /^</, BEGING_END_TAGE_REGEXP = /^<\s*\//, COMMENT_REGEXP = /<!--(.*?)-->/g, DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i, CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g, voidElements = makeMap("area,br,col,hr,img,wbr"), optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = makeMap("rp,rt"), optionalEndTagElements = angular.extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements), blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")), inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), specialElements = makeMap("script,style"), validElements = angular.extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements), uriAttrs = makeMap("background,cite,href,longdesc,src,usemap"), validAttrs = angular.extend({}, uriAttrs, makeMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,target,title,type,valign,value,vspace,width")), hiddenPre = document.createElement("pre"), spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider), angular.module("ngSanitize").filter("linky", [ "$sanitize", function($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>]/, MAILTO_REGEXP = /^mailto:/;
        return function(text, target) {
            function addText(text) {
                text && html.push(sanitizeText(text));
            }
            function addLink(url, text) {
                html.push("<a "), angular.isDefined(target) && (html.push('target="'), html.push(target), 
                html.push('" ')), html.push('href="'), html.push(url), html.push('">'), addText(text), 
                html.push("</a>");
            }
            if (!text) return text;
            for (var match, url, i, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP); ) url = match[0], 
            match[2] == match[3] && (url = "mailto:" + url), i = match.index, addText(raw.substr(0, i)), 
            addLink(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
            return addText(raw), $sanitize(html.join(""));
        };
    } ]);
}(window, window.angular), angular.module("ui.bootstrap", [ "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.transition", []).factory("$transition", [ "$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) if (void 0 !== transElement.style[name]) return endEventNames[name];
    }
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer(), endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"], transitionEndHandler = function(event) {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler), deferred.resolve(element);
            });
        };
        return endEventName && element.bind(endEventName, transitionEndHandler), $timeout(function() {
            angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger), 
            endEventName || deferred.resolve(element);
        }), deferred.promise.cancel = function() {
            endEventName && element.unbind(endEventName, transitionEndHandler), deferred.reject("Transition cancelled");
        }, deferred.promise;
    }, transElement = document.createElement("trans"), transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    }, animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    };
    return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames), 
    $transition.animationEndEventName = findEndEventName(animationEndEventNames), $transition;
} ]), angular.module("ui.bootstrap.collapse", [ "ui.bootstrap.transition" ]).directive("collapse", [ "$transition", function($transition) {
    return {
        link: function(scope, element, attrs) {
            function doTransition(change) {
                function newTransitionDone() {
                    currentTransition === newTransition && (currentTransition = void 0);
                }
                var newTransition = $transition(element, change);
                return currentTransition && currentTransition.cancel(), currentTransition = newTransition, 
                newTransition.then(newTransitionDone, newTransitionDone), newTransition;
            }
            function expand() {
                initialAnimSkip ? (initialAnimSkip = !1, expandDone()) : (element.removeClass("collapse").addClass("collapsing"), 
                doTransition({
                    height: element[0].scrollHeight + "px"
                }).then(expandDone));
            }
            function expandDone() {
                element.removeClass("collapsing"), element.addClass("collapse in"), element.css({
                    height: "auto"
                });
            }
            function collapse() {
                if (initialAnimSkip) initialAnimSkip = !1, collapseDone(), element.css({
                    height: 0
                }); else {
                    element.css({
                        height: element[0].scrollHeight + "px"
                    });
                    element[0].offsetWidth;
                    element.removeClass("collapse in").addClass("collapsing"), doTransition({
                        height: 0
                    }).then(collapseDone);
                }
            }
            function collapseDone() {
                element.removeClass("collapsing"), element.addClass("collapse");
            }
            var currentTransition, initialAnimSkip = !0;
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse" ]).constant("accordionConfig", {
    closeOthers: !0
}).controller("AccordionController", [ "$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        closeOthers && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1);
    };
} ]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: !0,
        replace: !1,
        templateUrl: "template/accordion/accordion.html"
    };
}).directive("accordionGroup", function() {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/accordion/accordion-group.html",
        scope: {
            heading: "@",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope), scope.$watch("isOpen", function(value) {
                value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function() {
                scope.isDisabled || (scope.isOpen = !scope.isOpen);
            };
        }
    };
}).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: !0,
        template: "",
        replace: !0,
        require: "^accordionGroup",
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, function() {}));
        }
    };
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                heading && (element.html(""), element.append(heading));
            });
        }
    };
}), angular.module("ui.bootstrap.alert", []).controller("AlertController", [ "$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = "close" in $attrs;
} ]).directive("alert", function() {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@",
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe), scope.$watch(attr.bindHtmlUnsafe, function(value) {
            element.html(value || "");
        });
    };
}), angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", [ "buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("btnRadio", function() {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                var isActive = element.hasClass(buttonsCtrl.activeClass);
                (!isActive || angular.isDefined(attrs.uncheckable)) && scope.$apply(function() {
                    ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio)), ngModelCtrl.$render();
                });
            });
        }
    };
}).directive("btnCheckbox", function() {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.carousel", [ "ui.bootstrap.transition" ]).controller("CarouselController", [ "$scope", "$timeout", "$transition", function($scope, $timeout, $transition) {
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval >= 0 && (currentTimeout = $timeout(timerFn, interval));
    }
    function resetTimer() {
        currentTimeout && ($timeout.cancel(currentTimeout), currentTimeout = null);
    }
    function timerFn() {
        isPlaying ? ($scope.next(), restartTimer()) : $scope.pause();
    }
    var currentTimeout, isPlaying, self = this, slides = self.slides = $scope.slides = [], currentIndex = -1;
    self.currentSlide = null;
    var destroyed = !1;
    self.select = $scope.select = function(nextSlide, direction) {
        function goNext() {
            if (!destroyed) {
                if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                    nextSlide.$element.addClass(direction);
                    nextSlide.$element[0].offsetWidth;
                    angular.forEach(slides, function(slide) {
                        angular.extend(slide, {
                            direction: "",
                            entering: !1,
                            leaving: !1,
                            active: !1
                        });
                    }), angular.extend(nextSlide, {
                        direction: direction,
                        active: !0,
                        entering: !0
                    }), angular.extend(self.currentSlide || {}, {
                        direction: direction,
                        leaving: !0
                    }), $scope.$currentTransition = $transition(nextSlide.$element, {}), function(next, current) {
                        $scope.$currentTransition.then(function() {
                            transitionDone(next, current);
                        }, function() {
                            transitionDone(next, current);
                        });
                    }(nextSlide, self.currentSlide);
                } else transitionDone(nextSlide, self.currentSlide);
                self.currentSlide = nextSlide, currentIndex = nextIndex, restartTimer();
            }
        }
        function transitionDone(next, current) {
            angular.extend(next, {
                direction: "",
                active: !0,
                leaving: !1,
                entering: !1
            }), angular.extend(current || {}, {
                direction: "",
                active: !1,
                leaving: !1,
                entering: !1
            }), $scope.$currentTransition = null;
        }
        var nextIndex = slides.indexOf(nextSlide);
        void 0 === direction && (direction = nextIndex > currentIndex ? "next" : "prev"), 
        nextSlide && nextSlide !== self.currentSlide && ($scope.$currentTransition ? ($scope.$currentTransition.cancel(), 
        $timeout(goNext)) : goNext());
    }, $scope.$on("$destroy", function() {
        destroyed = !0;
    }), self.indexOfSlide = function(slide) {
        return slides.indexOf(slide);
    }, $scope.next = function() {
        var newIndex = (currentIndex + 1) % slides.length;
        return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "next");
    }, $scope.prev = function() {
        var newIndex = 0 > currentIndex - 1 ? slides.length - 1 : currentIndex - 1;
        return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "prev");
    }, $scope.isActive = function(slide) {
        return self.currentSlide === slide;
    }, $scope.$watch("interval", restartTimer), $scope.$on("$destroy", resetTimer), 
    $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, self.addSlide = function(slide, element) {
        slide.$element = element, slides.push(slide), 1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]), 
        1 == slides.length && $scope.play()) : slide.active = !1;
    }, self.removeSlide = function(slide) {
        var index = slides.indexOf(slide);
        slides.splice(index, 1), slides.length > 0 && slide.active ? index >= slides.length ? self.select(slides[index - 1]) : self.select(slides[index]) : currentIndex > index && currentIndex--;
    };
} ]).directive("carousel", [ function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        controller: "CarouselController",
        require: "carousel",
        templateUrl: "template/carousel/carousel.html",
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "="
        }
    };
} ]).directive("slide", function() {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/carousel/slide.html",
        scope: {
            active: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                active && carouselCtrl.select(scope);
            });
        }
    };
}), angular.module("ui.bootstrap.dateparser", []).service("dateParser", [ "$locale", "orderByFilter", function($locale, orderByFilter) {
    function isValid(year, month, date) {
        return 1 === month && date > 28 ? 29 === date && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) : 3 === month || 5 === month || 8 === month || 10 === month ? 31 > date : !0;
    }
    this.parsers = {};
    var formatCodeToRegex = {
        yyyy: {
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value;
            }
        },
        yy: {
            regex: "\\d{2}",
            apply: function(value) {
                this.year = +value + 2e3;
            }
        },
        y: {
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value;
            }
        },
        MMMM: {
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            }
        },
        MMM: {
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            }
        },
        MM: {
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            }
        },
        M: {
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            }
        },
        dd: {
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            }
        },
        d: {
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            }
        },
        EEEE: {
            regex: $locale.DATETIME_FORMATS.DAY.join("|")
        },
        EEE: {
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|")
        }
    };
    this.createParser = function(format) {
        var map = [], regex = format.split("");
        return angular.forEach(formatCodeToRegex, function(data, code) {
            var index = format.indexOf(code);
            if (index > -1) {
                format = format.split(""), regex[index] = "(" + data.regex + ")", format[index] = "$";
                for (var i = index + 1, n = index + code.length; n > i; i++) regex[i] = "", format[i] = "$";
                format = format.join(""), map.push({
                    index: index,
                    apply: data.apply
                });
            }
        }), {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }, this.parse = function(input, format) {
        if (!angular.isString(input)) return input;
        format = $locale.DATETIME_FORMATS[format] || format, this.parsers[format] || (this.parsers[format] = this.createParser(format));
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex);
        if (results && results.length) {
            for (var dt, fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0
            }, i = 1, n = results.length; n > i; i++) {
                var mapper = map[i - 1];
                mapper.apply && mapper.apply.call(fields, results[i]);
            }
            return isValid(fields.year, fields.month, fields.date) && (dt = new Date(fields.year, fields.month, fields.date, fields.hours)), 
            dt;
        }
    };
} ]), angular.module("ui.bootstrap.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop];
    }
    function isStaticPositioned(element) {
        return "static" === (getStyle(element, "position") || "static");
    }
    var parentOffsetEl = function(element) {
        for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
        return offsetParent || docDomEl;
    };
    return {
        position: function(element) {
            var elBCR = this.offset(element), offsetParentBCR = {
                top: 0,
                left: 0
            }, offsetParentEl = parentOffsetEl(element[0]);
            offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)), 
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
            var hostElPos, targetElWidth, targetElHeight, targetElPos, positionStrParts = positionStr.split("-"), pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center";
            hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl), targetElWidth = targetEl.prop("offsetWidth"), 
            targetElHeight = targetEl.prop("offsetHeight");
            var shiftWidth = {
                center: function() {
                    return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
                },
                left: function() {
                    return hostElPos.left;
                },
                right: function() {
                    return hostElPos.left + hostElPos.width;
                }
            }, shiftHeight = {
                center: function() {
                    return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
                },
                top: function() {
                    return hostElPos.top;
                },
                bottom: function() {
                    return hostElPos.top + hostElPos.height;
                }
            };
            switch (pos0) {
              case "right":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: shiftWidth[pos0]()
                };
                break;

              case "left":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: hostElPos.left - targetElWidth
                };
                break;

              case "bottom":
                targetElPos = {
                    top: shiftHeight[pos0](),
                    left: shiftWidth[pos1]()
                };
                break;

              default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[pos1]()
                };
            }
            return targetElPos;
        }
    };
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.position" ]).constant("datepickerConfig", {
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    datepickerMode: "day",
    minMode: "day",
    maxMode: "year",
    showWeeks: !0,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
}).controller("DatepickerController", [ "$scope", "$attrs", "$parse", "$interpolate", "$timeout", "$log", "dateFilter", "datepickerConfig", function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.modes = [ "day", "month", "year" ], angular.forEach([ "formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "minMode", "maxMode", "showWeeks", "startingDay", "yearRange" ], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? 8 > index ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
    }), angular.forEach([ "minDate", "maxDate" ], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null, self.refreshView();
        }) : self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }), $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode, 
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date(), 
    $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) ? ($scope.activeDateId = dateObject.uid, 
        !0) : !1;
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$modelValue) {
            var date = new Date(ngModelCtrl.$modelValue), isValid = !isNaN(date);
            isValid ? this.activeDate = date : $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.'), 
            ngModelCtrl.$setValidity("date", isValid);
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            this._refreshView();
            var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
            ngModelCtrl.$setValidity("date-disabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            current: 0 === this.compare(date, new Date())
        };
    }, this.isDisabled = function(date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), ngModelCtrl.$setViewValue(dt), 
            ngModelCtrl.$render();
        } else self.activeDate = date, $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || ($scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        $timeout(function() {
            self.element[0].focus();
        }, 0, !1);
    };
    $scope.$on("datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey) if (evt.preventDefault(), evt.stopPropagation(), 
        "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate), focusElement();
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : ($scope.toggleMode("up" === key ? 1 : -1), focusElement());
    };
} ]).directive("datepicker", function() {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/datepicker.html",
        scope: {
            datepickerMode: "=?",
            dateDisabled: "&"
        },
        require: [ "datepicker", "?^ngModel" ],
        controller: "DatepickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("daypicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/day.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            function getDaysInMonth(year, month) {
                return 1 !== month || year % 4 !== 0 || year % 100 === 0 && year % 400 !== 0 ? DAYS_IN_MONTH[month] : 29;
            }
            function getDates(startDate, n) {
                var dates = new Array(n), current = new Date(startDate), i = 0;
                for (current.setHours(12); n > i; ) dates[i++] = new Date(current), current.setDate(current.getDate() + 1);
                return dates;
            }
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                var time = checkDate.getTime();
                return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
            }
            scope.showWeeks = ctrl.showWeeks, ctrl.step = {
                months: 1
            }, ctrl.element = element;
            var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
            ctrl._refreshView = function() {
                var year = ctrl.activeDate.getFullYear(), month = ctrl.activeDate.getMonth(), firstDayOfMonth = new Date(year, month, 1), difference = ctrl.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
                numDisplayedFromPreviousMonth > 0 && firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
                for (var days = getDates(firstDate, 42), i = 0; 42 > i; i++) days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
                    secondary: days[i].getMonth() !== month,
                    uid: scope.uniqueId + "-" + i
                });
                scope.labels = new Array(7);
                for (var j = 0; 7 > j; j++) scope.labels[j] = {
                    abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
                    full: dateFilter(days[j].date, "EEEE")
                };
                if (scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle), scope.rows = ctrl.split(days, 7), 
                scope.showWeeks) {
                    scope.weekNumbers = [];
                    for (var weekNumber = getISO8601WeekNumber(scope.rows[0][0].date), numWeeks = scope.rows.length; scope.weekNumbers.push(weekNumber++) < numWeeks; ) ;
                }
            }, ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            }, ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getDate();
                if ("left" === key) date -= 1; else if ("up" === key) date -= 7; else if ("right" === key) date += 1; else if ("down" === key) date += 7; else if ("pageup" === key || "pagedown" === key) {
                    var month = ctrl.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
                    ctrl.activeDate.setMonth(month, 1), date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
                } else "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()));
                ctrl.activeDate.setDate(date);
            }, ctrl.refreshView();
        }
    };
} ]).directive("monthpicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/month.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            ctrl.step = {
                years: 1
            }, ctrl.element = element, ctrl._refreshView = function() {
                for (var months = new Array(12), year = ctrl.activeDate.getFullYear(), i = 0; 12 > i; i++) months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
                    uid: scope.uniqueId + "-" + i
                });
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle), scope.rows = ctrl.split(months, 3);
            }, ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
            }, ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getMonth();
                if ("left" === key) date -= 1; else if ("up" === key) date -= 3; else if ("right" === key) date += 1; else if ("down" === key) date += 3; else if ("pageup" === key || "pagedown" === key) {
                    var year = ctrl.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
                    ctrl.activeDate.setFullYear(year);
                } else "home" === key ? date = 0 : "end" === key && (date = 11);
                ctrl.activeDate.setMonth(date);
            }, ctrl.refreshView();
        }
    };
} ]).directive("yearpicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/year.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            function getStartingYear(year) {
                return parseInt((year - 1) / range, 10) * range + 1;
            }
            var range = ctrl.yearRange;
            ctrl.step = {
                years: range
            }, ctrl.element = element, ctrl._refreshView = function() {
                for (var years = new Array(range), i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); range > i; i++) years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
                    uid: scope.uniqueId + "-" + i
                });
                scope.title = [ years[0].label, years[range - 1].label ].join(" - "), scope.rows = ctrl.split(years, 5);
            }, ctrl.compare = function(date1, date2) {
                return date1.getFullYear() - date2.getFullYear();
            }, ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getFullYear();
                "left" === key ? date -= 1 : "up" === key ? date -= 5 : "right" === key ? date += 1 : "down" === key ? date += 5 : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * ctrl.step.years : "home" === key ? date = getStartingYear(ctrl.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1), 
                ctrl.activeDate.setFullYear(date);
            }, ctrl.refreshView();
        }
    };
} ]).constant("datepickerPopupConfig", {
    datepickerPopup: "yyyy-MM-dd",
    currentText: "Today",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: !0,
    appendToBody: !1,
    showButtonBar: !0
}).directive("datepickerPopup", [ "$compile", "$parse", "$document", "$position", "dateFilter", "dateParser", "datepickerPopupConfig", function($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
    return {
        restrict: "EA",
        require: "ngModel",
        scope: {
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@",
            dateDisabled: "&"
        },
        link: function(scope, element, attrs, ngModel) {
            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function($1) {
                    return "-" + $1.toLowerCase();
                });
            }
            function parseDate(viewValue) {
                if (viewValue) {
                    if (angular.isDate(viewValue) && !isNaN(viewValue)) return ngModel.$setValidity("date", !0), 
                    viewValue;
                    if (angular.isString(viewValue)) {
                        var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);
                        return isNaN(date) ? void ngModel.$setValidity("date", !1) : (ngModel.$setValidity("date", !0), 
                        date);
                    }
                    return void ngModel.$setValidity("date", !1);
                }
                return ngModel.$setValidity("date", !0), null;
            }
            var dateFormat, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
            scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
            scope.getText = function(key) {
                return scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
            }, attrs.$observe("datepickerPopup", function(value) {
                dateFormat = value || datepickerPopupConfig.datepickerPopup, ngModel.$render();
            });
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");
            popupEl.attr({
                "ng-model": "date",
                "ng-change": "dateSelection()"
            });
            var datepickerEl = angular.element(popupEl.children()[0]);
            attrs.datepickerOptions && angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function(value, option) {
                datepickerEl.attr(cameltoDash(option), value);
            }), angular.forEach([ "minDate", "maxDate" ], function(key) {
                attrs[key] && (scope.$parent.$watch($parse(attrs[key]), function(value) {
                    scope[key] = value;
                }), datepickerEl.attr(cameltoDash(key), key));
            }), attrs.dateDisabled && datepickerEl.attr("date-disabled", "dateDisabled({ date: date, mode: mode })"), 
            ngModel.$parsers.unshift(parseDate), scope.dateSelection = function(dt) {
                angular.isDefined(dt) && (scope.date = dt), ngModel.$setViewValue(scope.date), ngModel.$render(), 
                closeOnDateSelection && (scope.isOpen = !1, element[0].focus());
            }, element.bind("input change keyup", function() {
                scope.$apply(function() {
                    scope.date = ngModel.$modelValue;
                });
            }), ngModel.$render = function() {
                var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : "";
                element.val(date), scope.date = parseDate(ngModel.$modelValue);
            };
            var documentClickBind = function(event) {
                scope.isOpen && event.target !== element[0] && scope.$apply(function() {
                    scope.isOpen = !1;
                });
            }, keydown = function(evt, noApply) {
                scope.keydown(evt);
            };
            element.bind("keydown", keydown), scope.keydown = function(evt) {
                27 === evt.which ? (evt.preventDefault(), evt.stopPropagation(), scope.close()) : 40 !== evt.which || scope.isOpen || (scope.isOpen = !0);
            }, scope.$watch("isOpen", function(value) {
                value ? (scope.$broadcast("datepicker.focus"), scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                scope.position.top = scope.position.top + element.prop("offsetHeight"), $document.bind("click", documentClickBind)) : $document.unbind("click", documentClickBind);
            }), scope.select = function(date) {
                if ("today" === date) {
                    var today = new Date();
                    angular.isDate(ngModel.$modelValue) ? (date = new Date(ngModel.$modelValue), date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : date = new Date(today.setHours(0, 0, 0, 0));
                }
                scope.dateSelection(date);
            }, scope.close = function() {
                scope.isOpen = !1, element[0].focus();
            };
            var $popup = $compile(popupEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup), scope.$on("$destroy", function() {
                $popup.remove(), element.unbind("keydown", keydown), $document.unbind("click", documentClickBind);
            });
        }
    };
} ]).directive("datepickerPopupWrap", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        templateUrl: "template/datepicker/popup.html",
        link: function(scope, element, attrs) {
            element.bind("click", function(event) {
                event.preventDefault(), event.stopPropagation();
            });
        }
    };
}), angular.module("ui.bootstrap.dropdown", []).constant("dropdownConfig", {
    openClass: "open"
}).service("dropdownService", [ "$document", function($document) {
    var openScope = null;
    this.open = function(dropdownScope) {
        openScope || ($document.bind("click", closeDropdown), $document.bind("keydown", escapeKeyBind)), 
        openScope && openScope !== dropdownScope && (openScope.isOpen = !1), openScope = dropdownScope;
    }, this.close = function(dropdownScope) {
        openScope === dropdownScope && (openScope = null, $document.unbind("click", closeDropdown), 
        $document.unbind("keydown", escapeKeyBind));
    };
    var closeDropdown = function(evt) {
        evt && evt.isDefaultPrevented() || openScope.$apply(function() {
            openScope.isOpen = !1;
        });
    }, escapeKeyBind = function(evt) {
        27 === evt.which && (openScope.focusToggleElement(), closeDropdown());
    };
} ]).controller("DropdownController", [ "$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
    var getIsOpen, self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;
    this.init = function(element) {
        self.$element = element, $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        }));
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        $animate[isOpen ? "addClass" : "removeClass"](self.$element, openClass), isOpen ? (scope.focusToggleElement(), 
        dropdownService.open(scope)) : dropdownService.close(scope), setIsOpen($scope, isOpen), 
        angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
            open: !!isOpen
        });
    }), $scope.$on("$locationChangeSuccess", function() {
        scope.isOpen = !1;
    }), $scope.$on("$destroy", function() {
        scope.$destroy();
    });
} ]).directive("dropdown", function() {
    return {
        restrict: "CA",
        controller: "DropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init(element);
        }
    };
}).directive("dropdownToggle", function() {
    return {
        restrict: "CA",
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.bind("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.transition" ]).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key == stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key == stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}).directive("modalBackdrop", [ "$timeout", function($timeout) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        link: function(scope) {
            scope.animate = !1, $timeout(function() {
                scope.animate = !0;
            });
        }
    };
} ]).directive("modalWindow", [ "$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {
            index: "@",
            animate: "="
        },
        replace: !0,
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowClass || ""), scope.size = attrs.size, $timeout(function() {
                scope.animate = !0, element[0].focus();
            }), scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" != modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            };
        }
    };
} ]).factory("$modalStack", [ "$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex;
    }
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0), modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
            modalWindow.modalScope.$destroy(), body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0), 
            checkRemoveBackdrop();
        });
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 == backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, 150, function() {
                backdropScopeRef.$destroy(), backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, emulateTime, done) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, domEl.remove(), done && done());
        }
        scope.animate = !1;
        var transitionEndEventName = $transition.transitionEndEventName;
        if (transitionEndEventName) {
            var timeout = $timeout(afterAnimating, emulateTime);
            domEl.bind(transitionEndEventName, function() {
                $timeout.cancel(timeout), afterAnimating(), scope.$apply();
            });
        } else $timeout(afterAnimating, 0);
    }
    var backdropDomEl, backdropScope, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), $modalStack = {};
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.bind("keydown", function(evt) {
        var modal;
        27 === evt.which && (modal = openedWindows.top(), modal && modal.value.keyboard && (evt.preventDefault(), 
        $rootScope.$apply(function() {
            $modalStack.dismiss(modal.key, "escape key press");
        })));
    }), $modalStack.open = function(modalInstance, modal) {
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard
        });
        var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex();
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.index = currBackdropIndex, backdropDomEl = $compile("<div modal-backdrop></div>")(backdropScope), 
        body.append(backdropDomEl));
        var angularDomEl = angular.element("<div modal-window></div>");
        angularDomEl.attr({
            "template-url": modal.windowTemplateUrl,
            "window-class": modal.windowClass,
            size: modal.size,
            index: openedWindows.length() - 1,
            animate: "animate"
        }).html(modal.content);
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl, body.append(modalDomEl), body.addClass(OPENED_MODAL_CLASS);
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.resolve(result), removeModalWindow(modalInstance));
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.reject(reason), removeModalWindow(modalInstance));
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal; ) this.dismiss(topModal.key, reason), 
        topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack;
} ]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $http.get(options.templateUrl, {
                    cache: $templateCache
                }).then(function(result) {
                    return result.data;
                });
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                return angular.forEach(resolves, function(value, key) {
                    (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)));
                }), promisesArr;
            }
            var $modal = {};
            return $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function(result) {
                        $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of template or templateUrl options is required.");
                var templateAndResolvePromise = $q.all([ getTemplatePromise(modalOptions) ].concat(getResolvePromises(modalOptions.resolve)));
                return templateAndResolvePromise.then(function(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss;
                    var ctrlInstance, ctrlLocals = {}, resolveIter = 1;
                    modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$modalInstance = modalInstance, 
                    angular.forEach(modalOptions.resolve, function(value, key) {
                        ctrlLocals[key] = tplAndVars[resolveIter++];
                    }), ctrlInstance = $controller(modalOptions.controller, ctrlLocals)), $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        size: modalOptions.size
                    });
                }, function(reason) {
                    modalResultDeferred.reject(reason);
                }), templateAndResolvePromise.then(function() {
                    modalOpenedDeferred.resolve(!0);
                }, function() {
                    modalOpenedDeferred.reject(!1);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.pagination", []).controller("PaginationController", [ "$scope", "$attrs", "$parse", function($scope, $attrs, $parse) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_, this.config = config, ngModelCtrl.$render = function() {
            self.render();
        }, $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10), $scope.totalPages = self.calculateTotalPages();
        }) : this.itemsPerPage = config.itemsPerPage;
    }, this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }, this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
    }, $scope.selectPage = function(page) {
        $scope.page !== page && page > 0 && page <= $scope.totalPages && (ngModelCtrl.$setViewValue(page), 
        ngModelCtrl.$render());
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || self.config[key + "Text"];
    }, $scope.noPrevious = function() {
        return 1 === $scope.page;
    }, $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
    }, $scope.$watch("totalItems", function() {
        $scope.totalPages = self.calculateTotalPages();
    }), $scope.$watch("totalPages", function(value) {
        setNumPages($scope.$parent, value), $scope.page > value ? $scope.selectPage(value) : ngModelCtrl.$render();
    });
} ]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0
}).directive("pagination", [ "$parse", "paginationConfig", function($parse, paginationConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@"
        },
        require: [ "pagination", "?ngModel" ],
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                };
            }
            function getPages(currentPage, totalPages) {
                var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
                isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
                endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
                startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
                endPage = Math.min(startPage + maxSize - 1, totalPages)));
                for (var number = startPage; endPage >= number; number++) {
                    var page = makePage(number, number, number === currentPage);
                    pages.push(page);
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", !1);
                        pages.unshift(previousPageSet);
                    }
                    if (totalPages > endPage) {
                        var nextPageSet = makePage(endPage + 1, "...", !1);
                        pages.push(nextPageSet);
                    }
                }
                return pages;
            }
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize, rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
                scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks, 
                scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks, 
                paginationCtrl.init(ngModelCtrl, paginationConfig), attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10), paginationCtrl.render();
                });
                var originalRender = paginationCtrl.render;
                paginationCtrl.render = function() {
                    originalRender(), scope.page > 0 && scope.page <= scope.totalPages && (scope.pages = getPages(scope.page, scope.totalPages));
                };
            }
        }
    };
} ]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("pager", [ "pagerConfig", function(pagerConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@"
        },
        require: [ "pager", "?ngModel" ],
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && (scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align, 
            paginationCtrl.init(ngModelCtrl, pagerConfig));
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).provider("$tooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        animation: !0,
        popupDelay: 0
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur"
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$parse", "$document", "$position", "$interpolate", function($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function(type, prefix, defaultTriggerShow) {
            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow, hide = triggerMap[show] || show;
                return {
                    show: show,
                    hide: hide
                };
            }
            var options = angular.extend({}, defaultOptions, globalOptions), directiveName = snake_case(type), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup title="' + startSym + "tt_title" + endSym + '" content="' + startSym + "tt_content" + endSym + '" placement="' + startSym + "tt_placement" + endSym + '" animation="tt_animation" is-open="tt_isOpen"></div>';
            return {
                restrict: "EA",
                scope: !0,
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        function toggleTooltipBind() {
                            scope.tt_isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (scope.tt_popupDelay ? popupTimeout || (popupTimeout = $timeout(show, scope.tt_popupDelay, !1), 
                            popupTimeout.then(function(reposition) {
                                reposition();
                            })) : show()());
                        }
                        function hideTooltipBind() {
                            scope.$apply(function() {
                                hide();
                            });
                        }
                        function show() {
                            return popupTimeout = null, transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null), scope.tt_content ? (createTooltip(), tooltip.css({
                                top: 0,
                                left: 0,
                                display: "block"
                            }), appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip), 
                            positionTooltip(), scope.tt_isOpen = !0, scope.$digest(), positionTooltip) : angular.noop;
                        }
                        function hide() {
                            scope.tt_isOpen = !1, $timeout.cancel(popupTimeout), popupTimeout = null, scope.tt_animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 500)) : removeTooltip();
                        }
                        function createTooltip() {
                            tooltip && removeTooltip(), tooltip = tooltipLinker(scope, function() {}), scope.$digest();
                        }
                        function removeTooltip() {
                            transitionTimeout = null, tooltip && (tooltip.remove(), tooltip = null);
                        }
                        var tooltip, transitionTimeout, popupTimeout, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), positionTooltip = function() {
                            var ttPosition = $position.positionElements(element, tooltip, scope.tt_placement, appendToBody);
                            ttPosition.top += "px", ttPosition.left += "px", tooltip.css(ttPosition);
                        };
                        scope.tt_isOpen = !1, attrs.$observe(type, function(val) {
                            scope.tt_content = val, !val && scope.tt_isOpen && hide();
                        }), attrs.$observe(prefix + "Title", function(val) {
                            scope.tt_title = val;
                        }), attrs.$observe(prefix + "Placement", function(val) {
                            scope.tt_placement = angular.isDefined(val) ? val : options.placement;
                        }), attrs.$observe(prefix + "PopupDelay", function(val) {
                            var delay = parseInt(val, 10);
                            scope.tt_popupDelay = isNaN(delay) ? options.popupDelay : delay;
                        });
                        var unregisterTriggers = function() {
                            element.unbind(triggers.show, showTooltipBind), element.unbind(triggers.hide, hideTooltipBind);
                        };
                        attrs.$observe(prefix + "Trigger", function(val) {
                            unregisterTriggers(), triggers = getTriggers(val), triggers.show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind), 
                            element.bind(triggers.hide, hideTooltipBind));
                        });
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation, 
                        attrs.$observe(prefix + "AppendToBody", function(val) {
                            appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                        }), appendToBody && scope.$on("$locationChangeSuccess", function() {
                            scope.tt_isOpen && hide();
                        }), scope.$on("$destroy", function() {
                            $timeout.cancel(transitionTimeout), $timeout.cancel(popupTimeout), unregisterTriggers(), 
                            removeTooltip();
                        });
                    };
                }
            };
        };
    } ];
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    };
}).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    };
}).directive("tooltipHtmlUnsafe", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter");
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    };
}).directive("popover", [ "$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", []).constant("progressConfig", {
    animate: !0,
    max: 100
}).controller("ProgressController", [ "$scope", "$attrs", "progressConfig", function($scope, $attrs, progressConfig) {
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max, 
    this.addBar = function(bar, element) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.$watch("value", function(value) {
            bar.percent = +(100 * value / $scope.max).toFixed(2);
        }), bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
} ]).directive("progress", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        templateUrl: "template/progressbar/progress.html"
    };
}).directive("bar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
}), angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", [ "$scope", "$attrs", "ratingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    }, this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; n > i; i++) states[i] = angular.extend({
            index: i
        }, {
            stateOn: this.stateOn,
            stateOff: this.stateOff
        }, states[i]);
        return states;
    }, $scope.rate = function(value) {
        !$scope.readonly && value >= 0 && value <= $scope.range.length && (ngModelCtrl.$setViewValue(value), 
        ngModelCtrl.$render());
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.onLeave();
    }, $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(), evt.stopPropagation(), 
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)));
    }, this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
    };
} ]).directive("rating", function() {
    return {
        restrict: "EA",
        require: [ "rating", "ngModel" ],
        scope: {
            readonly: "=?",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && ratingCtrl.init(ngModelCtrl);
        }
    };
}), angular.module("ui.bootstrap.tabs", []).controller("TabsetController", [ "$scope", function($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
            tab.active && tab !== selectedTab && (tab.active = !1, tab.onDeselect());
        }), selectedTab.active = !0, selectedTab.onSelect();
    }, ctrl.addTab = function(tab) {
        tabs.push(tab), 1 === tabs.length ? tab.active = !0 : tab.active && ctrl.select(tab);
    }, ctrl.removeTab = function(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
} ]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@"
        },
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1;
        }
    };
}).directive("tab", [ "$parse", function($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            active: "=?",
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
            return function(scope, elm, attrs, tabsetCtrl) {
                scope.$watch("active", function(active) {
                    active && tabsetCtrl.select(scope);
                }), scope.disabled = !1, attrs.disabled && scope.$parent.$watch($parse(attrs.disabled), function(value) {
                    scope.disabled = !!value;
                }), scope.select = function() {
                    scope.disabled || (scope.active = !0);
                }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                    tabsetCtrl.removeTab(scope);
                }), scope.$transcludeFn = transclude;
            };
        }
    };
} ]).directive("tabHeadingTransclude", [ function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
} ]).directive("tabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: !0,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0
}).controller("TimepickerController", [ "$scope", "$attrs", "$parse", "$log", "$locale", "timepickerConfig", function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10), valid = $scope.showMeridian ? hours > 0 && 13 > hours : hours >= 0 && 24 > hours;
        return valid ? ($scope.showMeridian && (12 === hours && (hours = 0), $scope.meridian === meridians[1] && (hours += 12)), 
        hours) : void 0;
    }
    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return minutes >= 0 && 60 > minutes ? minutes : void 0;
    }
    function pad(value) {
        return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value;
    }
    function refresh(keyboardChange) {
        makeValid(), ngModelCtrl.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
    }
    function makeValid() {
        ngModelCtrl.$setValidity("time", !0), $scope.invalidHours = !1, $scope.invalidMinutes = !1;
    }
    function updateTemplate(keyboardChange) {
        var hours = selected.getHours(), minutes = selected.getMinutes();
        $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), 
        $scope.hours = "h" === keyboardChange ? hours : pad(hours), $scope.minutes = "m" === keyboardChange ? minutes : pad(minutes), 
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
    function addMinutes(minutes) {
        var dt = new Date(selected.getTime() + 6e4 * minutes);
        selected.setHours(dt.getHours(), dt.getMinutes()), refresh();
    }
    var selected = new Date(), ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render;
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        mousewheel && this.setupMousewheelEvents(hoursInputEl, minutesInputEl), $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput, 
        this.setupInputEvents(hoursInputEl, minutesInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = parseInt(value, 10);
    });
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = parseInt(value, 10);
    }), $scope.showMeridian = timepickerConfig.showMeridian, $attrs.showMeridian && $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value, ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
            refresh());
        } else updateTemplate();
    }), this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()), 
            e.preventDefault();
        }), minutesInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()), 
            e.preventDefault();
        });
    }, this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) return $scope.updateHours = angular.noop, void ($scope.updateMinutes = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes) {
            ngModelCtrl.$setViewValue(null), ngModelCtrl.$setValidity("time", !1), angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours), 
            angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes);
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate();
            angular.isDefined(hours) ? (selected.setHours(hours), refresh("h")) : invalidate(!0);
        }, hoursInputEl.bind("blur", function(e) {
            !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours);
            });
        }), $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate();
            angular.isDefined(minutes) ? (selected.setMinutes(minutes), refresh("m")) : invalidate(void 0, !0);
        }, minutesInputEl.bind("blur", function(e) {
            !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes);
            });
        });
    }, this.render = function() {
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
        makeValid(), updateTemplate());
    }, $scope.incrementHours = function() {
        addMinutes(60 * hourStep);
    }, $scope.decrementHours = function() {
        addMinutes(60 * -hourStep);
    }, $scope.incrementMinutes = function() {
        addMinutes(minuteStep);
    }, $scope.decrementMinutes = function() {
        addMinutes(-minuteStep);
    }, $scope.toggleMeridian = function() {
        addMinutes(720 * (selected.getHours() < 12 ? 1 : -1));
    };
} ]).directive("timepicker", function() {
    return {
        restrict: "EA",
        require: [ "timepicker", "?^ngModel" ],
        controller: "TimepickerController",
        replace: !0,
        scope: {},
        templateUrl: "template/timepicker/timepicker.html",
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
}), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            var hasFocus, minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : !1, $setModelValue = $parse(attrs.ngModel).assign, parserResult = typeaheadParser.parse(attrs.typeahead), scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            element.attr({
                "aria-autocomplete": "list",
                "aria-expanded": !1,
                "aria-owns": popupId
            });
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                id: popupId,
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            var resetMatches = function() {
                scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1);
            }, getMatchId = function(index) {
                return popupId + "-option-" + index;
            };
            scope.$watch("activeIdx", function(index) {
                0 > index ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
            });
            var getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, !0), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus) if (matches.length > 0) {
                        scope.activeIdx = 0, scope.matches.length = 0;
                        for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                        scope.matches.push({
                            id: getMatchId(i),
                            label: parserResult.viewMapper(scope, locals),
                            model: matches[i]
                        });
                        scope.query = inputValue, scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                        scope.position.top = scope.position.top + element.prop("offsetHeight"), element.attr("aria-expanded", !0);
                    } else resetMatches();
                    onCurrentRequest && isLoadingSetter(originalScope, !1);
                }, function() {
                    resetMatches(), isLoadingSetter(originalScope, !1);
                });
            };
            resetMatches(), scope.query = void 0;
            var timeoutPromise;
            modelCtrl.$parsers.unshift(function(inputValue) {
                return hasFocus = !0, inputValue && inputValue.length >= minSearch ? waitTime > 0 ? (timeoutPromise && $timeout.cancel(timeoutPromise), 
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue);
                }, waitTime)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
                resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
                inputValue);
            }), modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue, locals = {};
                return inputFormatter ? (locals.$model = modelValue, inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
                candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
                emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
            }), scope.select = function(activeIdx) {
                var model, item, locals = {};
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model, model = parserResult.modelMapper(originalScope, locals), 
                $setModelValue(originalScope, model), modelCtrl.$setValidity("editable", !0), onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                }), resetMatches(), $timeout(function() {
                    element[0].focus();
                }, 0, !1);
            }, element.bind("keydown", function(evt) {
                0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which) && (evt.preventDefault(), 
                40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, 
                scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                    scope.select(scope.activeIdx);
                }) : 27 === evt.which && (evt.stopPropagation(), resetMatches(), scope.$digest()));
            }), element.bind("blur", function(evt) {
                hasFocus = !1;
            });
            var dismissClickHandler = function(evt) {
                element[0] !== evt.target && (resetMatches(), scope.$digest());
            };
            $document.bind("click", dismissClickHandler), originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
            });
            var $popup = $compile(popUpEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup);
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                return scope.matches.length > 0;
            }, scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("typeaheadMatch", [ "$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope));
            });
        }
    };
} ]).filter("typeaheadHighlight", function() {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    return function(matchItem, query) {
        return query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem;
    };
}), angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.transition", []).factory("$transition", [ "$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) if (void 0 !== transElement.style[name]) return endEventNames[name];
    }
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer(), endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"], transitionEndHandler = function(event) {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler), deferred.resolve(element);
            });
        };
        return endEventName && element.bind(endEventName, transitionEndHandler), $timeout(function() {
            angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger), 
            endEventName || deferred.resolve(element);
        }), deferred.promise.cancel = function() {
            endEventName && element.unbind(endEventName, transitionEndHandler), deferred.reject("Transition cancelled");
        }, deferred.promise;
    }, transElement = document.createElement("trans"), transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    }, animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    };
    return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames), 
    $transition.animationEndEventName = findEndEventName(animationEndEventNames), $transition;
} ]), angular.module("ui.bootstrap.collapse", [ "ui.bootstrap.transition" ]).directive("collapse", [ "$transition", function($transition) {
    return {
        link: function(scope, element, attrs) {
            function doTransition(change) {
                function newTransitionDone() {
                    currentTransition === newTransition && (currentTransition = void 0);
                }
                var newTransition = $transition(element, change);
                return currentTransition && currentTransition.cancel(), currentTransition = newTransition, 
                newTransition.then(newTransitionDone, newTransitionDone), newTransition;
            }
            function expand() {
                initialAnimSkip ? (initialAnimSkip = !1, expandDone()) : (element.removeClass("collapse").addClass("collapsing"), 
                doTransition({
                    height: element[0].scrollHeight + "px"
                }).then(expandDone));
            }
            function expandDone() {
                element.removeClass("collapsing"), element.addClass("collapse in"), element.css({
                    height: "auto"
                });
            }
            function collapse() {
                if (initialAnimSkip) initialAnimSkip = !1, collapseDone(), element.css({
                    height: 0
                }); else {
                    element.css({
                        height: element[0].scrollHeight + "px"
                    });
                    element[0].offsetWidth;
                    element.removeClass("collapse in").addClass("collapsing"), doTransition({
                        height: 0
                    }).then(collapseDone);
                }
            }
            function collapseDone() {
                element.removeClass("collapsing"), element.addClass("collapse");
            }
            var currentTransition, initialAnimSkip = !0;
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse" ]).constant("accordionConfig", {
    closeOthers: !0
}).controller("AccordionController", [ "$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        closeOthers && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1);
    };
} ]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: !0,
        replace: !1,
        templateUrl: "template/accordion/accordion.html"
    };
}).directive("accordionGroup", function() {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/accordion/accordion-group.html",
        scope: {
            heading: "@",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope), scope.$watch("isOpen", function(value) {
                value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function() {
                scope.isDisabled || (scope.isOpen = !scope.isOpen);
            };
        }
    };
}).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: !0,
        template: "",
        replace: !0,
        require: "^accordionGroup",
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, function() {}));
        }
    };
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                heading && (element.html(""), element.append(heading));
            });
        }
    };
}), angular.module("ui.bootstrap.alert", []).controller("AlertController", [ "$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = "close" in $attrs;
} ]).directive("alert", function() {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@",
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe), scope.$watch(attr.bindHtmlUnsafe, function(value) {
            element.html(value || "");
        });
    };
}), angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", [ "buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("btnRadio", function() {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                var isActive = element.hasClass(buttonsCtrl.activeClass);
                (!isActive || angular.isDefined(attrs.uncheckable)) && scope.$apply(function() {
                    ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio)), ngModelCtrl.$render();
                });
            });
        }
    };
}).directive("btnCheckbox", function() {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.carousel", [ "ui.bootstrap.transition" ]).controller("CarouselController", [ "$scope", "$timeout", "$transition", function($scope, $timeout, $transition) {
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval >= 0 && (currentTimeout = $timeout(timerFn, interval));
    }
    function resetTimer() {
        currentTimeout && ($timeout.cancel(currentTimeout), currentTimeout = null);
    }
    function timerFn() {
        isPlaying ? ($scope.next(), restartTimer()) : $scope.pause();
    }
    var currentTimeout, isPlaying, self = this, slides = self.slides = $scope.slides = [], currentIndex = -1;
    self.currentSlide = null;
    var destroyed = !1;
    self.select = $scope.select = function(nextSlide, direction) {
        function goNext() {
            if (!destroyed) {
                if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                    nextSlide.$element.addClass(direction);
                    nextSlide.$element[0].offsetWidth;
                    angular.forEach(slides, function(slide) {
                        angular.extend(slide, {
                            direction: "",
                            entering: !1,
                            leaving: !1,
                            active: !1
                        });
                    }), angular.extend(nextSlide, {
                        direction: direction,
                        active: !0,
                        entering: !0
                    }), angular.extend(self.currentSlide || {}, {
                        direction: direction,
                        leaving: !0
                    }), $scope.$currentTransition = $transition(nextSlide.$element, {}), function(next, current) {
                        $scope.$currentTransition.then(function() {
                            transitionDone(next, current);
                        }, function() {
                            transitionDone(next, current);
                        });
                    }(nextSlide, self.currentSlide);
                } else transitionDone(nextSlide, self.currentSlide);
                self.currentSlide = nextSlide, currentIndex = nextIndex, restartTimer();
            }
        }
        function transitionDone(next, current) {
            angular.extend(next, {
                direction: "",
                active: !0,
                leaving: !1,
                entering: !1
            }), angular.extend(current || {}, {
                direction: "",
                active: !1,
                leaving: !1,
                entering: !1
            }), $scope.$currentTransition = null;
        }
        var nextIndex = slides.indexOf(nextSlide);
        void 0 === direction && (direction = nextIndex > currentIndex ? "next" : "prev"), 
        nextSlide && nextSlide !== self.currentSlide && ($scope.$currentTransition ? ($scope.$currentTransition.cancel(), 
        $timeout(goNext)) : goNext());
    }, $scope.$on("$destroy", function() {
        destroyed = !0;
    }), self.indexOfSlide = function(slide) {
        return slides.indexOf(slide);
    }, $scope.next = function() {
        var newIndex = (currentIndex + 1) % slides.length;
        return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "next");
    }, $scope.prev = function() {
        var newIndex = 0 > currentIndex - 1 ? slides.length - 1 : currentIndex - 1;
        return $scope.$currentTransition ? void 0 : self.select(slides[newIndex], "prev");
    }, $scope.isActive = function(slide) {
        return self.currentSlide === slide;
    }, $scope.$watch("interval", restartTimer), $scope.$on("$destroy", resetTimer), 
    $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, self.addSlide = function(slide, element) {
        slide.$element = element, slides.push(slide), 1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]), 
        1 == slides.length && $scope.play()) : slide.active = !1;
    }, self.removeSlide = function(slide) {
        var index = slides.indexOf(slide);
        slides.splice(index, 1), slides.length > 0 && slide.active ? index >= slides.length ? self.select(slides[index - 1]) : self.select(slides[index]) : currentIndex > index && currentIndex--;
    };
} ]).directive("carousel", [ function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        controller: "CarouselController",
        require: "carousel",
        templateUrl: "template/carousel/carousel.html",
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "="
        }
    };
} ]).directive("slide", function() {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: "template/carousel/slide.html",
        scope: {
            active: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                active && carouselCtrl.select(scope);
            });
        }
    };
}), angular.module("ui.bootstrap.dateparser", []).service("dateParser", [ "$locale", "orderByFilter", function($locale, orderByFilter) {
    function isValid(year, month, date) {
        return 1 === month && date > 28 ? 29 === date && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) : 3 === month || 5 === month || 8 === month || 10 === month ? 31 > date : !0;
    }
    this.parsers = {};
    var formatCodeToRegex = {
        yyyy: {
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value;
            }
        },
        yy: {
            regex: "\\d{2}",
            apply: function(value) {
                this.year = +value + 2e3;
            }
        },
        y: {
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value;
            }
        },
        MMMM: {
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            }
        },
        MMM: {
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            }
        },
        MM: {
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            }
        },
        M: {
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            }
        },
        dd: {
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            }
        },
        d: {
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            }
        },
        EEEE: {
            regex: $locale.DATETIME_FORMATS.DAY.join("|")
        },
        EEE: {
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|")
        }
    };
    this.createParser = function(format) {
        var map = [], regex = format.split("");
        return angular.forEach(formatCodeToRegex, function(data, code) {
            var index = format.indexOf(code);
            if (index > -1) {
                format = format.split(""), regex[index] = "(" + data.regex + ")", format[index] = "$";
                for (var i = index + 1, n = index + code.length; n > i; i++) regex[i] = "", format[i] = "$";
                format = format.join(""), map.push({
                    index: index,
                    apply: data.apply
                });
            }
        }), {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }, this.parse = function(input, format) {
        if (!angular.isString(input)) return input;
        format = $locale.DATETIME_FORMATS[format] || format, this.parsers[format] || (this.parsers[format] = this.createParser(format));
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex);
        if (results && results.length) {
            for (var dt, fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0
            }, i = 1, n = results.length; n > i; i++) {
                var mapper = map[i - 1];
                mapper.apply && mapper.apply.call(fields, results[i]);
            }
            return isValid(fields.year, fields.month, fields.date) && (dt = new Date(fields.year, fields.month, fields.date, fields.hours)), 
            dt;
        }
    };
} ]), angular.module("ui.bootstrap.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop];
    }
    function isStaticPositioned(element) {
        return "static" === (getStyle(element, "position") || "static");
    }
    var parentOffsetEl = function(element) {
        for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
        return offsetParent || docDomEl;
    };
    return {
        position: function(element) {
            var elBCR = this.offset(element), offsetParentBCR = {
                top: 0,
                left: 0
            }, offsetParentEl = parentOffsetEl(element[0]);
            offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)), 
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
            var hostElPos, targetElWidth, targetElHeight, targetElPos, positionStrParts = positionStr.split("-"), pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center";
            hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl), targetElWidth = targetEl.prop("offsetWidth"), 
            targetElHeight = targetEl.prop("offsetHeight");
            var shiftWidth = {
                center: function() {
                    return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
                },
                left: function() {
                    return hostElPos.left;
                },
                right: function() {
                    return hostElPos.left + hostElPos.width;
                }
            }, shiftHeight = {
                center: function() {
                    return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
                },
                top: function() {
                    return hostElPos.top;
                },
                bottom: function() {
                    return hostElPos.top + hostElPos.height;
                }
            };
            switch (pos0) {
              case "right":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: shiftWidth[pos0]()
                };
                break;

              case "left":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: hostElPos.left - targetElWidth
                };
                break;

              case "bottom":
                targetElPos = {
                    top: shiftHeight[pos0](),
                    left: shiftWidth[pos1]()
                };
                break;

              default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[pos1]()
                };
            }
            return targetElPos;
        }
    };
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.position" ]).constant("datepickerConfig", {
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    datepickerMode: "day",
    minMode: "day",
    maxMode: "year",
    showWeeks: !0,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
}).controller("DatepickerController", [ "$scope", "$attrs", "$parse", "$interpolate", "$timeout", "$log", "dateFilter", "datepickerConfig", function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.modes = [ "day", "month", "year" ], angular.forEach([ "formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "minMode", "maxMode", "showWeeks", "startingDay", "yearRange" ], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? 8 > index ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
    }), angular.forEach([ "minDate", "maxDate" ], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null, self.refreshView();
        }) : self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }), $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode, 
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    this.activeDate = angular.isDefined($attrs.initDate) ? $scope.$parent.$eval($attrs.initDate) : new Date(), 
    $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) ? ($scope.activeDateId = dateObject.uid, 
        !0) : !1;
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$modelValue) {
            var date = new Date(ngModelCtrl.$modelValue), isValid = !isNaN(date);
            isValid ? this.activeDate = date : $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.'), 
            ngModelCtrl.$setValidity("date", isValid);
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            this._refreshView();
            var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
            ngModelCtrl.$setValidity("date-disabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            current: 0 === this.compare(date, new Date())
        };
    }, this.isDisabled = function(date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), ngModelCtrl.$setViewValue(dt), 
            ngModelCtrl.$render();
        } else self.activeDate = date, $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || ($scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        $timeout(function() {
            self.element[0].focus();
        }, 0, !1);
    };
    $scope.$on("datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey) if (evt.preventDefault(), evt.stopPropagation(), 
        "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate), focusElement();
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : ($scope.toggleMode("up" === key ? 1 : -1), focusElement());
    };
} ]).directive("datepicker", function() {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/datepicker.html",
        scope: {
            datepickerMode: "=?",
            dateDisabled: "&"
        },
        require: [ "datepicker", "?^ngModel" ],
        controller: "DatepickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("daypicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/day.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            function getDaysInMonth(year, month) {
                return 1 !== month || year % 4 !== 0 || year % 100 === 0 && year % 400 !== 0 ? DAYS_IN_MONTH[month] : 29;
            }
            function getDates(startDate, n) {
                var dates = new Array(n), current = new Date(startDate), i = 0;
                for (current.setHours(12); n > i; ) dates[i++] = new Date(current), current.setDate(current.getDate() + 1);
                return dates;
            }
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                var time = checkDate.getTime();
                return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
            }
            scope.showWeeks = ctrl.showWeeks, ctrl.step = {
                months: 1
            }, ctrl.element = element;
            var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
            ctrl._refreshView = function() {
                var year = ctrl.activeDate.getFullYear(), month = ctrl.activeDate.getMonth(), firstDayOfMonth = new Date(year, month, 1), difference = ctrl.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
                numDisplayedFromPreviousMonth > 0 && firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
                for (var days = getDates(firstDate, 42), i = 0; 42 > i; i++) days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
                    secondary: days[i].getMonth() !== month,
                    uid: scope.uniqueId + "-" + i
                });
                scope.labels = new Array(7);
                for (var j = 0; 7 > j; j++) scope.labels[j] = {
                    abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
                    full: dateFilter(days[j].date, "EEEE")
                };
                if (scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle), scope.rows = ctrl.split(days, 7), 
                scope.showWeeks) {
                    scope.weekNumbers = [];
                    for (var weekNumber = getISO8601WeekNumber(scope.rows[0][0].date), numWeeks = scope.rows.length; scope.weekNumbers.push(weekNumber++) < numWeeks; ) ;
                }
            }, ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            }, ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getDate();
                if ("left" === key) date -= 1; else if ("up" === key) date -= 7; else if ("right" === key) date += 1; else if ("down" === key) date += 7; else if ("pageup" === key || "pagedown" === key) {
                    var month = ctrl.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
                    ctrl.activeDate.setMonth(month, 1), date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
                } else "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()));
                ctrl.activeDate.setDate(date);
            }, ctrl.refreshView();
        }
    };
} ]).directive("monthpicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/month.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            ctrl.step = {
                years: 1
            }, ctrl.element = element, ctrl._refreshView = function() {
                for (var months = new Array(12), year = ctrl.activeDate.getFullYear(), i = 0; 12 > i; i++) months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
                    uid: scope.uniqueId + "-" + i
                });
                scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle), scope.rows = ctrl.split(months, 3);
            }, ctrl.compare = function(date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
            }, ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getMonth();
                if ("left" === key) date -= 1; else if ("up" === key) date -= 3; else if ("right" === key) date += 1; else if ("down" === key) date += 3; else if ("pageup" === key || "pagedown" === key) {
                    var year = ctrl.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
                    ctrl.activeDate.setFullYear(year);
                } else "home" === key ? date = 0 : "end" === key && (date = 11);
                ctrl.activeDate.setMonth(date);
            }, ctrl.refreshView();
        }
    };
} ]).directive("yearpicker", [ "dateFilter", function(dateFilter) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/datepicker/year.html",
        require: "^datepicker",
        link: function(scope, element, attrs, ctrl) {
            function getStartingYear(year) {
                return parseInt((year - 1) / range, 10) * range + 1;
            }
            var range = ctrl.yearRange;
            ctrl.step = {
                years: range
            }, ctrl.element = element, ctrl._refreshView = function() {
                for (var years = new Array(range), i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); range > i; i++) years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
                    uid: scope.uniqueId + "-" + i
                });
                scope.title = [ years[0].label, years[range - 1].label ].join(" - "), scope.rows = ctrl.split(years, 5);
            }, ctrl.compare = function(date1, date2) {
                return date1.getFullYear() - date2.getFullYear();
            }, ctrl.handleKeyDown = function(key, evt) {
                var date = ctrl.activeDate.getFullYear();
                "left" === key ? date -= 1 : "up" === key ? date -= 5 : "right" === key ? date += 1 : "down" === key ? date += 5 : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * ctrl.step.years : "home" === key ? date = getStartingYear(ctrl.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(ctrl.activeDate.getFullYear()) + range - 1), 
                ctrl.activeDate.setFullYear(date);
            }, ctrl.refreshView();
        }
    };
} ]).constant("datepickerPopupConfig", {
    datepickerPopup: "yyyy-MM-dd",
    currentText: "Today",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: !0,
    appendToBody: !1,
    showButtonBar: !0
}).directive("datepickerPopup", [ "$compile", "$parse", "$document", "$position", "dateFilter", "dateParser", "datepickerPopupConfig", function($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
    return {
        restrict: "EA",
        require: "ngModel",
        scope: {
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@",
            dateDisabled: "&"
        },
        link: function(scope, element, attrs, ngModel) {
            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function($1) {
                    return "-" + $1.toLowerCase();
                });
            }
            function parseDate(viewValue) {
                if (viewValue) {
                    if (angular.isDate(viewValue) && !isNaN(viewValue)) return ngModel.$setValidity("date", !0), 
                    viewValue;
                    if (angular.isString(viewValue)) {
                        var date = dateParser.parse(viewValue, dateFormat) || new Date(viewValue);
                        return isNaN(date) ? void ngModel.$setValidity("date", !1) : (ngModel.$setValidity("date", !0), 
                        date);
                    }
                    return void ngModel.$setValidity("date", !1);
                }
                return ngModel.$setValidity("date", !0), null;
            }
            var dateFormat, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
            scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
            scope.getText = function(key) {
                return scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
            }, attrs.$observe("datepickerPopup", function(value) {
                dateFormat = value || datepickerPopupConfig.datepickerPopup, ngModel.$render();
            });
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");
            popupEl.attr({
                "ng-model": "date",
                "ng-change": "dateSelection()"
            });
            var datepickerEl = angular.element(popupEl.children()[0]);
            attrs.datepickerOptions && angular.forEach(scope.$parent.$eval(attrs.datepickerOptions), function(value, option) {
                datepickerEl.attr(cameltoDash(option), value);
            }), angular.forEach([ "minDate", "maxDate" ], function(key) {
                attrs[key] && (scope.$parent.$watch($parse(attrs[key]), function(value) {
                    scope[key] = value;
                }), datepickerEl.attr(cameltoDash(key), key));
            }), attrs.dateDisabled && datepickerEl.attr("date-disabled", "dateDisabled({ date: date, mode: mode })"), 
            ngModel.$parsers.unshift(parseDate), scope.dateSelection = function(dt) {
                angular.isDefined(dt) && (scope.date = dt), ngModel.$setViewValue(scope.date), ngModel.$render(), 
                closeOnDateSelection && (scope.isOpen = !1, element[0].focus());
            }, element.bind("input change keyup", function() {
                scope.$apply(function() {
                    scope.date = ngModel.$modelValue;
                });
            }), ngModel.$render = function() {
                var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : "";
                element.val(date), scope.date = parseDate(ngModel.$modelValue);
            };
            var documentClickBind = function(event) {
                scope.isOpen && event.target !== element[0] && scope.$apply(function() {
                    scope.isOpen = !1;
                });
            }, keydown = function(evt, noApply) {
                scope.keydown(evt);
            };
            element.bind("keydown", keydown), scope.keydown = function(evt) {
                27 === evt.which ? (evt.preventDefault(), evt.stopPropagation(), scope.close()) : 40 !== evt.which || scope.isOpen || (scope.isOpen = !0);
            }, scope.$watch("isOpen", function(value) {
                value ? (scope.$broadcast("datepicker.focus"), scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                scope.position.top = scope.position.top + element.prop("offsetHeight"), $document.bind("click", documentClickBind)) : $document.unbind("click", documentClickBind);
            }), scope.select = function(date) {
                if ("today" === date) {
                    var today = new Date();
                    angular.isDate(ngModel.$modelValue) ? (date = new Date(ngModel.$modelValue), date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : date = new Date(today.setHours(0, 0, 0, 0));
                }
                scope.dateSelection(date);
            }, scope.close = function() {
                scope.isOpen = !1, element[0].focus();
            };
            var $popup = $compile(popupEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup), scope.$on("$destroy", function() {
                $popup.remove(), element.unbind("keydown", keydown), $document.unbind("click", documentClickBind);
            });
        }
    };
} ]).directive("datepickerPopupWrap", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        templateUrl: "template/datepicker/popup.html",
        link: function(scope, element, attrs) {
            element.bind("click", function(event) {
                event.preventDefault(), event.stopPropagation();
            });
        }
    };
}), angular.module("ui.bootstrap.dropdown", []).constant("dropdownConfig", {
    openClass: "open"
}).service("dropdownService", [ "$document", function($document) {
    var openScope = null;
    this.open = function(dropdownScope) {
        openScope || ($document.bind("click", closeDropdown), $document.bind("keydown", escapeKeyBind)), 
        openScope && openScope !== dropdownScope && (openScope.isOpen = !1), openScope = dropdownScope;
    }, this.close = function(dropdownScope) {
        openScope === dropdownScope && (openScope = null, $document.unbind("click", closeDropdown), 
        $document.unbind("keydown", escapeKeyBind));
    };
    var closeDropdown = function(evt) {
        evt && evt.isDefaultPrevented() || openScope.$apply(function() {
            openScope.isOpen = !1;
        });
    }, escapeKeyBind = function(evt) {
        27 === evt.which && (openScope.focusToggleElement(), closeDropdown());
    };
} ]).controller("DropdownController", [ "$scope", "$attrs", "$parse", "dropdownConfig", "dropdownService", "$animate", function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate) {
    var getIsOpen, self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop;
    this.init = function(element) {
        self.$element = element, $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        }));
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        $animate[isOpen ? "addClass" : "removeClass"](self.$element, openClass), isOpen ? (scope.focusToggleElement(), 
        dropdownService.open(scope)) : dropdownService.close(scope), setIsOpen($scope, isOpen), 
        angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
            open: !!isOpen
        });
    }), $scope.$on("$locationChangeSuccess", function() {
        scope.isOpen = !1;
    }), $scope.$on("$destroy", function() {
        scope.$destroy();
    });
} ]).directive("dropdown", function() {
    return {
        restrict: "CA",
        controller: "DropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init(element);
        }
    };
}).directive("dropdownToggle", function() {
    return {
        restrict: "CA",
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.bind("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.transition" ]).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key == stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key == stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}).directive("modalBackdrop", [ "$timeout", function($timeout) {
    return {
        restrict: "EA",
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        link: function(scope) {
            scope.animate = !1, $timeout(function() {
                scope.animate = !0;
            });
        }
    };
} ]).directive("modalWindow", [ "$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {
            index: "@",
            animate: "="
        },
        replace: !0,
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowClass || ""), scope.size = attrs.size, $timeout(function() {
                scope.animate = !0, element[0].focus();
            }), scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" != modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            };
        }
    };
} ]).factory("$modalStack", [ "$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex;
    }
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0), modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
            modalWindow.modalScope.$destroy(), body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0), 
            checkRemoveBackdrop();
        });
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 == backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, 150, function() {
                backdropScopeRef.$destroy(), backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, emulateTime, done) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, domEl.remove(), done && done());
        }
        scope.animate = !1;
        var transitionEndEventName = $transition.transitionEndEventName;
        if (transitionEndEventName) {
            var timeout = $timeout(afterAnimating, emulateTime);
            domEl.bind(transitionEndEventName, function() {
                $timeout.cancel(timeout), afterAnimating(), scope.$apply();
            });
        } else $timeout(afterAnimating, 0);
    }
    var backdropDomEl, backdropScope, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), $modalStack = {};
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.bind("keydown", function(evt) {
        var modal;
        27 === evt.which && (modal = openedWindows.top(), modal && modal.value.keyboard && (evt.preventDefault(), 
        $rootScope.$apply(function() {
            $modalStack.dismiss(modal.key, "escape key press");
        })));
    }), $modalStack.open = function(modalInstance, modal) {
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard
        });
        var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex();
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.index = currBackdropIndex, backdropDomEl = $compile("<div modal-backdrop></div>")(backdropScope), 
        body.append(backdropDomEl));
        var angularDomEl = angular.element("<div modal-window></div>");
        angularDomEl.attr({
            "template-url": modal.windowTemplateUrl,
            "window-class": modal.windowClass,
            size: modal.size,
            index: openedWindows.length() - 1,
            animate: "animate"
        }).html(modal.content);
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl, body.append(modalDomEl), body.addClass(OPENED_MODAL_CLASS);
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.resolve(result), removeModalWindow(modalInstance));
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        modalWindow && (modalWindow.deferred.reject(reason), removeModalWindow(modalInstance));
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal; ) this.dismiss(topModal.key, reason), 
        topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack;
} ]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $http.get(options.templateUrl, {
                    cache: $templateCache
                }).then(function(result) {
                    return result.data;
                });
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                return angular.forEach(resolves, function(value, key) {
                    (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)));
                }), promisesArr;
            }
            var $modal = {};
            return $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function(result) {
                        $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of template or templateUrl options is required.");
                var templateAndResolvePromise = $q.all([ getTemplatePromise(modalOptions) ].concat(getResolvePromises(modalOptions.resolve)));
                return templateAndResolvePromise.then(function(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss;
                    var ctrlInstance, ctrlLocals = {}, resolveIter = 1;
                    modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$modalInstance = modalInstance, 
                    angular.forEach(modalOptions.resolve, function(value, key) {
                        ctrlLocals[key] = tplAndVars[resolveIter++];
                    }), ctrlInstance = $controller(modalOptions.controller, ctrlLocals)), $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        size: modalOptions.size
                    });
                }, function(reason) {
                    modalResultDeferred.reject(reason);
                }), templateAndResolvePromise.then(function() {
                    modalOpenedDeferred.resolve(!0);
                }, function() {
                    modalOpenedDeferred.reject(!1);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.pagination", []).controller("PaginationController", [ "$scope", "$attrs", "$parse", function($scope, $attrs, $parse) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_, this.config = config, ngModelCtrl.$render = function() {
            self.render();
        }, $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10), $scope.totalPages = self.calculateTotalPages();
        }) : this.itemsPerPage = config.itemsPerPage;
    }, this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }, this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
    }, $scope.selectPage = function(page) {
        $scope.page !== page && page > 0 && page <= $scope.totalPages && (ngModelCtrl.$setViewValue(page), 
        ngModelCtrl.$render());
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || self.config[key + "Text"];
    }, $scope.noPrevious = function() {
        return 1 === $scope.page;
    }, $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
    }, $scope.$watch("totalItems", function() {
        $scope.totalPages = self.calculateTotalPages();
    }), $scope.$watch("totalPages", function(value) {
        setNumPages($scope.$parent, value), $scope.page > value ? $scope.selectPage(value) : ngModelCtrl.$render();
    });
} ]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0
}).directive("pagination", [ "$parse", "paginationConfig", function($parse, paginationConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@"
        },
        require: [ "pagination", "?ngModel" ],
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                };
            }
            function getPages(currentPage, totalPages) {
                var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
                isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
                endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
                startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
                endPage = Math.min(startPage + maxSize - 1, totalPages)));
                for (var number = startPage; endPage >= number; number++) {
                    var page = makePage(number, number, number === currentPage);
                    pages.push(page);
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", !1);
                        pages.unshift(previousPageSet);
                    }
                    if (totalPages > endPage) {
                        var nextPageSet = makePage(endPage + 1, "...", !1);
                        pages.push(nextPageSet);
                    }
                }
                return pages;
            }
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize, rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
                scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks, 
                scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks, 
                paginationCtrl.init(ngModelCtrl, paginationConfig), attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10), paginationCtrl.render();
                });
                var originalRender = paginationCtrl.render;
                paginationCtrl.render = function() {
                    originalRender(), scope.page > 0 && scope.page <= scope.totalPages && (scope.pages = getPages(scope.page, scope.totalPages));
                };
            }
        }
    };
} ]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("pager", [ "pagerConfig", function(pagerConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@"
        },
        require: [ "pager", "?ngModel" ],
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && (scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align, 
            paginationCtrl.init(ngModelCtrl, pagerConfig));
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).provider("$tooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        animation: !0,
        popupDelay: 0
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur"
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$parse", "$document", "$position", "$interpolate", function($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function(type, prefix, defaultTriggerShow) {
            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow, hide = triggerMap[show] || show;
                return {
                    show: show,
                    hide: hide
                };
            }
            var options = angular.extend({}, defaultOptions, globalOptions), directiveName = snake_case(type), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup title="' + startSym + "tt_title" + endSym + '" content="' + startSym + "tt_content" + endSym + '" placement="' + startSym + "tt_placement" + endSym + '" animation="tt_animation" is-open="tt_isOpen"></div>';
            return {
                restrict: "EA",
                scope: !0,
                compile: function(tElem, tAttrs) {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        function toggleTooltipBind() {
                            scope.tt_isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (scope.tt_popupDelay ? popupTimeout || (popupTimeout = $timeout(show, scope.tt_popupDelay, !1), 
                            popupTimeout.then(function(reposition) {
                                reposition();
                            })) : show()());
                        }
                        function hideTooltipBind() {
                            scope.$apply(function() {
                                hide();
                            });
                        }
                        function show() {
                            return popupTimeout = null, transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null), scope.tt_content ? (createTooltip(), tooltip.css({
                                top: 0,
                                left: 0,
                                display: "block"
                            }), appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip), 
                            positionTooltip(), scope.tt_isOpen = !0, scope.$digest(), positionTooltip) : angular.noop;
                        }
                        function hide() {
                            scope.tt_isOpen = !1, $timeout.cancel(popupTimeout), popupTimeout = null, scope.tt_animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 500)) : removeTooltip();
                        }
                        function createTooltip() {
                            tooltip && removeTooltip(), tooltip = tooltipLinker(scope, function() {}), scope.$digest();
                        }
                        function removeTooltip() {
                            transitionTimeout = null, tooltip && (tooltip.remove(), tooltip = null);
                        }
                        var tooltip, transitionTimeout, popupTimeout, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), positionTooltip = function() {
                            var ttPosition = $position.positionElements(element, tooltip, scope.tt_placement, appendToBody);
                            ttPosition.top += "px", ttPosition.left += "px", tooltip.css(ttPosition);
                        };
                        scope.tt_isOpen = !1, attrs.$observe(type, function(val) {
                            scope.tt_content = val, !val && scope.tt_isOpen && hide();
                        }), attrs.$observe(prefix + "Title", function(val) {
                            scope.tt_title = val;
                        }), attrs.$observe(prefix + "Placement", function(val) {
                            scope.tt_placement = angular.isDefined(val) ? val : options.placement;
                        }), attrs.$observe(prefix + "PopupDelay", function(val) {
                            var delay = parseInt(val, 10);
                            scope.tt_popupDelay = isNaN(delay) ? options.popupDelay : delay;
                        });
                        var unregisterTriggers = function() {
                            element.unbind(triggers.show, showTooltipBind), element.unbind(triggers.hide, hideTooltipBind);
                        };
                        attrs.$observe(prefix + "Trigger", function(val) {
                            unregisterTriggers(), triggers = getTriggers(val), triggers.show === triggers.hide ? element.bind(triggers.show, toggleTooltipBind) : (element.bind(triggers.show, showTooltipBind), 
                            element.bind(triggers.hide, hideTooltipBind));
                        });
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation, 
                        attrs.$observe(prefix + "AppendToBody", function(val) {
                            appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                        }), appendToBody && scope.$on("$locationChangeSuccess", function() {
                            scope.tt_isOpen && hide();
                        }), scope.$on("$destroy", function() {
                            $timeout.cancel(transitionTimeout), $timeout.cancel(popupTimeout), unregisterTriggers(), 
                            removeTooltip();
                        });
                    };
                }
            };
        };
    } ];
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    };
}).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    };
}).directive("tooltipHtmlUnsafe", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter");
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    };
}).directive("popover", [ "$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", []).constant("progressConfig", {
    animate: !0,
    max: 100
}).controller("ProgressController", [ "$scope", "$attrs", "progressConfig", function($scope, $attrs, progressConfig) {
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max, 
    this.addBar = function(bar, element) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.$watch("value", function(value) {
            bar.percent = +(100 * value / $scope.max).toFixed(2);
        }), bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
} ]).directive("progress", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        templateUrl: "template/progressbar/progress.html"
    };
}).directive("bar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
}), angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", [ "$scope", "$attrs", "ratingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    }, this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; n > i; i++) states[i] = angular.extend({
            index: i
        }, {
            stateOn: this.stateOn,
            stateOff: this.stateOff
        }, states[i]);
        return states;
    }, $scope.rate = function(value) {
        !$scope.readonly && value >= 0 && value <= $scope.range.length && (ngModelCtrl.$setViewValue(value), 
        ngModelCtrl.$render());
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.onLeave();
    }, $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(), evt.stopPropagation(), 
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)));
    }, this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
    };
} ]).directive("rating", function() {
    return {
        restrict: "EA",
        require: [ "rating", "ngModel" ],
        scope: {
            readonly: "=?",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && ratingCtrl.init(ngModelCtrl);
        }
    };
}), angular.module("ui.bootstrap.tabs", []).controller("TabsetController", [ "$scope", function($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
            tab.active && tab !== selectedTab && (tab.active = !1, tab.onDeselect());
        }), selectedTab.active = !0, selectedTab.onSelect();
    }, ctrl.addTab = function(tab) {
        tabs.push(tab), 1 === tabs.length ? tab.active = !0 : tab.active && ctrl.select(tab);
    }, ctrl.removeTab = function(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
} ]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@"
        },
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1;
        }
    };
}).directive("tab", [ "$parse", function($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            active: "=?",
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
            return function(scope, elm, attrs, tabsetCtrl) {
                scope.$watch("active", function(active) {
                    active && tabsetCtrl.select(scope);
                }), scope.disabled = !1, attrs.disabled && scope.$parent.$watch($parse(attrs.disabled), function(value) {
                    scope.disabled = !!value;
                }), scope.select = function() {
                    scope.disabled || (scope.active = !0);
                }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                    tabsetCtrl.removeTab(scope);
                }), scope.$transcludeFn = transclude;
            };
        }
    };
} ]).directive("tabHeadingTransclude", [ function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
} ]).directive("tabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: !0,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0
}).controller("TimepickerController", [ "$scope", "$attrs", "$parse", "$log", "$locale", "timepickerConfig", function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10), valid = $scope.showMeridian ? hours > 0 && 13 > hours : hours >= 0 && 24 > hours;
        return valid ? ($scope.showMeridian && (12 === hours && (hours = 0), $scope.meridian === meridians[1] && (hours += 12)), 
        hours) : void 0;
    }
    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return minutes >= 0 && 60 > minutes ? minutes : void 0;
    }
    function pad(value) {
        return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value;
    }
    function refresh(keyboardChange) {
        makeValid(), ngModelCtrl.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
    }
    function makeValid() {
        ngModelCtrl.$setValidity("time", !0), $scope.invalidHours = !1, $scope.invalidMinutes = !1;
    }
    function updateTemplate(keyboardChange) {
        var hours = selected.getHours(), minutes = selected.getMinutes();
        $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), 
        $scope.hours = "h" === keyboardChange ? hours : pad(hours), $scope.minutes = "m" === keyboardChange ? minutes : pad(minutes), 
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
    function addMinutes(minutes) {
        var dt = new Date(selected.getTime() + 6e4 * minutes);
        selected.setHours(dt.getHours(), dt.getMinutes()), refresh();
    }
    var selected = new Date(), ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render;
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        mousewheel && this.setupMousewheelEvents(hoursInputEl, minutesInputEl), $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput, 
        this.setupInputEvents(hoursInputEl, minutesInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = parseInt(value, 10);
    });
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = parseInt(value, 10);
    }), $scope.showMeridian = timepickerConfig.showMeridian, $attrs.showMeridian && $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value, ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
            refresh());
        } else updateTemplate();
    }), this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()), 
            e.preventDefault();
        }), minutesInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()), 
            e.preventDefault();
        });
    }, this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) return $scope.updateHours = angular.noop, void ($scope.updateMinutes = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes) {
            ngModelCtrl.$setViewValue(null), ngModelCtrl.$setValidity("time", !1), angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours), 
            angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes);
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate();
            angular.isDefined(hours) ? (selected.setHours(hours), refresh("h")) : invalidate(!0);
        }, hoursInputEl.bind("blur", function(e) {
            !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours);
            });
        }), $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate();
            angular.isDefined(minutes) ? (selected.setMinutes(minutes), refresh("m")) : invalidate(void 0, !0);
        }, minutesInputEl.bind("blur", function(e) {
            !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes);
            });
        });
    }, this.render = function() {
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : null;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
        makeValid(), updateTemplate());
    }, $scope.incrementHours = function() {
        addMinutes(60 * hourStep);
    }, $scope.decrementHours = function() {
        addMinutes(60 * -hourStep);
    }, $scope.incrementMinutes = function() {
        addMinutes(minuteStep);
    }, $scope.decrementMinutes = function() {
        addMinutes(-minuteStep);
    }, $scope.toggleMeridian = function() {
        addMinutes(720 * (selected.getHours() < 12 ? 1 : -1));
    };
} ]).directive("timepicker", function() {
    return {
        restrict: "EA",
        require: [ "timepicker", "?^ngModel" ],
        controller: "TimepickerController",
        replace: !0,
        scope: {},
        templateUrl: "template/timepicker/timepicker.html",
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
}), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            var hasFocus, minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : !1, $setModelValue = $parse(attrs.ngModel).assign, parserResult = typeaheadParser.parse(attrs.typeahead), scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            element.attr({
                "aria-autocomplete": "list",
                "aria-expanded": !1,
                "aria-owns": popupId
            });
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                id: popupId,
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            var resetMatches = function() {
                scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1);
            }, getMatchId = function(index) {
                return popupId + "-option-" + index;
            };
            scope.$watch("activeIdx", function(index) {
                0 > index ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
            });
            var getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, !0), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus) if (matches.length > 0) {
                        scope.activeIdx = 0, scope.matches.length = 0;
                        for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                        scope.matches.push({
                            id: getMatchId(i),
                            label: parserResult.viewMapper(scope, locals),
                            model: matches[i]
                        });
                        scope.query = inputValue, scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                        scope.position.top = scope.position.top + element.prop("offsetHeight"), element.attr("aria-expanded", !0);
                    } else resetMatches();
                    onCurrentRequest && isLoadingSetter(originalScope, !1);
                }, function() {
                    resetMatches(), isLoadingSetter(originalScope, !1);
                });
            };
            resetMatches(), scope.query = void 0;
            var timeoutPromise;
            modelCtrl.$parsers.unshift(function(inputValue) {
                return hasFocus = !0, inputValue && inputValue.length >= minSearch ? waitTime > 0 ? (timeoutPromise && $timeout.cancel(timeoutPromise), 
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue);
                }, waitTime)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
                resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
                inputValue);
            }), modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue, locals = {};
                return inputFormatter ? (locals.$model = modelValue, inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
                candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
                emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
            }), scope.select = function(activeIdx) {
                var model, item, locals = {};
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model, model = parserResult.modelMapper(originalScope, locals), 
                $setModelValue(originalScope, model), modelCtrl.$setValidity("editable", !0), onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                }), resetMatches(), $timeout(function() {
                    element[0].focus();
                }, 0, !1);
            }, element.bind("keydown", function(evt) {
                0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which) && (evt.preventDefault(), 
                40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, 
                scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                    scope.select(scope.activeIdx);
                }) : 27 === evt.which && (evt.stopPropagation(), resetMatches(), scope.$digest()));
            }), element.bind("blur", function(evt) {
                hasFocus = !1;
            });
            var dismissClickHandler = function(evt) {
                element[0] !== evt.target && (resetMatches(), scope.$digest());
            };
            $document.bind("click", dismissClickHandler), originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
            });
            var $popup = $compile(popUpEl)(scope);
            appendToBody ? $document.find("body").append($popup) : element.after($popup);
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                return scope.matches.length > 0;
            }, scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("typeaheadMatch", [ "$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope));
            });
        }
    };
} ]).filter("typeaheadHighlight", function() {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    return function(matchItem, query) {
        return query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem;
    };
}), angular.module("template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<div class="panel panel-default">\n  <div class="panel-heading">\n    <h4 class="panel-title">\n      <a class="accordion-toggle" ng-click="toggleOpen()" accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n    </h4>\n  </div>\n  <div class="panel-collapse" collapse="!isOpen">\n	  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>');
} ]), angular.module("template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>');
} ]), angular.module("template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", '<div class="alert" ng-class="{\'alert-{{type || \'warning\'}}\': true, \'alert-dismissable\': closeable}" role="alert">\n    <button ng-show="closeable" type="button" class="close" ng-click="close()">\n        <span aria-hidden="true">&times;</span>\n        <span class="sr-only">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n');
} ]), angular.module("template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n    <ol class="carousel-indicators" ng-show="slides.length > 1">\n        <li ng-repeat="slide in slides track by $index" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n    </ol>\n    <div class="carousel-inner" ng-transclude></div>\n    <a class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-left"></span></a>\n    <a class="right carousel-control" ng-click="next()" ng-show="slides.length > 1"><span class="glyphicon glyphicon-chevron-right"></span></a>\n</div>\n');
} ]), angular.module("template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/slide.html", "<div ng-class=\"{\n    'active': leaving || (active && !entering),\n    'prev': (next || active) && direction=='prev',\n    'next': (next || active) && direction=='next',\n    'right': direction=='prev',\n    'left': direction=='next'\n  }\" class=\"item text-center\" ng-transclude></div>\n");
} ]), angular.module("template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n  <daypicker ng-switch-when="day" tabindex="0"></daypicker>\n  <monthpicker ng-switch-when="month" tabindex="0"></monthpicker>\n  <yearpicker ng-switch-when="year" tabindex="0"></yearpicker>\n</div>');
} ]), angular.module("template/datepicker/day.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/day.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{5 + showWeeks}}"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-show="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in labels track by $index" class="text-center"><small aria-label="{{label.full}}">{{label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-show="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/datepicker/month.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/month.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/datepicker/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/popup.html", '<ul class="dropdown-menu" ng-style="{display: (isOpen && \'block\') || \'none\', top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)">\n	<li ng-transclude></li>\n	<li ng-if="showButtonBar" style="padding:10px 9px 2px">\n		<span class="btn-group">\n			<button type="button" class="btn btn-sm btn-info" ng-click="select(\'today\')">{{ getText(\'current\') }}</button>\n			<button type="button" class="btn btn-sm btn-danger" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n		</span>\n		<button type="button" class="btn btn-sm btn-success pull-right" ng-click="close()">{{ getText(\'close\') }}</button>\n	</li>\n</ul>\n');
} ]), angular.module("template/datepicker/year.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/year.html", '<table role="grid" aria-labelledby="{{uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="3"><button id="{{uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{dt.uid}}" aria-disabled="{{!!dt.disabled}}">\n        <button type="button" style="width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="{\'text-info\': dt.current}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/modal/backdrop.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="modal-backdrop fade"\n     ng-class="{in: animate}"\n     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n></div>\n');
} ]), angular.module("template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div tabindex="-1" role="dialog" class="modal fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n    <div class="modal-dialog" ng-class="{\'modal-sm\': size == \'sm\', \'modal-lg\': size == \'lg\'}"><div class="modal-content" ng-transclude></div></div>\n</div>');
} ]), angular.module("template/pagination/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n  <li ng-class="{disabled: noPrevious(), previous: align}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext(), next: align}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n</ul>');
} ]), angular.module("template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-if="boundaryLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(1)">{{getText(\'first\')}}</a></li>\n  <li ng-if="directionLinks" ng-class="{disabled: noPrevious()}"><a href ng-click="selectPage(page - 1)">{{getText(\'previous\')}}</a></li>\n  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active}"><a href ng-click="selectPage(page.number)">{{page.text}}</a></li>\n  <li ng-if="directionLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(page + 1)">{{getText(\'next\')}}</a></li>\n  <li ng-if="boundaryLinks" ng-class="{disabled: noNext()}"><a href ng-click="selectPage(totalPages)">{{getText(\'last\')}}</a></li>\n</ul>');
} ]), angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n</div>\n');
} ]), angular.module("template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n');
} ]), angular.module("template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: percent + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>');
} ]), angular.module("template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-transclude></div>');
} ]), angular.module("template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: percent + \'%\'}" aria-valuetext="{{percent | number:0}}%" ng-transclude></div>\n</div>');
} ]), angular.module("template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n    <i ng-repeat="r in range track by $index" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')">\n        <span class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    </i>\n</span>');
} ]), angular.module("template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n  <a ng-click="select()" tab-heading-transclude>{{heading}}</a>\n</li>\n');
} ]), angular.module("template/tabs/tabset-titles.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset-titles.html", "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n</ul>\n");
} ]), angular.module("template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", '\n<div>\n  <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", '<table>\n	<tbody>\n		<tr class="text-center">\n			<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n			<td>&nbsp;</td>\n			<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n			<td ng-show="showMeridian"></td>\n		</tr>\n		<tr>\n			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n				<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n			</td>\n			<td>:</td>\n			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n				<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n			</td>\n			<td ng-show="showMeridian"><button type="button" class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n		</tr>\n		<tr class="text-center">\n			<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n			<td>&nbsp;</td>\n			<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n			<td ng-show="showMeridian"></td>\n		</tr>\n	</tbody>\n</table>\n');
} ]), angular.module("template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>');
} ]), angular.module("template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-if="isOpen()" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)" role="option" id="{{match.id}}">\n        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>');
} ]), function() {
    var KEY = {
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        SPACE: 32,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        SHIFT: 16,
        CTRL: 17,
        ALT: 18,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        HOME: 36,
        END: 35,
        BACKSPACE: 8,
        DELETE: 46,
        COMMAND: 91,
        isControl: function(e) {
            var k = e.which;
            switch (k) {
              case KEY.COMMAND:
              case KEY.SHIFT:
              case KEY.CTRL:
              case KEY.ALT:
                return !0;
            }
            return e.metaKey ? !0 : !1;
        },
        isFunctionKey: function(k) {
            return k = k.which ? k.which : k, k >= 112 && 123 >= k;
        },
        isVerticalMovement: function(k) {
            return ~[ KEY.UP, KEY.DOWN ].indexOf(k);
        },
        isHorizontalMovement: function(k) {
            return ~[ KEY.LEFT, KEY.RIGHT, KEY.BACKSPACE, KEY.DELETE ].indexOf(k);
        }
    };
    void 0 === angular.element.prototype.querySelectorAll && (angular.element.prototype.querySelectorAll = function(selector) {
        return angular.element(this[0].querySelectorAll(selector));
    }), angular.module("ui.select", []).constant("uiSelectConfig", {
        theme: "bootstrap",
        searchEnabled: !0,
        placeholder: "",
        refreshDelay: 1e3
    }).service("uiSelectMinErr", function() {
        var minErr = angular.$$minErr("ui.select");
        return function() {
            var error = minErr.apply(this, arguments), message = error.message.replace(new RegExp("\nhttp://errors.angularjs.org/.*"), "");
            return new Error(message);
        };
    }).service("RepeatParser", [ "uiSelectMinErr", "$parse", function(uiSelectMinErr, $parse) {
        var self = this;
        self.parse = function(expression) {
            var match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?([\S]+?)\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
            if (!match) throw uiSelectMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
            return {
                itemName: match[2],
                source: $parse(match[3]),
                trackByExp: match[4],
                modelMapper: $parse(match[1] || match[2])
            };
        }, self.getGroupNgRepeatExpression = function() {
            return "$group in $select.groups";
        }, self.getNgRepeatExpression = function(itemName, source, trackByExp, grouped) {
            var expression = itemName + " in " + (grouped ? "$group.items" : source);
            return trackByExp && (expression += " track by " + trackByExp), expression;
        };
    } ]).controller("uiSelectCtrl", [ "$scope", "$element", "$timeout", "RepeatParser", "uiSelectMinErr", function($scope, $element, $timeout, RepeatParser, uiSelectMinErr) {
        function _resetSearchInput() {
            ctrl.resetSearchInput && (ctrl.search = EMPTY_SEARCH, ctrl.selected && ctrl.items.length && !ctrl.multiple && (ctrl.activeIndex = ctrl.items.indexOf(ctrl.selected)));
        }
        function _handleDropDownSelection(key) {
            var processed = !0;
            switch (key) {
              case KEY.DOWN:
                !ctrl.open && ctrl.multiple ? ctrl.activate(!1, !0) : ctrl.activeIndex < ctrl.items.length - 1 && ctrl.activeIndex++;
                break;

              case KEY.UP:
                !ctrl.open && ctrl.multiple ? ctrl.activate(!1, !0) : ctrl.activeIndex > 0 && ctrl.activeIndex--;
                break;

              case KEY.TAB:
                (!ctrl.multiple || ctrl.open) && ctrl.select(ctrl.items[ctrl.activeIndex], !0);
                break;

              case KEY.ENTER:
                ctrl.open ? ctrl.select(ctrl.items[ctrl.activeIndex]) : ctrl.activate(!1, !0);
                break;

              case KEY.ESC:
                ctrl.close();
                break;

              default:
                processed = !1;
            }
            return processed;
        }
        function _handleMatchSelection(key) {
            function getNewActiveMatchIndex() {
                switch (key) {
                  case KEY.LEFT:
                    return ~ctrl.activeMatchIndex ? prev : last;

                  case KEY.RIGHT:
                    return ~ctrl.activeMatchIndex && curr !== last ? next : (ctrl.activate(), !1);

                  case KEY.BACKSPACE:
                    return ~ctrl.activeMatchIndex ? (ctrl.removeChoice(curr), prev) : last;

                  case KEY.DELETE:
                    return ~ctrl.activeMatchIndex ? (ctrl.removeChoice(ctrl.activeMatchIndex), curr) : !1;
                }
            }
            var caretPosition = _getCaretPosition(_searchInput[0]), length = ctrl.selected.length, first = 0, last = length - 1, curr = ctrl.activeMatchIndex, next = ctrl.activeMatchIndex + 1, prev = ctrl.activeMatchIndex - 1, newIndex = curr;
            return caretPosition > 0 || ctrl.search.length && key == KEY.RIGHT ? !1 : (ctrl.close(), 
            newIndex = getNewActiveMatchIndex(), ctrl.selected.length && newIndex !== !1 ? ctrl.activeMatchIndex = Math.min(last, Math.max(first, newIndex)) : ctrl.activeMatchIndex = -1, 
            !0);
        }
        function _getCaretPosition(el) {
            return angular.isNumber(el.selectionStart) ? el.selectionStart : el.value.length;
        }
        function _ensureHighlightVisible() {
            var container = $element.querySelectorAll(".ui-select-choices-content"), choices = container.querySelectorAll(".ui-select-choices-row");
            if (choices.length < 1) throw uiSelectMinErr("choices", "Expected multiple .ui-select-choices-row but got '{0}'.", choices.length);
            var highlighted = choices[ctrl.activeIndex], posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop, height = container[0].offsetHeight;
            posY > height ? container[0].scrollTop += posY - height : posY < highlighted.clientHeight && (ctrl.isGrouped && 0 === ctrl.activeIndex ? container[0].scrollTop = 0 : container[0].scrollTop -= highlighted.clientHeight - posY);
        }
        var ctrl = this, EMPTY_SEARCH = "";
        ctrl.placeholder = void 0, ctrl.search = EMPTY_SEARCH, ctrl.activeIndex = 0, ctrl.activeMatchIndex = -1, 
        ctrl.items = [], ctrl.selected = void 0, ctrl.open = !1, ctrl.focus = !1, ctrl.focusser = void 0, 
        ctrl.disabled = void 0, ctrl.searchEnabled = void 0, ctrl.resetSearchInput = void 0, 
        ctrl.refreshDelay = void 0, ctrl.multiple = !1, ctrl.disableChoiceExpression = void 0, 
        ctrl.isEmpty = function() {
            return angular.isUndefined(ctrl.selected) || null === ctrl.selected || "" === ctrl.selected;
        };
        var _searchInput = $element.querySelectorAll("input.ui-select-search");
        if (1 !== _searchInput.length) throw uiSelectMinErr("searchInput", "Expected 1 input.ui-select-search but got '{0}'.", _searchInput.length);
        ctrl.activate = function(initSearchValue, avoidReset) {
            ctrl.disabled || ctrl.open || (avoidReset || _resetSearchInput(), ctrl.focusser.prop("disabled", !0), 
            ctrl.open = !0, ctrl.activeMatchIndex = -1, ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex, 
            $timeout(function() {
                ctrl.search = initSearchValue || ctrl.search, _searchInput[0].focus();
            }));
        }, ctrl.findGroupByName = function(name) {
            return ctrl.groups && ctrl.groups.filter(function(group) {
                return group.name === name;
            })[0];
        }, ctrl.parseRepeatAttr = function(repeatAttr, groupByExp) {
            function updateGroups(items) {
                ctrl.groups = [], angular.forEach(items, function(item) {
                    var groupFn = $scope.$eval(groupByExp), groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn], group = ctrl.findGroupByName(groupName);
                    group ? group.items.push(item) : ctrl.groups.push({
                        name: groupName,
                        items: [ item ]
                    });
                }), ctrl.items = [], ctrl.groups.forEach(function(group) {
                    ctrl.items = ctrl.items.concat(group.items);
                });
            }
            function setPlainItems(items) {
                ctrl.items = items;
            }
            var setItemsFn = groupByExp ? updateGroups : setPlainItems;
            ctrl.parserResult = RepeatParser.parse(repeatAttr), ctrl.isGrouped = !!groupByExp, 
            ctrl.itemProperty = ctrl.parserResult.itemName, $scope.$watchCollection(ctrl.parserResult.source, function(items) {
                if (void 0 === items || null === items) ctrl.items = []; else {
                    if (!angular.isArray(items)) throw uiSelectMinErr("items", "Expected an array but got '{0}'.", items);
                    if (ctrl.multiple) {
                        var filteredItems = items.filter(function(i) {
                            return ctrl.selected.indexOf(i) < 0;
                        });
                        setItemsFn(filteredItems);
                    } else setItemsFn(items);
                    ctrl.ngModel.$modelValue = null;
                }
            }), ctrl.multiple && $scope.$watchCollection("$select.selected", function(selectedItems) {
                var data = ctrl.parserResult.source($scope);
                if (selectedItems.length) {
                    var filteredItems = data.filter(function(i) {
                        return selectedItems.indexOf(i) < 0;
                    });
                    setItemsFn(filteredItems);
                } else setItemsFn(data);
                ctrl.sizeSearchInput();
            });
        };
        var _refreshDelayPromise;
        ctrl.refresh = function(refreshAttr) {
            void 0 !== refreshAttr && (_refreshDelayPromise && $timeout.cancel(_refreshDelayPromise), 
            _refreshDelayPromise = $timeout(function() {
                $scope.$eval(refreshAttr);
            }, ctrl.refreshDelay));
        }, ctrl.setActiveItem = function(item) {
            ctrl.activeIndex = ctrl.items.indexOf(item);
        }, ctrl.isActive = function(itemScope) {
            return ctrl.open && ctrl.items.indexOf(itemScope[ctrl.itemProperty]) === ctrl.activeIndex;
        }, ctrl.isDisabled = function(itemScope) {
            if (ctrl.open) {
                var item, itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]), isDisabled = !1;
                return itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression) && (item = ctrl.items[itemIndex], 
                isDisabled = !!itemScope.$eval(ctrl.disableChoiceExpression), item._uiSelectChoiceDisabled = isDisabled), 
                isDisabled;
            }
        }, ctrl.select = function(item, skipFocusser) {
            if (void 0 === item || !item._uiSelectChoiceDisabled) {
                var locals = {};
                locals[ctrl.parserResult.itemName] = item, ctrl.onSelectCallback($scope, {
                    $item: item,
                    $model: ctrl.parserResult.modelMapper($scope, locals)
                }), ctrl.multiple ? (ctrl.selected.push(item), ctrl.sizeSearchInput()) : ctrl.selected = item, 
                ctrl.close(skipFocusser);
            }
        }, ctrl.close = function(skipFocusser) {
            ctrl.open && (_resetSearchInput(), ctrl.open = !1, ctrl.multiple || $timeout(function() {
                ctrl.focusser.prop("disabled", !1), skipFocusser || ctrl.focusser[0].focus();
            }, 0, !1));
        }, ctrl.toggle = function(e) {
            ctrl.open ? ctrl.close() : ctrl.activate(), e.preventDefault(), e.stopPropagation();
        }, ctrl.removeChoice = function(index) {
            var removedChoice = ctrl.selected[index], locals = {};
            locals[ctrl.parserResult.itemName] = removedChoice, ctrl.selected.splice(index, 1), 
            ctrl.activeMatchIndex = -1, ctrl.sizeSearchInput(), ctrl.onRemoveCallback($scope, {
                $item: removedChoice,
                $model: ctrl.parserResult.modelMapper($scope, locals)
            });
        }, ctrl.getPlaceholder = function() {
            return ctrl.multiple && ctrl.selected.length ? void 0 : ctrl.placeholder;
        };
        var containerSizeWatch;
        ctrl.sizeSearchInput = function() {
            var input = _searchInput[0], container = _searchInput.parent().parent()[0];
            _searchInput.css("width", "10px");
            var calculate = function() {
                var newWidth = container.clientWidth - input.offsetLeft - 10;
                50 > newWidth && (newWidth = container.clientWidth), _searchInput.css("width", newWidth + "px");
            };
            $timeout(function() {
                0 !== container.clientWidth || containerSizeWatch ? containerSizeWatch || calculate() : containerSizeWatch = $scope.$watch(function() {
                    return container.clientWidth;
                }, function(newValue) {
                    0 !== newValue && (calculate(), containerSizeWatch(), containerSizeWatch = null);
                });
            }, 0, !1);
        }, _searchInput.on("keydown", function(e) {
            var key = e.which;
            $scope.$apply(function() {
                var processed = !1;
                ctrl.multiple && KEY.isHorizontalMovement(key) && (processed = _handleMatchSelection(key)), 
                !processed && ctrl.items.length > 0 && (processed = _handleDropDownSelection(key)), 
                processed && key != KEY.TAB && (e.preventDefault(), e.stopPropagation());
            }), KEY.isVerticalMovement(key) && ctrl.items.length > 0 && _ensureHighlightVisible();
        }), _searchInput.on("blur", function() {
            $timeout(function() {
                ctrl.activeMatchIndex = -1;
            });
        }), $scope.$on("$destroy", function() {
            _searchInput.off("keydown blur");
        });
    } ]).directive("uiSelect", [ "$document", "uiSelectConfig", "uiSelectMinErr", "$compile", "$parse", function($document, uiSelectConfig, uiSelectMinErr, $compile, $parse) {
        return {
            restrict: "EA",
            templateUrl: function(tElement, tAttrs) {
                var theme = tAttrs.theme || uiSelectConfig.theme;
                return theme + (angular.isDefined(tAttrs.multiple) ? "/select-multiple.tpl.html" : "/select.tpl.html");
            },
            replace: !0,
            transclude: !0,
            require: [ "uiSelect", "ngModel" ],
            scope: !0,
            controller: "uiSelectCtrl",
            controllerAs: "$select",
            link: function(scope, element, attrs, ctrls, transcludeFn) {
                function onDocumentClick(e) {
                    var contains = !1;
                    contains = window.jQuery ? window.jQuery.contains(element[0], e.target) : element[0].contains(e.target), 
                    contains || ($select.close(), scope.$digest());
                }
                var $select = ctrls[0], ngModel = ctrls[1], searchInput = element.querySelectorAll("input.ui-select-search");
                $select.multiple = angular.isDefined(attrs.multiple) ? "" === attrs.multiple ? !0 : "true" === attrs.multiple.toLowerCase() : !1, 
                $select.onSelectCallback = $parse(attrs.onSelect), $select.onRemoveCallback = $parse(attrs.onRemove), 
                ngModel.$parsers.unshift(function(inputValue) {
                    var result, locals = {};
                    if ($select.multiple) {
                        for (var resultMultiple = [], j = $select.selected.length - 1; j >= 0; j--) locals = {}, 
                        locals[$select.parserResult.itemName] = $select.selected[j], result = $select.parserResult.modelMapper(scope, locals), 
                        resultMultiple.unshift(result);
                        return resultMultiple;
                    }
                    return locals = {}, locals[$select.parserResult.itemName] = inputValue, result = $select.parserResult.modelMapper(scope, locals);
                }), ngModel.$formatters.unshift(function(inputValue) {
                    var result, data = $select.parserResult.source(scope, {
                        $select: {
                            search: ""
                        }
                    }), locals = {};
                    if (data) {
                        if ($select.multiple) {
                            var resultMultiple = [], checkFnMultiple = function(list, value) {
                                if (list && list.length) {
                                    for (var p = list.length - 1; p >= 0; p--) if (locals[$select.parserResult.itemName] = list[p], 
                                    result = $select.parserResult.modelMapper(scope, locals), result == value) return resultMultiple.unshift(list[p]), 
                                    !0;
                                    return !1;
                                }
                            };
                            if (!inputValue) return resultMultiple;
                            for (var k = inputValue.length - 1; k >= 0; k--) checkFnMultiple($select.selected, inputValue[k]) || checkFnMultiple(data, inputValue[k]);
                            return resultMultiple;
                        }
                        var checkFnSingle = function(d) {
                            return locals[$select.parserResult.itemName] = d, result = $select.parserResult.modelMapper(scope, locals), 
                            result == inputValue;
                        };
                        if ($select.selected && checkFnSingle($select.selected)) return $select.selected;
                        for (var i = data.length - 1; i >= 0; i--) if (checkFnSingle(data[i])) return data[i];
                    }
                    return inputValue;
                }), $select.ngModel = ngModel;
                var focusser = angular.element("<input ng-disabled='$select.disabled' class='ui-select-focusser ui-select-offscreen' type='text' aria-haspopup='true' role='button' />");
                attrs.tabindex && attrs.$observe("tabindex", function(value) {
                    $select.multiple ? searchInput.attr("tabindex", value) : focusser.attr("tabindex", value), 
                    element.removeAttr("tabindex");
                }), $compile(focusser)(scope), $select.focusser = focusser, $select.multiple || (element.append(focusser), 
                focusser.bind("focus", function() {
                    scope.$evalAsync(function() {
                        $select.focus = !0;
                    });
                }), focusser.bind("blur", function() {
                    scope.$evalAsync(function() {
                        $select.focus = !1;
                    });
                }), focusser.bind("keydown", function(e) {
                    return e.which === KEY.BACKSPACE ? (e.preventDefault(), e.stopPropagation(), $select.select(void 0), 
                    void scope.$apply()) : void (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || ((e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE) && (e.preventDefault(), 
                    e.stopPropagation(), $select.activate()), scope.$digest()));
                }), focusser.bind("keyup input", function(e) {
                    e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE || ($select.activate(focusser.val()), 
                    focusser.val(""), scope.$digest());
                })), scope.$watch("searchEnabled", function() {
                    var searchEnabled = scope.$eval(attrs.searchEnabled);
                    $select.searchEnabled = void 0 !== searchEnabled ? searchEnabled : !0;
                }), attrs.$observe("disabled", function() {
                    $select.disabled = void 0 !== attrs.disabled ? attrs.disabled : !1;
                }), attrs.$observe("resetSearchInput", function() {
                    var resetSearchInput = scope.$eval(attrs.resetSearchInput);
                    $select.resetSearchInput = void 0 !== resetSearchInput ? resetSearchInput : !0;
                }), $select.multiple ? (scope.$watchCollection(function() {
                    return ngModel.$modelValue;
                }, function(newValue, oldValue) {
                    oldValue != newValue && (ngModel.$modelValue = null);
                }), scope.$watchCollection("$select.selected", function() {
                    ngModel.$setViewValue(Date.now());
                }), focusser.prop("disabled", !0)) : scope.$watch("$select.selected", function(newValue) {
                    ngModel.$viewValue !== newValue && ngModel.$setViewValue(newValue);
                }), ngModel.$render = function() {
                    if ($select.multiple && !angular.isArray(ngModel.$viewValue)) {
                        if (!angular.isUndefined(ngModel.$viewValue) && null !== ngModel.$viewValue) throw uiSelectMinErr("multiarr", "Expected model value to be array but got '{0}'", ngModel.$viewValue);
                        $select.selected = [];
                    }
                    $select.selected = ngModel.$viewValue;
                }, $document.on("click", onDocumentClick), scope.$on("$destroy", function() {
                    $document.off("click", onDocumentClick);
                }), transcludeFn(scope, function(clone) {
                    var transcluded = angular.element("<div>").append(clone), transcludedMatch = transcluded.querySelectorAll(".ui-select-match");
                    if (transcludedMatch.removeAttr("ui-select-match"), 1 !== transcludedMatch.length) throw uiSelectMinErr("transcluded", "Expected 1 .ui-select-match but got '{0}'.", transcludedMatch.length);
                    element.querySelectorAll(".ui-select-match").replaceWith(transcludedMatch);
                    var transcludedChoices = transcluded.querySelectorAll(".ui-select-choices");
                    if (transcludedChoices.removeAttr("ui-select-choices"), 1 !== transcludedChoices.length) throw uiSelectMinErr("transcluded", "Expected 1 .ui-select-choices but got '{0}'.", transcludedChoices.length);
                    element.querySelectorAll(".ui-select-choices").replaceWith(transcludedChoices);
                });
            }
        };
    } ]).directive("uiSelectChoices", [ "uiSelectConfig", "RepeatParser", "uiSelectMinErr", "$compile", function(uiSelectConfig, RepeatParser, uiSelectMinErr, $compile) {
        return {
            restrict: "EA",
            require: "^uiSelect",
            replace: !0,
            transclude: !0,
            templateUrl: function(tElement) {
                var theme = tElement.parent().attr("theme") || uiSelectConfig.theme;
                return theme + "/choices.tpl.html";
            },
            compile: function(tElement, tAttrs) {
                if (!tAttrs.repeat) throw uiSelectMinErr("repeat", "Expected 'repeat' expression.");
                return function(scope, element, attrs, $select, transcludeFn) {
                    var groupByExp = attrs.groupBy;
                    if ($select.parseRepeatAttr(attrs.repeat, groupByExp), $select.disableChoiceExpression = attrs.uiDisableChoice, 
                    groupByExp) {
                        var groups = element.querySelectorAll(".ui-select-choices-group");
                        if (1 !== groups.length) throw uiSelectMinErr("rows", "Expected 1 .ui-select-choices-group but got '{0}'.", groups.length);
                        groups.attr("ng-repeat", RepeatParser.getGroupNgRepeatExpression());
                    }
                    var choices = element.querySelectorAll(".ui-select-choices-row");
                    if (1 !== choices.length) throw uiSelectMinErr("rows", "Expected 1 .ui-select-choices-row but got '{0}'.", choices.length);
                    choices.attr("ng-repeat", RepeatParser.getNgRepeatExpression($select.parserResult.itemName, "$select.items", $select.parserResult.trackByExp, groupByExp)).attr("ng-mouseenter", "$select.setActiveItem(" + $select.parserResult.itemName + ")").attr("ng-click", "$select.select(" + $select.parserResult.itemName + ")");
                    var rowsInner = element.querySelectorAll(".ui-select-choices-row-inner");
                    if (1 !== rowsInner.length) throw uiSelectMinErr("rows", "Expected 1 .ui-select-choices-row-inner but got '{0}'.", rowsInner.length);
                    rowsInner.attr("uis-transclude-append", ""), $compile(element, transcludeFn)(scope), 
                    scope.$watch("$select.search", function(newValue) {
                        newValue && !$select.open && $select.multiple && $select.activate(!1, !0), $select.activeIndex = 0, 
                        $select.refresh(attrs.refresh);
                    }), attrs.$observe("refreshDelay", function() {
                        var refreshDelay = scope.$eval(attrs.refreshDelay);
                        $select.refreshDelay = void 0 !== refreshDelay ? refreshDelay : uiSelectConfig.refreshDelay;
                    });
                };
            }
        };
    } ]).directive("uisTranscludeAppend", function() {
        return {
            link: function(scope, element, attrs, ctrl, transclude) {
                transclude(scope, function(clone) {
                    element.append(clone);
                });
            }
        };
    }).directive("uiSelectMatch", [ "uiSelectConfig", function(uiSelectConfig) {
        return {
            restrict: "EA",
            require: "^uiSelect",
            replace: !0,
            transclude: !0,
            templateUrl: function(tElement) {
                var theme = tElement.parent().attr("theme") || uiSelectConfig.theme, multi = tElement.parent().attr("multiple");
                return theme + (multi ? "/match-multiple.tpl.html" : "/match.tpl.html");
            },
            link: function(scope, element, attrs, $select) {
                attrs.$observe("placeholder", function(placeholder) {
                    $select.placeholder = void 0 !== placeholder ? placeholder : uiSelectConfig.placeholder;
                }), $select.multiple && $select.sizeSearchInput();
            }
        };
    } ]).filter("highlight", function() {
        function escapeRegexp(queryToEscape) {
            return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
        }
        return function(matchItem, query) {
            return query && matchItem ? matchItem.replace(new RegExp(escapeRegexp(query), "gi"), '<span class="ui-select-highlight">$&</span>') : matchItem;
        };
    });
}(), angular.module("ui.select").run([ "$templateCache", function($templateCache) {
    $templateCache.put("bootstrap/choices.tpl.html", '<ul class="ui-select-choices ui-select-choices-content dropdown-menu" role="menu" aria-labelledby="dLabel" ng-show="$select.items.length > 0"><li class="ui-select-choices-group"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header">{{$group.name}}</div><div class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><a href="javascript:void(0)" class="ui-select-choices-row-inner"></a></div></li></ul>'), 
    $templateCache.put("bootstrap/match-multiple.tpl.html", '<span class="ui-select-match"><span ng-repeat="$item in $select.selected"><span style="margin-right: 3px;" class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$select.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$select.activeMatchIndex === $index}"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$select.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>'), 
    $templateCache.put("bootstrap/match.tpl.html", '<button type="button" class="btn btn-default form-control ui-select-match" tabindex="-1" ng-hide="$select.open" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}" ;="" ng-click="$select.activate()"><span ng-show="$select.searchEnabled && $select.isEmpty()" class="text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" ng-transclude=""></span> <span class="caret ui-select-toggle" ng-click="$select.toggle($event)"></span></button>'), 
    $templateCache.put("bootstrap/select-multiple.tpl.html", '<div class="ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$select.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-click="$select.activate()" ng-model="$select.search"></div><div class="ui-select-choices"></div></div>'), 
    $templateCache.put("bootstrap/select.tpl.html", '<div class="ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><input type="text" autocomplete="off" tabindex="-1" class="form-control ui-select-search" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.searchEnabled && $select.open"><div class="ui-select-choices"></div></div>'), 
    $templateCache.put("select2/choices.tpl.html", '<ul class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.isGrouped}"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label select2-result-label">{{$group.name}}</div><ul ng-class="{\'select2-result-sub\': $select.isGrouped, \'select2-result-single\': !$select.isGrouped}"><li class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>'), 
    $templateCache.put("select2/match-multiple.tpl.html", '<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected" ng-class="{\'select2-search-choice-focus\':$select.activeMatchIndex === $index}"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$select.removeChoice($index)" tabindex="-1"></a></li></span>'), 
    $templateCache.put("select2/match.tpl.html", '<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.activate()"><span ng-show="$select.searchEnabled && $select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <span class="select2-arrow ui-select-toggle" ng-click="$select.toggle($event)"><b></b></span></a>'), 
    $templateCache.put("select2/select-multiple.tpl.html", '<div class="ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open\': $select.open,\n                \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="select2-input ui-select-search" placeholder="{{$select.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;"></li></ul><div class="select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="ui-select-choices"></div></div></div>'), 
    $templateCache.put("select2/select.tpl.html", '<div class="select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open\': $select.open,\n                \'select2-container-disabled\': $select.disabled,\n                \'select2-container-active\': $select.focus }"><div class="ui-select-match"></div><div class="select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="select2-search" ng-show="$select.searchEnabled"><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div></div></div>'), 
    $templateCache.put("selectize/choices.tpl.html", '<div ng-show="$select.open" class="ui-select-choices selectize-dropdown single"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header">{{$group.name}}</div><div class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>'), 
    $templateCache.put("selectize/match.tpl.html", '<div ng-hide="$select.searchEnabled && ($select.open || $select.isEmpty())" class="ui-select-match" ng-transclude=""></div>'), 
    $templateCache.put("selectize/select.tpl.html", '<div class="selectize-control single"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.activate()"><div class="ui-select-match"></div><input type="text" autocomplete="off" tabindex="-1" class="ui-select-search ui-select-toggle" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.searchEnabled || ($select.selected && !$select.open)" ng-disabled="$select.disabled"></div><div class="ui-select-choices"></div></div>');
} ]);

var qrcode = function() {
    function qrPolynomial(num, shift) {
        if ("undefined" == typeof num.length) throw new Error(num.length + "/" + shift);
        var _num = function() {
            for (var offset = 0; offset < num.length && 0 == num[offset]; ) offset += 1;
            for (var _num = new Array(num.length - offset + shift), i = 0; i < num.length - offset; i += 1) _num[i] = num[i + offset];
            return _num;
        }(), _this = {};
        return _this.getAt = function(index) {
            return _num[index];
        }, _this.getLength = function() {
            return _num.length;
        }, _this.multiply = function(e) {
            for (var num = new Array(_this.getLength() + e.getLength() - 1), i = 0; i < _this.getLength(); i += 1) for (var j = 0; j < e.getLength(); j += 1) num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i)) + QRMath.glog(e.getAt(j)));
            return qrPolynomial(num, 0);
        }, _this.mod = function(e) {
            if (_this.getLength() - e.getLength() < 0) return _this;
            for (var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e.getAt(0)), num = new Array(_this.getLength()), i = 0; i < _this.getLength(); i += 1) num[i] = _this.getAt(i);
            for (var i = 0; i < e.getLength(); i += 1) num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i)) + ratio);
            return qrPolynomial(num, 0).mod(e);
        }, _this;
    }
    var qrcode = function(typeNumber, errorCorrectLevel) {
        var PAD0 = 236, PAD1 = 17, _typeNumber = typeNumber, _errorCorrectLevel = QRErrorCorrectLevel[errorCorrectLevel], _modules = null, _moduleCount = 0, _dataCache = null, _dataList = new Array(), _this = {}, makeImpl = function(test, maskPattern) {
            _moduleCount = 4 * _typeNumber + 17, _modules = function(moduleCount) {
                for (var modules = new Array(moduleCount), row = 0; moduleCount > row; row += 1) {
                    modules[row] = new Array(moduleCount);
                    for (var col = 0; moduleCount > col; col += 1) modules[row][col] = null;
                }
                return modules;
            }(_moduleCount), setupPositionProbePattern(0, 0), setupPositionProbePattern(_moduleCount - 7, 0), 
            setupPositionProbePattern(0, _moduleCount - 7), setupPositionAdjustPattern(), setupTimingPattern(), 
            setupTypeInfo(test, maskPattern), _typeNumber >= 7 && setupTypeNumber(test), null == _dataCache && (_dataCache = createData(_typeNumber, _errorCorrectLevel, _dataList)), 
            mapData(_dataCache, maskPattern);
        }, setupPositionProbePattern = function(row, col) {
            for (var r = -1; 7 >= r; r += 1) if (!(-1 >= row + r || row + r >= _moduleCount)) for (var c = -1; 7 >= c; c += 1) -1 >= col + c || col + c >= _moduleCount || (r >= 0 && 6 >= r && (0 == c || 6 == c) || c >= 0 && 6 >= c && (0 == r || 6 == r) || r >= 2 && 4 >= r && c >= 2 && 4 >= c ? _modules[row + r][col + c] = !0 : _modules[row + r][col + c] = !1);
        }, getBestMaskPattern = function() {
            for (var minLostPoint = 0, pattern = 0, i = 0; 8 > i; i += 1) {
                makeImpl(!0, i);
                var lostPoint = QRUtil.getLostPoint(_this);
                (0 == i || minLostPoint > lostPoint) && (minLostPoint = lostPoint, pattern = i);
            }
            return pattern;
        }, setupTimingPattern = function() {
            for (var r = 8; _moduleCount - 8 > r; r += 1) null == _modules[r][6] && (_modules[r][6] = r % 2 == 0);
            for (var c = 8; _moduleCount - 8 > c; c += 1) null == _modules[6][c] && (_modules[6][c] = c % 2 == 0);
        }, setupPositionAdjustPattern = function() {
            for (var pos = QRUtil.getPatternPosition(_typeNumber), i = 0; i < pos.length; i += 1) for (var j = 0; j < pos.length; j += 1) {
                var row = pos[i], col = pos[j];
                if (null == _modules[row][col]) for (var r = -2; 2 >= r; r += 1) for (var c = -2; 2 >= c; c += 1) -2 == r || 2 == r || -2 == c || 2 == c || 0 == r && 0 == c ? _modules[row + r][col + c] = !0 : _modules[row + r][col + c] = !1;
            }
        }, setupTypeNumber = function(test) {
            for (var bits = QRUtil.getBCHTypeNumber(_typeNumber), i = 0; 18 > i; i += 1) {
                var mod = !test && 1 == (bits >> i & 1);
                _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
            }
            for (var i = 0; 18 > i; i += 1) {
                var mod = !test && 1 == (bits >> i & 1);
                _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
            }
        }, setupTypeInfo = function(test, maskPattern) {
            for (var data = _errorCorrectLevel << 3 | maskPattern, bits = QRUtil.getBCHTypeInfo(data), i = 0; 15 > i; i += 1) {
                var mod = !test && 1 == (bits >> i & 1);
                6 > i ? _modules[i][8] = mod : 8 > i ? _modules[i + 1][8] = mod : _modules[_moduleCount - 15 + i][8] = mod;
            }
            for (var i = 0; 15 > i; i += 1) {
                var mod = !test && 1 == (bits >> i & 1);
                8 > i ? _modules[8][_moduleCount - i - 1] = mod : 9 > i ? _modules[8][15 - i - 1 + 1] = mod : _modules[8][15 - i - 1] = mod;
            }
            _modules[_moduleCount - 8][8] = !test;
        }, mapData = function(data, maskPattern) {
            for (var inc = -1, row = _moduleCount - 1, bitIndex = 7, byteIndex = 0, maskFunc = QRUtil.getMaskFunction(maskPattern), col = _moduleCount - 1; col > 0; col -= 2) for (6 == col && (col -= 1); ;) {
                for (var c = 0; 2 > c; c += 1) if (null == _modules[row][col - c]) {
                    var dark = !1;
                    byteIndex < data.length && (dark = 1 == (data[byteIndex] >>> bitIndex & 1));
                    var mask = maskFunc(row, col - c);
                    mask && (dark = !dark), _modules[row][col - c] = dark, bitIndex -= 1, -1 == bitIndex && (byteIndex += 1, 
                    bitIndex = 7);
                }
                if (row += inc, 0 > row || row >= _moduleCount) {
                    row -= inc, inc = -inc;
                    break;
                }
            }
        }, createBytes = function(buffer, rsBlocks) {
            for (var offset = 0, maxDcCount = 0, maxEcCount = 0, dcdata = new Array(rsBlocks.length), ecdata = new Array(rsBlocks.length), r = 0; r < rsBlocks.length; r += 1) {
                var dcCount = rsBlocks[r].dataCount, ecCount = rsBlocks[r].totalCount - dcCount;
                maxDcCount = Math.max(maxDcCount, dcCount), maxEcCount = Math.max(maxEcCount, ecCount), 
                dcdata[r] = new Array(dcCount);
                for (var i = 0; i < dcdata[r].length; i += 1) dcdata[r][i] = 255 & buffer.getBuffer()[i + offset];
                offset += dcCount;
                var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount), rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1), modPoly = rawPoly.mod(rsPoly);
                ecdata[r] = new Array(rsPoly.getLength() - 1);
                for (var i = 0; i < ecdata[r].length; i += 1) {
                    var modIndex = i + modPoly.getLength() - ecdata[r].length;
                    ecdata[r][i] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
                }
            }
            for (var totalCodeCount = 0, i = 0; i < rsBlocks.length; i += 1) totalCodeCount += rsBlocks[i].totalCount;
            for (var data = new Array(totalCodeCount), index = 0, i = 0; maxDcCount > i; i += 1) for (var r = 0; r < rsBlocks.length; r += 1) i < dcdata[r].length && (data[index] = dcdata[r][i], 
            index += 1);
            for (var i = 0; maxEcCount > i; i += 1) for (var r = 0; r < rsBlocks.length; r += 1) i < ecdata[r].length && (data[index] = ecdata[r][i], 
            index += 1);
            return data;
        }, createData = function(typeNumber, errorCorrectLevel, dataList) {
            for (var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel), buffer = qrBitBuffer(), i = 0; i < dataList.length; i += 1) {
                var data = dataList[i];
                buffer.put(data.getMode(), 4), buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber)), 
                data.write(buffer);
            }
            for (var totalDataCount = 0, i = 0; i < rsBlocks.length; i += 1) totalDataCount += rsBlocks[i].dataCount;
            if (buffer.getLengthInBits() > 8 * totalDataCount) throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + 8 * totalDataCount + ")");
            for (buffer.getLengthInBits() + 4 <= 8 * totalDataCount && buffer.put(0, 4); buffer.getLengthInBits() % 8 != 0; ) buffer.putBit(!1);
            for (;;) {
                if (buffer.getLengthInBits() >= 8 * totalDataCount) break;
                if (buffer.put(PAD0, 8), buffer.getLengthInBits() >= 8 * totalDataCount) break;
                buffer.put(PAD1, 8);
            }
            return createBytes(buffer, rsBlocks);
        };
        return _this.addData = function(data) {
            var newData = qr8BitByte(data);
            _dataList.push(newData), _dataCache = null;
        }, _this.isDark = function(row, col) {
            if (0 > row || row >= _moduleCount || 0 > col || col >= _moduleCount) throw new Error(row + "," + col);
            return _modules[row][col];
        }, _this.getModuleCount = function() {
            return _moduleCount;
        }, _this.make = function() {
            makeImpl(!1, getBestMaskPattern());
        }, _this.createTableTag = function(cellSize, margin) {
            cellSize = cellSize || 2, margin = "undefined" == typeof margin ? 4 * cellSize : margin;
            var qrHtml = "";
            qrHtml += '<table style="', qrHtml += " border-width: 0px; border-style: none;", 
            qrHtml += " border-collapse: collapse;", qrHtml += " padding: 0px; margin: " + margin + "px;", 
            qrHtml += '">', qrHtml += "<tbody>";
            for (var r = 0; r < _this.getModuleCount(); r += 1) {
                qrHtml += "<tr>";
                for (var c = 0; c < _this.getModuleCount(); c += 1) qrHtml += '<td style="', qrHtml += " border-width: 0px; border-style: none;", 
                qrHtml += " border-collapse: collapse;", qrHtml += " padding: 0px; margin: 0px;", 
                qrHtml += " width: " + cellSize + "px;", qrHtml += " height: " + cellSize + "px;", 
                qrHtml += " background-color: ", qrHtml += _this.isDark(r, c) ? "#000000" : "#ffffff", 
                qrHtml += ";", qrHtml += '"/>';
                qrHtml += "</tr>";
            }
            return qrHtml += "</tbody>", qrHtml += "</table>";
        }, _this.createImgTag = function(cellSize, margin) {
            cellSize = cellSize || 2, margin = "undefined" == typeof margin ? 4 * cellSize : margin;
            var size = _this.getModuleCount() * cellSize + 2 * margin, min = margin, max = size - margin;
            return createImgTag(size, size, function(x, y) {
                if (x >= min && max > x && y >= min && max > y) {
                    var c = Math.floor((x - min) / cellSize), r = Math.floor((y - min) / cellSize);
                    return _this.isDark(r, c) ? 0 : 1;
                }
                return 1;
            });
        }, _this;
    };
    qrcode.stringToBytes = function(s) {
        for (var bytes = new Array(), i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            bytes.push(255 & c);
        }
        return bytes;
    }, qrcode.createStringToBytes = function(unicodeData, numChars) {
        var unicodeMap = function() {
            for (var bin = base64DecodeInputStream(unicodeData), read = function() {
                var b = bin.read();
                if (-1 == b) throw new Error();
                return b;
            }, count = 0, unicodeMap = {}; ;) {
                var b0 = bin.read();
                if (-1 == b0) break;
                var b1 = read(), b2 = read(), b3 = read(), k = String.fromCharCode(b0 << 8 | b1), v = b2 << 8 | b3;
                unicodeMap[k] = v, count += 1;
            }
            if (count != numChars) throw new Error(count + " != " + numChars);
            return unicodeMap;
        }(), unknownChar = "?".charCodeAt(0);
        return function(s) {
            for (var bytes = new Array(), i = 0; i < s.length; i += 1) {
                var c = s.charCodeAt(i);
                if (128 > c) bytes.push(c); else {
                    var b = unicodeMap[s.charAt(i)];
                    "number" == typeof b ? (255 & b) == b ? bytes.push(b) : (bytes.push(b >>> 8), bytes.push(255 & b)) : bytes.push(unknownChar);
                }
            }
            return bytes;
        };
    };
    var QRMode = {
        MODE_NUMBER: 1,
        MODE_ALPHA_NUM: 2,
        MODE_8BIT_BYTE: 4,
        MODE_KANJI: 8
    }, QRErrorCorrectLevel = {
        L: 1,
        M: 0,
        Q: 3,
        H: 2
    }, QRMaskPattern = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    }, QRUtil = function() {
        var PATTERN_POSITION_TABLE = [ [], [ 6, 18 ], [ 6, 22 ], [ 6, 26 ], [ 6, 30 ], [ 6, 34 ], [ 6, 22, 38 ], [ 6, 24, 42 ], [ 6, 26, 46 ], [ 6, 28, 50 ], [ 6, 30, 54 ], [ 6, 32, 58 ], [ 6, 34, 62 ], [ 6, 26, 46, 66 ], [ 6, 26, 48, 70 ], [ 6, 26, 50, 74 ], [ 6, 30, 54, 78 ], [ 6, 30, 56, 82 ], [ 6, 30, 58, 86 ], [ 6, 34, 62, 90 ], [ 6, 28, 50, 72, 94 ], [ 6, 26, 50, 74, 98 ], [ 6, 30, 54, 78, 102 ], [ 6, 28, 54, 80, 106 ], [ 6, 32, 58, 84, 110 ], [ 6, 30, 58, 86, 114 ], [ 6, 34, 62, 90, 118 ], [ 6, 26, 50, 74, 98, 122 ], [ 6, 30, 54, 78, 102, 126 ], [ 6, 26, 52, 78, 104, 130 ], [ 6, 30, 56, 82, 108, 134 ], [ 6, 34, 60, 86, 112, 138 ], [ 6, 30, 58, 86, 114, 142 ], [ 6, 34, 62, 90, 118, 146 ], [ 6, 30, 54, 78, 102, 126, 150 ], [ 6, 24, 50, 76, 102, 128, 154 ], [ 6, 28, 54, 80, 106, 132, 158 ], [ 6, 32, 58, 84, 110, 136, 162 ], [ 6, 26, 54, 82, 110, 138, 166 ], [ 6, 30, 58, 86, 114, 142, 170 ] ], G15 = 1335, G18 = 7973, G15_MASK = 21522, _this = {}, getBCHDigit = function(data) {
            for (var digit = 0; 0 != data; ) digit += 1, data >>>= 1;
            return digit;
        };
        return _this.getBCHTypeInfo = function(data) {
            for (var d = data << 10; getBCHDigit(d) - getBCHDigit(G15) >= 0; ) d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);
            return (data << 10 | d) ^ G15_MASK;
        }, _this.getBCHTypeNumber = function(data) {
            for (var d = data << 12; getBCHDigit(d) - getBCHDigit(G18) >= 0; ) d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);
            return data << 12 | d;
        }, _this.getPatternPosition = function(typeNumber) {
            return PATTERN_POSITION_TABLE[typeNumber - 1];
        }, _this.getMaskFunction = function(maskPattern) {
            switch (maskPattern) {
              case QRMaskPattern.PATTERN000:
                return function(i, j) {
                    return (i + j) % 2 == 0;
                };

              case QRMaskPattern.PATTERN001:
                return function(i, j) {
                    return i % 2 == 0;
                };

              case QRMaskPattern.PATTERN010:
                return function(i, j) {
                    return j % 3 == 0;
                };

              case QRMaskPattern.PATTERN011:
                return function(i, j) {
                    return (i + j) % 3 == 0;
                };

              case QRMaskPattern.PATTERN100:
                return function(i, j) {
                    return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
                };

              case QRMaskPattern.PATTERN101:
                return function(i, j) {
                    return i * j % 2 + i * j % 3 == 0;
                };

              case QRMaskPattern.PATTERN110:
                return function(i, j) {
                    return (i * j % 2 + i * j % 3) % 2 == 0;
                };

              case QRMaskPattern.PATTERN111:
                return function(i, j) {
                    return (i * j % 3 + (i + j) % 2) % 2 == 0;
                };

              default:
                throw new Error("bad maskPattern:" + maskPattern);
            }
        }, _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
            for (var a = qrPolynomial([ 1 ], 0), i = 0; errorCorrectLength > i; i += 1) a = a.multiply(qrPolynomial([ 1, QRMath.gexp(i) ], 0));
            return a;
        }, _this.getLengthInBits = function(mode, type) {
            if (type >= 1 && 10 > type) switch (mode) {
              case QRMode.MODE_NUMBER:
                return 10;

              case QRMode.MODE_ALPHA_NUM:
                return 9;

              case QRMode.MODE_8BIT_BYTE:
                return 8;

              case QRMode.MODE_KANJI:
                return 8;

              default:
                throw new Error("mode:" + mode);
            } else if (27 > type) switch (mode) {
              case QRMode.MODE_NUMBER:
                return 12;

              case QRMode.MODE_ALPHA_NUM:
                return 11;

              case QRMode.MODE_8BIT_BYTE:
                return 16;

              case QRMode.MODE_KANJI:
                return 10;

              default:
                throw new Error("mode:" + mode);
            } else {
                if (!(41 > type)) throw new Error("type:" + type);
                switch (mode) {
                  case QRMode.MODE_NUMBER:
                    return 14;

                  case QRMode.MODE_ALPHA_NUM:
                    return 13;

                  case QRMode.MODE_8BIT_BYTE:
                    return 16;

                  case QRMode.MODE_KANJI:
                    return 12;

                  default:
                    throw new Error("mode:" + mode);
                }
            }
        }, _this.getLostPoint = function(qrcode) {
            for (var moduleCount = qrcode.getModuleCount(), lostPoint = 0, row = 0; moduleCount > row; row += 1) for (var col = 0; moduleCount > col; col += 1) {
                for (var sameCount = 0, dark = qrcode.isDark(row, col), r = -1; 1 >= r; r += 1) if (!(0 > row + r || row + r >= moduleCount)) for (var c = -1; 1 >= c; c += 1) 0 > col + c || col + c >= moduleCount || (0 != r || 0 != c) && dark == qrcode.isDark(row + r, col + c) && (sameCount += 1);
                sameCount > 5 && (lostPoint += 3 + sameCount - 5);
            }
            for (var row = 0; moduleCount - 1 > row; row += 1) for (var col = 0; moduleCount - 1 > col; col += 1) {
                var count = 0;
                qrcode.isDark(row, col) && (count += 1), qrcode.isDark(row + 1, col) && (count += 1), 
                qrcode.isDark(row, col + 1) && (count += 1), qrcode.isDark(row + 1, col + 1) && (count += 1), 
                (0 == count || 4 == count) && (lostPoint += 3);
            }
            for (var row = 0; moduleCount > row; row += 1) for (var col = 0; moduleCount - 6 > col; col += 1) qrcode.isDark(row, col) && !qrcode.isDark(row, col + 1) && qrcode.isDark(row, col + 2) && qrcode.isDark(row, col + 3) && qrcode.isDark(row, col + 4) && !qrcode.isDark(row, col + 5) && qrcode.isDark(row, col + 6) && (lostPoint += 40);
            for (var col = 0; moduleCount > col; col += 1) for (var row = 0; moduleCount - 6 > row; row += 1) qrcode.isDark(row, col) && !qrcode.isDark(row + 1, col) && qrcode.isDark(row + 2, col) && qrcode.isDark(row + 3, col) && qrcode.isDark(row + 4, col) && !qrcode.isDark(row + 5, col) && qrcode.isDark(row + 6, col) && (lostPoint += 40);
            for (var darkCount = 0, col = 0; moduleCount > col; col += 1) for (var row = 0; moduleCount > row; row += 1) qrcode.isDark(row, col) && (darkCount += 1);
            var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
            return lostPoint += 10 * ratio;
        }, _this;
    }(), QRMath = function() {
        for (var EXP_TABLE = new Array(256), LOG_TABLE = new Array(256), i = 0; 8 > i; i += 1) EXP_TABLE[i] = 1 << i;
        for (var i = 8; 256 > i; i += 1) EXP_TABLE[i] = EXP_TABLE[i - 4] ^ EXP_TABLE[i - 5] ^ EXP_TABLE[i - 6] ^ EXP_TABLE[i - 8];
        for (var i = 0; 255 > i; i += 1) LOG_TABLE[EXP_TABLE[i]] = i;
        var _this = {};
        return _this.glog = function(n) {
            if (1 > n) throw new Error("glog(" + n + ")");
            return LOG_TABLE[n];
        }, _this.gexp = function(n) {
            for (;0 > n; ) n += 255;
            for (;n >= 256; ) n -= 255;
            return EXP_TABLE[n];
        }, _this;
    }(), QRRSBlock = function() {
        var RS_BLOCK_TABLE = [ [ 1, 26, 19 ], [ 1, 26, 16 ], [ 1, 26, 13 ], [ 1, 26, 9 ], [ 1, 44, 34 ], [ 1, 44, 28 ], [ 1, 44, 22 ], [ 1, 44, 16 ], [ 1, 70, 55 ], [ 1, 70, 44 ], [ 2, 35, 17 ], [ 2, 35, 13 ], [ 1, 100, 80 ], [ 2, 50, 32 ], [ 2, 50, 24 ], [ 4, 25, 9 ], [ 1, 134, 108 ], [ 2, 67, 43 ], [ 2, 33, 15, 2, 34, 16 ], [ 2, 33, 11, 2, 34, 12 ], [ 2, 86, 68 ], [ 4, 43, 27 ], [ 4, 43, 19 ], [ 4, 43, 15 ], [ 2, 98, 78 ], [ 4, 49, 31 ], [ 2, 32, 14, 4, 33, 15 ], [ 4, 39, 13, 1, 40, 14 ], [ 2, 121, 97 ], [ 2, 60, 38, 2, 61, 39 ], [ 4, 40, 18, 2, 41, 19 ], [ 4, 40, 14, 2, 41, 15 ], [ 2, 146, 116 ], [ 3, 58, 36, 2, 59, 37 ], [ 4, 36, 16, 4, 37, 17 ], [ 4, 36, 12, 4, 37, 13 ], [ 2, 86, 68, 2, 87, 69 ], [ 4, 69, 43, 1, 70, 44 ], [ 6, 43, 19, 2, 44, 20 ], [ 6, 43, 15, 2, 44, 16 ] ], qrRSBlock = function(totalCount, dataCount) {
            var _this = {};
            return _this.totalCount = totalCount, _this.dataCount = dataCount, _this;
        }, _this = {}, getRsBlockTable = function(typeNumber, errorCorrectLevel) {
            switch (errorCorrectLevel) {
              case QRErrorCorrectLevel.L:
                return RS_BLOCK_TABLE[4 * (typeNumber - 1) + 0];

              case QRErrorCorrectLevel.M:
                return RS_BLOCK_TABLE[4 * (typeNumber - 1) + 1];

              case QRErrorCorrectLevel.Q:
                return RS_BLOCK_TABLE[4 * (typeNumber - 1) + 2];

              case QRErrorCorrectLevel.H:
                return RS_BLOCK_TABLE[4 * (typeNumber - 1) + 3];

              default:
                return void 0;
            }
        };
        return _this.getRSBlocks = function(typeNumber, errorCorrectLevel) {
            var rsBlock = getRsBlockTable(typeNumber, errorCorrectLevel);
            if ("undefined" == typeof rsBlock) throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
            for (var length = rsBlock.length / 3, list = new Array(), i = 0; length > i; i += 1) for (var count = rsBlock[3 * i + 0], totalCount = rsBlock[3 * i + 1], dataCount = rsBlock[3 * i + 2], j = 0; count > j; j += 1) list.push(qrRSBlock(totalCount, dataCount));
            return list;
        }, _this;
    }(), qrBitBuffer = function() {
        var _buffer = new Array(), _length = 0, _this = {};
        return _this.getBuffer = function() {
            return _buffer;
        }, _this.getAt = function(index) {
            var bufIndex = Math.floor(index / 8);
            return 1 == (_buffer[bufIndex] >>> 7 - index % 8 & 1);
        }, _this.put = function(num, length) {
            for (var i = 0; length > i; i += 1) _this.putBit(1 == (num >>> length - i - 1 & 1));
        }, _this.getLengthInBits = function() {
            return _length;
        }, _this.putBit = function(bit) {
            var bufIndex = Math.floor(_length / 8);
            _buffer.length <= bufIndex && _buffer.push(0), bit && (_buffer[bufIndex] |= 128 >>> _length % 8), 
            _length += 1;
        }, _this;
    }, qr8BitByte = function(data) {
        var _mode = QRMode.MODE_8BIT_BYTE, _bytes = qrcode.stringToBytes(data), _this = {};
        return _this.getMode = function() {
            return _mode;
        }, _this.getLength = function(buffer) {
            return _bytes.length;
        }, _this.write = function(buffer) {
            for (var i = 0; i < _bytes.length; i += 1) buffer.put(_bytes[i], 8);
        }, _this;
    }, byteArrayOutputStream = function() {
        var _bytes = new Array(), _this = {};
        return _this.writeByte = function(b) {
            _bytes.push(255 & b);
        }, _this.writeShort = function(i) {
            _this.writeByte(i), _this.writeByte(i >>> 8);
        }, _this.writeBytes = function(b, off, len) {
            off = off || 0, len = len || b.length;
            for (var i = 0; len > i; i += 1) _this.writeByte(b[i + off]);
        }, _this.writeString = function(s) {
            for (var i = 0; i < s.length; i += 1) _this.writeByte(s.charCodeAt(i));
        }, _this.toByteArray = function() {
            return _bytes;
        }, _this.toString = function() {
            var s = "";
            s += "[";
            for (var i = 0; i < _bytes.length; i += 1) i > 0 && (s += ","), s += _bytes[i];
            return s += "]";
        }, _this;
    }, base64EncodeOutputStream = function() {
        var _buffer = 0, _buflen = 0, _length = 0, _base64 = "", _this = {}, writeEncoded = function(b) {
            _base64 += String.fromCharCode(encode(63 & b));
        }, encode = function(n) {
            if (0 > n) ; else {
                if (26 > n) return 65 + n;
                if (52 > n) return 97 + (n - 26);
                if (62 > n) return 48 + (n - 52);
                if (62 == n) return 43;
                if (63 == n) return 47;
            }
            throw new Error("n:" + n);
        };
        return _this.writeByte = function(n) {
            for (_buffer = _buffer << 8 | 255 & n, _buflen += 8, _length += 1; _buflen >= 6; ) writeEncoded(_buffer >>> _buflen - 6), 
            _buflen -= 6;
        }, _this.flush = function() {
            if (_buflen > 0 && (writeEncoded(_buffer << 6 - _buflen), _buffer = 0, _buflen = 0), 
            _length % 3 != 0) for (var padlen = 3 - _length % 3, i = 0; padlen > i; i += 1) _base64 += "=";
        }, _this.toString = function() {
            return _base64;
        }, _this;
    }, base64DecodeInputStream = function(str) {
        var _str = str, _pos = 0, _buffer = 0, _buflen = 0, _this = {};
        _this.read = function() {
            for (;8 > _buflen; ) {
                if (_pos >= _str.length) {
                    if (0 == _buflen) return -1;
                    throw new Error("unexpected end of file./" + _buflen);
                }
                var c = _str.charAt(_pos);
                if (_pos += 1, "=" == c) return _buflen = 0, -1;
                c.match(/^\s$/) || (_buffer = _buffer << 6 | decode(c.charCodeAt(0)), _buflen += 6);
            }
            var n = _buffer >>> _buflen - 8 & 255;
            return _buflen -= 8, n;
        };
        var decode = function(c) {
            if (c >= 65 && 90 >= c) return c - 65;
            if (c >= 97 && 122 >= c) return c - 97 + 26;
            if (c >= 48 && 57 >= c) return c - 48 + 52;
            if (43 == c) return 62;
            if (47 == c) return 63;
            throw new Error("c:" + c);
        };
        return _this;
    }, gifImage = function(width, height) {
        var _width = width, _height = height, _data = new Array(width * height), _this = {};
        _this.setPixel = function(x, y, pixel) {
            _data[y * _width + x] = pixel;
        }, _this.write = function(out) {
            out.writeString("GIF87a"), out.writeShort(_width), out.writeShort(_height), out.writeByte(128), 
            out.writeByte(0), out.writeByte(0), out.writeByte(0), out.writeByte(0), out.writeByte(0), 
            out.writeByte(255), out.writeByte(255), out.writeByte(255), out.writeString(","), 
            out.writeShort(0), out.writeShort(0), out.writeShort(_width), out.writeShort(_height), 
            out.writeByte(0);
            var lzwMinCodeSize = 2, raster = getLZWRaster(lzwMinCodeSize);
            out.writeByte(lzwMinCodeSize);
            for (var offset = 0; raster.length - offset > 255; ) out.writeByte(255), out.writeBytes(raster, offset, 255), 
            offset += 255;
            out.writeByte(raster.length - offset), out.writeBytes(raster, offset, raster.length - offset), 
            out.writeByte(0), out.writeString(";");
        };
        var bitOutputStream = function(out) {
            var _out = out, _bitLength = 0, _bitBuffer = 0, _this = {};
            return _this.write = function(data, length) {
                if (data >>> length != 0) throw new Error("length over");
                for (;_bitLength + length >= 8; ) _out.writeByte(255 & (data << _bitLength | _bitBuffer)), 
                length -= 8 - _bitLength, data >>>= 8 - _bitLength, _bitBuffer = 0, _bitLength = 0;
                _bitBuffer = data << _bitLength | _bitBuffer, _bitLength += length;
            }, _this.flush = function() {
                _bitLength > 0 && _out.writeByte(_bitBuffer);
            }, _this;
        }, getLZWRaster = function(lzwMinCodeSize) {
            for (var clearCode = 1 << lzwMinCodeSize, endCode = (1 << lzwMinCodeSize) + 1, bitLength = lzwMinCodeSize + 1, table = lzwTable(), i = 0; clearCode > i; i += 1) table.add(String.fromCharCode(i));
            table.add(String.fromCharCode(clearCode)), table.add(String.fromCharCode(endCode));
            var byteOut = byteArrayOutputStream(), bitOut = bitOutputStream(byteOut);
            bitOut.write(clearCode, bitLength);
            var dataIndex = 0, s = String.fromCharCode(_data[dataIndex]);
            for (dataIndex += 1; dataIndex < _data.length; ) {
                var c = String.fromCharCode(_data[dataIndex]);
                dataIndex += 1, table.contains(s + c) ? s += c : (bitOut.write(table.indexOf(s), bitLength), 
                table.size() < 4095 && (table.size() == 1 << bitLength && (bitLength += 1), table.add(s + c)), 
                s = c);
            }
            return bitOut.write(table.indexOf(s), bitLength), bitOut.write(endCode, bitLength), 
            bitOut.flush(), byteOut.toByteArray();
        }, lzwTable = function() {
            var _map = {}, _size = 0, _this = {};
            return _this.add = function(key) {
                if (_this.contains(key)) throw new Error("dup key:" + key);
                _map[key] = _size, _size += 1;
            }, _this.size = function() {
                return _size;
            }, _this.indexOf = function(key) {
                return _map[key];
            }, _this.contains = function(key) {
                return "undefined" != typeof _map[key];
            }, _this;
        };
        return _this;
    }, createImgTag = function(width, height, getPixel, alt) {
        for (var gif = gifImage(width, height), y = 0; height > y; y += 1) for (var x = 0; width > x; x += 1) gif.setPixel(x, y, getPixel(x, y));
        var b = byteArrayOutputStream();
        gif.write(b);
        for (var base64 = base64EncodeOutputStream(), bytes = b.toByteArray(), i = 0; i < bytes.length; i += 1) base64.writeByte(bytes[i]);
        base64.flush();
        var img = "";
        return img += "<img", img += ' src="', img += "data:image/gif;base64,", img += base64, 
        img += '"', img += ' width="', img += width, img += '"', img += ' height="', img += height, 
        img += '"', alt && (img += ' alt="', img += alt, img += '"'), img += "/>";
    };
    return qrcode;
}();

angular.module("monospaced.qrcode", []).directive("qrcode", [ "$window", function($window) {
    var canvas2D = !!$window.CanvasRenderingContext2D, levels = {
        L: "Low",
        M: "Medium",
        Q: "Quartile",
        H: "High"
    }, draw = function(context, qr, modules, tile) {
        for (var row = 0; modules > row; row++) for (var col = 0; modules > col; col++) {
            var w = Math.ceil((col + 1) * tile) - Math.floor(col * tile), h = Math.ceil((row + 1) * tile) - Math.floor(row * tile);
            context.fillStyle = qr.isDark(row, col) ? "#000" : "#fff", context.fillRect(Math.round(col * tile), Math.round(row * tile), w, h);
        }
    };
    return {
        restrict: "E",
        template: '<a class="qrcode" style="display: table;"><canvas style="display: block; max-width: 100%;"></canvas></a>',
        link: function(scope, element, attrs) {
            var error, version, errorCorrectionLevel, data, size, modules, tile, qr, domElement = element[0], canvas = element.find("canvas")[0], link = element.find("a")[0], context = canvas2D ? canvas.getContext("2d") : null, trim = /^\s+|\s+$/g, setVersion = function(value) {
                version = Math.max(1, Math.min(parseInt(value, 10), 10)) || 4;
            }, setErrorCorrectionLevel = function(value) {
                errorCorrectionLevel = value in levels ? value : "M";
            }, setData = function(value) {
                if (value) {
                    data = value.replace(trim, ""), qr = qrcode(version, errorCorrectionLevel), qr.addData(data);
                    try {
                        qr.make();
                    } catch (e) {
                        return void (error = e.message);
                    }
                    error = !1, modules = qr.getModuleCount();
                }
            }, setSize = function(value) {
                size = parseInt(value, 10) || 2 * modules, tile = size / modules, canvas.width = canvas.height = size;
            }, render = function() {
                return qr ? error ? (canvas2D ? (link.download = "", link.href = "") : domElement.innerHTML = '<img src width="' + size + '"height="' + size + '"class="qrcode"style="display: block;max-width: 100%;">', 
                void scope.$emit("qrcode:error", error)) : void (canvas2D ? (draw(context, qr, modules, tile), 
                link.download = "qrcode.png", link.href = canvas.toDataURL("image/png")) : (domElement.innerHTML = qr.createImgTag(tile, 0), 
                element.find("img").addClass("qrcode").css({
                    display: "block",
                    "max-width": "100%"
                }))) : void 0;
            };
            setVersion(attrs.version), setErrorCorrectionLevel(attrs.errorCorrectionLevel), 
            setSize(attrs.size), attrs.$observe("version", function(value) {
                value && (setVersion(value), setData(data), setSize(size), render());
            }), attrs.$observe("errorCorrectionLevel", function(value) {
                value && (setErrorCorrectionLevel(value), setData(data), setSize(size), render());
            }), attrs.$observe("data", function(value) {
                value && (setData(value), setSize(size), render());
            }), attrs.$observe("size", function(value) {
                value && (setSize(value), render());
            });
        }
    };
} ]), function() {
    var angularFileUpload = angular.module("angularFileUpload", []);
    angularFileUpload.service("$upload", [ "$http", "$q", "$timeout", function($http, $q, $timeout) {
        function sendHttp(config) {
            config.method = config.method || "POST", config.headers = config.headers || {}, 
            config.transformRequest = config.transformRequest || function(data, headersGetter) {
                return window.ArrayBuffer && data instanceof window.ArrayBuffer ? data : $http.defaults.transformRequest[0](data, headersGetter);
            };
            var deferred = $q.defer();
            window.XMLHttpRequest.__isShim && (config.headers.__setXHR_ = function() {
                return function(xhr) {
                    xhr && (config.__XHR = xhr, config.xhrFn && config.xhrFn(xhr), xhr.upload.addEventListener("progress", function(e) {
                        deferred.notify(e);
                    }, !1), xhr.upload.addEventListener("load", function(e) {
                        e.lengthComputable && deferred.notify(e);
                    }, !1));
                };
            }), $http(config).then(function(r) {
                deferred.resolve(r);
            }, function(e) {
                deferred.reject(e);
            }, function(n) {
                deferred.notify(n);
            });
            var promise = deferred.promise;
            return promise.success = function(fn) {
                return promise.then(function(response) {
                    fn(response.data, response.status, response.headers, config);
                }), promise;
            }, promise.error = function(fn) {
                return promise.then(null, function(response) {
                    fn(response.data, response.status, response.headers, config);
                }), promise;
            }, promise.progress = function(fn) {
                return promise.then(null, null, function(update) {
                    fn(update);
                }), promise;
            }, promise.abort = function() {
                return config.__XHR && $timeout(function() {
                    config.__XHR.abort();
                }), promise;
            }, promise.xhr = function(fn) {
                return config.xhrFn = function(origXhrFn) {
                    return function() {
                        origXhrFn && origXhrFn.apply(promise, arguments), fn.apply(promise, arguments);
                    };
                }(config.xhrFn), promise;
            }, promise;
        }
        this.upload = function(config) {
            config.headers = config.headers || {}, config.headers["Content-Type"] = void 0, 
            config.transformRequest = config.transformRequest || $http.defaults.transformRequest;
            var formData = new FormData(), origTransformRequest = config.transformRequest, origData = config.data;
            return config.transformRequest = function(formData, headerGetter) {
                if (origData) if (config.formDataAppender) for (var key in origData) {
                    var val = origData[key];
                    config.formDataAppender(formData, key, val);
                } else for (var key in origData) {
                    var val = origData[key];
                    if ("function" == typeof origTransformRequest) val = origTransformRequest(val, headerGetter); else for (var i = 0; i < origTransformRequest.length; i++) {
                        var transformFn = origTransformRequest[i];
                        "function" == typeof transformFn && (val = transformFn(val, headerGetter));
                    }
                    formData.append(key, val);
                }
                if (null != config.file) {
                    var fileFormName = config.fileFormDataName || "file";
                    if ("[object Array]" === Object.prototype.toString.call(config.file)) for (var isFileFormNameString = "[object String]" === Object.prototype.toString.call(fileFormName), i = 0; i < config.file.length; i++) formData.append(isFileFormNameString ? fileFormName : fileFormName[i], config.file[i], config.fileName && config.fileName[i] || config.file[i].name); else formData.append(fileFormName, config.file, config.fileName || config.file.name);
                }
                return formData;
            }, config.data = formData, sendHttp(config);
        }, this.http = function(config) {
            return sendHttp(config);
        };
    } ]), angularFileUpload.directive("ngFileSelect", [ "$parse", "$timeout", function($parse, $timeout) {
        return function(scope, elem, attr) {
            var fn = $parse(attr.ngFileSelect);
            if ("input" !== elem[0].tagName.toLowerCase() || "file" !== (elem.attr("type") && elem.attr("type").toLowerCase())) {
                for (var fileElem = angular.element('<input type="file">'), attrs = elem[0].attributes, i = 0; i < attrs.length; i++) "type" !== attrs[i].name.toLowerCase() && fileElem.attr(attrs[i].name, attrs[i].value);
                attr.multiple && fileElem.attr("multiple", "true"), fileElem.css("width", "1px").css("height", "1px").css("opacity", 0).css("position", "absolute").css("filter", "alpha(opacity=0)").css("padding", 0).css("margin", 0).css("overflow", "hidden"), 
                fileElem.attr("__wrapper_for_parent_", !0), elem.append(fileElem), elem[0].__file_click_fn_delegate_ = function() {
                    fileElem[0].click();
                }, elem.bind("click", elem[0].__file_click_fn_delegate_), elem.css("overflow", "hidden"), 
                elem = fileElem;
            }
            elem.bind("change", function(evt) {
                var fileList, i, files = [];
                if (fileList = evt.__files_ || evt.target.files, null != fileList) for (i = 0; i < fileList.length; i++) files.push(fileList.item(i));
                $timeout(function() {
                    fn(scope, {
                        $files: files,
                        $event: evt
                    });
                });
            });
        };
    } ]), angularFileUpload.directive("ngFileDropAvailable", [ "$parse", "$timeout", function($parse, $timeout) {
        return function(scope, elem, attr) {
            if ("draggable" in document.createElement("span")) {
                var fn = $parse(attr.ngFileDropAvailable);
                $timeout(function() {
                    fn(scope);
                });
            }
        };
    } ]), angularFileUpload.directive("ngFileDrop", [ "$parse", "$timeout", "$location", function($parse, $timeout, $location) {
        return function(scope, elem, attr) {
            function isASCII(str) {
                return /^[\000-\177]*$/.test(str);
            }
            function extractFiles(evt, callback) {
                var files = [], items = evt.dataTransfer.items;
                if (items && items.length > 0 && items[0].webkitGetAsEntry && "file" != $location.protocol() && items[0].webkitGetAsEntry().isDirectory) for (var i = 0; i < items.length; i++) {
                    var entry = items[i].webkitGetAsEntry();
                    null != entry && (isASCII(entry.name) ? traverseFileTree(files, entry) : items[i].webkitGetAsEntry().isDirectory || files.push(items[i].getAsFile()));
                } else {
                    var fileList = evt.dataTransfer.files;
                    if (null != fileList) for (var i = 0; i < fileList.length; i++) files.push(fileList.item(i));
                }
                !function waitForProcess(delay) {
                    $timeout(function() {
                        processing ? waitForProcess(10) : callback(files);
                    }, delay || 0);
                }();
            }
            function traverseFileTree(files, entry, path) {
                if (null != entry) if (entry.isDirectory) {
                    var dirReader = entry.createReader();
                    processing++, dirReader.readEntries(function(entries) {
                        for (var i = 0; i < entries.length; i++) traverseFileTree(files, entries[i], (path ? path : "") + entry.name + "/");
                        processing--;
                    });
                } else processing++, entry.file(function(file) {
                    processing--, file._relativePath = (path ? path : "") + file.name, files.push(file);
                });
            }
            if ("draggable" in document.createElement("span")) {
                var leaveTimeout = null;
                elem[0].addEventListener("dragover", function(evt) {
                    if (evt.preventDefault(), $timeout.cancel(leaveTimeout), !elem[0].__drag_over_class_) if (attr.ngFileDragOverClass && attr.ngFileDragOverClass.search(/\) *$/) > -1) {
                        var dragOverClass = $parse(attr.ngFileDragOverClass)(scope, {
                            $event: evt
                        });
                        elem[0].__drag_over_class_ = dragOverClass;
                    } else elem[0].__drag_over_class_ = attr.ngFileDragOverClass || "dragover";
                    elem.addClass(elem[0].__drag_over_class_);
                }, !1), elem[0].addEventListener("dragenter", function(evt) {
                    evt.preventDefault();
                }, !1), elem[0].addEventListener("dragleave", function(evt) {
                    leaveTimeout = $timeout(function() {
                        elem.removeClass(elem[0].__drag_over_class_), elem[0].__drag_over_class_ = null;
                    }, attr.ngFileDragOverDelay || 1);
                }, !1);
                var fn = $parse(attr.ngFileDrop);
                elem[0].addEventListener("drop", function(evt) {
                    evt.preventDefault(), elem.removeClass(elem[0].__drag_over_class_), elem[0].__drag_over_class_ = null, 
                    extractFiles(evt, function(files) {
                        fn(scope, {
                            $files: files,
                            $event: evt
                        });
                    });
                }, !1);
                var processing = 0;
            }
        };
    } ]);
}();

var saveAs = saveAs || function(view) {
    if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
        var doc = view.document, get_URL = function() {
            return view.URL || view.webkitURL || view;
        }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent("click", !0, !1, view, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), 
            node.dispatchEvent(event);
        }, webkit_req_fs = view.webkitRequestFileSystem, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem, throw_outside = function(ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }, force_saveable_type = "application/octet-stream", fs_min_size = 0, arbitrary_revoke_timeout = 500, revoke = function(file) {
            var revoker = function() {
                "string" == typeof file ? get_URL().revokeObjectURL(file) : file.remove();
            };
            view.chrome ? revoker() : setTimeout(revoker, arbitrary_revoke_timeout);
        }, dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            for (var i = event_types.length; i--; ) {
                var listener = filesaver["on" + event_types[i]];
                if ("function" == typeof listener) try {
                    listener.call(filesaver, event || filesaver);
                } catch (ex) {
                    throw_outside(ex);
                }
            }
        }, auto_bom = function(blob) {
            return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type) ? new Blob([ "\ufeff", blob ], {
                type: blob.type
            }) : blob;
        }, FileSaver = function(blob, name) {
            blob = auto_bom(blob);
            var object_url, target_view, slice, filesaver = this, type = blob.type, blob_changed = !1, dispatch_all = function() {
                dispatch(filesaver, "writestart progress write writeend".split(" "));
            }, fs_error = function() {
                if ((blob_changed || !object_url) && (object_url = get_URL().createObjectURL(blob)), 
                target_view) target_view.location.href = object_url; else {
                    var new_tab = view.open(object_url, "_blank");
                    void 0 == new_tab && "undefined" != typeof safari && (view.location.href = object_url);
                }
                filesaver.readyState = filesaver.DONE, dispatch_all(), revoke(object_url);
            }, abortable = function(func) {
                return function() {
                    return filesaver.readyState !== filesaver.DONE ? func.apply(this, arguments) : void 0;
                };
            }, create_if_not_found = {
                create: !0,
                exclusive: !1
            };
            return filesaver.readyState = filesaver.INIT, name || (name = "download"), can_use_save_link ? (object_url = get_URL().createObjectURL(blob), 
            save_link.href = object_url, save_link.download = name, click(save_link), filesaver.readyState = filesaver.DONE, 
            dispatch_all(), void revoke(object_url)) : (view.chrome && type && type !== force_saveable_type && (slice = blob.slice || blob.webkitSlice, 
            blob = slice.call(blob, 0, blob.size, force_saveable_type), blob_changed = !0), 
            webkit_req_fs && "download" !== name && (name += ".download"), (type === force_saveable_type || webkit_req_fs) && (target_view = view), 
            req_fs ? (fs_min_size += blob.size, void req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL(), filesaver.readyState = filesaver.DONE, 
                                    dispatch(filesaver, "writeend", event), revoke(file);
                                }, writer.onerror = function() {
                                    var error = writer.error;
                                    error.code !== error.ABORT_ERR && fs_error();
                                }, "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                }), writer.write(blob), filesaver.abort = function() {
                                    writer.abort(), filesaver.readyState = filesaver.DONE;
                                }, filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {
                        create: !1
                    }, abortable(function(file) {
                        file.remove(), save();
                    }), abortable(function(ex) {
                        ex.code === ex.NOT_FOUND_ERR ? save() : fs_error();
                    }));
                }), fs_error);
            }), fs_error)) : void fs_error());
        }, FS_proto = FileSaver.prototype, saveAs = function(blob, name) {
            return new FileSaver(blob, name);
        };
        return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function(blob, name) {
            return navigator.msSaveOrOpenBlob(auto_bom(blob), name);
        } : (FS_proto.abort = function() {
            var filesaver = this;
            filesaver.readyState = filesaver.DONE, dispatch(filesaver, "abort");
        }, FS_proto.readyState = FS_proto.INIT = 0, FS_proto.WRITING = 1, FS_proto.DONE = 2, 
        FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null, 
        saveAs);
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);

"undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null != define.amd && define([], function() {
    return saveAs;
}), function(global, factory) {
    "function" == typeof define && define.amd ? define([], factory) : "undefined" != typeof module && module.exports ? module.exports = factory() : global.tv4 = factory();
}(this, function() {
    function recursiveCompare(A, B) {
        if (A === B) return !0;
        if ("object" == typeof A && "object" == typeof B) {
            if (Array.isArray(A) !== Array.isArray(B)) return !1;
            if (Array.isArray(A)) {
                if (A.length !== B.length) return !1;
                for (var i = 0; i < A.length; i++) if (!recursiveCompare(A[i], B[i])) return !1;
            } else {
                var key;
                for (key in A) if (void 0 === B[key] && void 0 !== A[key]) return !1;
                for (key in B) if (void 0 === A[key] && void 0 !== B[key]) return !1;
                for (key in A) if (!recursiveCompare(A[key], B[key])) return !1;
            }
            return !0;
        }
        return !1;
    }
    function parseURI(url) {
        var m = String(url).replace(/^\s+|\s+$/g, "").match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
        return m ? {
            href: m[0] || "",
            protocol: m[1] || "",
            authority: m[2] || "",
            host: m[3] || "",
            hostname: m[4] || "",
            port: m[5] || "",
            pathname: m[6] || "",
            search: m[7] || "",
            hash: m[8] || ""
        } : null;
    }
    function resolveUrl(base, href) {
        function removeDotSegments(input) {
            var output = [];
            return input.replace(/^(\.\.?(\/|$))+/, "").replace(/\/(\.(\/|$))+/g, "/").replace(/\/\.\.$/, "/../").replace(/\/?[^\/]*/g, function(p) {
                "/.." === p ? output.pop() : output.push(p);
            }), output.join("").replace(/^\//, "/" === input.charAt(0) ? "/" : "");
        }
        return href = parseURI(href || ""), base = parseURI(base || ""), href && base ? (href.protocol || base.protocol) + (href.protocol || href.authority ? href.authority : base.authority) + removeDotSegments(href.protocol || href.authority || "/" === href.pathname.charAt(0) ? href.pathname : href.pathname ? (base.authority && !base.pathname ? "/" : "") + base.pathname.slice(0, base.pathname.lastIndexOf("/") + 1) + href.pathname : base.pathname) + (href.protocol || href.authority || href.pathname ? href.search : href.search || base.search) + href.hash : null;
    }
    function getDocumentUri(uri) {
        return uri.split("#")[0];
    }
    function normSchema(schema, baseUri) {
        if (schema && "object" == typeof schema) if (void 0 === baseUri ? baseUri = schema.id : "string" == typeof schema.id && (baseUri = resolveUrl(baseUri, schema.id), 
        schema.id = baseUri), Array.isArray(schema)) for (var i = 0; i < schema.length; i++) normSchema(schema[i], baseUri); else {
            "string" == typeof schema.$ref && (schema.$ref = resolveUrl(baseUri, schema.$ref));
            for (var key in schema) "enum" !== key && normSchema(schema[key], baseUri);
        }
    }
    function ValidationError(code, message, dataPath, schemaPath, subErrors) {
        if (Error.call(this), void 0 === code) throw new Error("No code supplied for error: " + message);
        this.message = message, this.code = code, this.dataPath = dataPath || "", this.schemaPath = schemaPath || "", 
        this.subErrors = subErrors || null;
        var err = new Error(this.message);
        if (this.stack = err.stack || err.stacktrace, !this.stack) try {
            throw err;
        } catch (err) {
            this.stack = err.stack || err.stacktrace;
        }
    }
    function isTrustedUrl(baseUrl, testUrl) {
        if (testUrl.substring(0, baseUrl.length) === baseUrl) {
            var remainder = testUrl.substring(baseUrl.length);
            if (testUrl.length > 0 && "/" === testUrl.charAt(baseUrl.length - 1) || "#" === remainder.charAt(0) || "?" === remainder.charAt(0)) return !0;
        }
        return !1;
    }
    function createApi(language) {
        var globalContext = new ValidatorContext(), currentLanguage = language || "en", api = {
            addFormat: function() {
                globalContext.addFormat.apply(globalContext, arguments);
            },
            language: function(code) {
                return code ? (languages[code] || (code = code.split("-")[0]), languages[code] ? (currentLanguage = code, 
                code) : !1) : currentLanguage;
            },
            addLanguage: function(code, messageMap) {
                var key;
                for (key in ErrorCodes) messageMap[key] && !messageMap[ErrorCodes[key]] && (messageMap[ErrorCodes[key]] = messageMap[key]);
                var rootCode = code.split("-")[0];
                if (languages[rootCode]) {
                    languages[code] = Object.create(languages[rootCode]);
                    for (key in messageMap) "undefined" == typeof languages[rootCode][key] && (languages[rootCode][key] = messageMap[key]), 
                    languages[code][key] = messageMap[key];
                } else languages[code] = messageMap, languages[rootCode] = messageMap;
                return this;
            },
            freshApi: function(language) {
                var result = createApi();
                return language && result.language(language), result;
            },
            validate: function(data, schema, checkRecursive, banUnknownProperties) {
                var context = new ValidatorContext(globalContext, !1, languages[currentLanguage], checkRecursive, banUnknownProperties);
                "string" == typeof schema && (schema = {
                    $ref: schema
                }), context.addSchema("", schema);
                var error = context.validateAll(data, schema, null, null, "");
                return !error && banUnknownProperties && (error = context.banUnknownProperties()), 
                this.error = error, this.missing = context.missing, this.valid = null === error, 
                this.valid;
            },
            validateResult: function() {
                var result = {};
                return this.validate.apply(result, arguments), result;
            },
            validateMultiple: function(data, schema, checkRecursive, banUnknownProperties) {
                var context = new ValidatorContext(globalContext, !0, languages[currentLanguage], checkRecursive, banUnknownProperties);
                "string" == typeof schema && (schema = {
                    $ref: schema
                }), context.addSchema("", schema), context.validateAll(data, schema, null, null, ""), 
                banUnknownProperties && context.banUnknownProperties();
                var result = {};
                return result.errors = context.errors, result.missing = context.missing, result.valid = 0 === result.errors.length, 
                result;
            },
            addSchema: function() {
                return globalContext.addSchema.apply(globalContext, arguments);
            },
            getSchema: function() {
                return globalContext.getSchema.apply(globalContext, arguments);
            },
            getSchemaMap: function() {
                return globalContext.getSchemaMap.apply(globalContext, arguments);
            },
            getSchemaUris: function() {
                return globalContext.getSchemaUris.apply(globalContext, arguments);
            },
            getMissingUris: function() {
                return globalContext.getMissingUris.apply(globalContext, arguments);
            },
            dropSchemas: function() {
                globalContext.dropSchemas.apply(globalContext, arguments);
            },
            defineKeyword: function() {
                globalContext.defineKeyword.apply(globalContext, arguments);
            },
            defineError: function(codeName, codeNumber, defaultMessage) {
                if ("string" != typeof codeName || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) throw new Error("Code name must be a string in UPPER_CASE_WITH_UNDERSCORES");
                if ("number" != typeof codeNumber || codeNumber % 1 !== 0 || 1e4 > codeNumber) throw new Error("Code number must be an integer > 10000");
                if ("undefined" != typeof ErrorCodes[codeName]) throw new Error("Error already defined: " + codeName + " as " + ErrorCodes[codeName]);
                if ("undefined" != typeof ErrorCodeLookup[codeNumber]) throw new Error("Error code already used: " + ErrorCodeLookup[codeNumber] + " as " + codeNumber);
                ErrorCodes[codeName] = codeNumber, ErrorCodeLookup[codeNumber] = codeName, ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
                for (var langCode in languages) {
                    var language = languages[langCode];
                    language[codeName] && (language[codeNumber] = language[codeNumber] || language[codeName]);
                }
            },
            reset: function() {
                globalContext.reset(), this.error = null, this.missing = [], this.valid = !0;
            },
            missing: [],
            error: null,
            valid: !0,
            normSchema: normSchema,
            resolveUrl: resolveUrl,
            getDocumentUri: getDocumentUri,
            errorCodes: ErrorCodes
        };
        return api;
    }
    Object.keys || (Object.keys = function() {
        var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !{
            toString: null
        }.propertyIsEnumerable("toString"), dontEnums = [ "toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor" ], dontEnumsLength = dontEnums.length;
        return function(obj) {
            if ("object" != typeof obj && "function" != typeof obj || null === obj) throw new TypeError("Object.keys called on non-object");
            var result = [];
            for (var prop in obj) hasOwnProperty.call(obj, prop) && result.push(prop);
            if (hasDontEnumBug) for (var i = 0; dontEnumsLength > i; i++) hasOwnProperty.call(obj, dontEnums[i]) && result.push(dontEnums[i]);
            return result;
        };
    }()), Object.create || (Object.create = function() {
        function F() {}
        return function(o) {
            if (1 !== arguments.length) throw new Error("Object.create implementation only accepts one parameter.");
            return F.prototype = o, new F();
        };
    }()), Array.isArray || (Array.isArray = function(vArg) {
        return "[object Array]" === Object.prototype.toString.call(vArg);
    }), Array.prototype.indexOf || (Array.prototype.indexOf = function(searchElement) {
        if (null === this) throw new TypeError();
        var t = Object(this), len = t.length >>> 0;
        if (0 === len) return -1;
        var n = 0;
        if (arguments.length > 1 && (n = Number(arguments[1]), n !== n ? n = 0 : 0 !== n && n !== 1 / 0 && n !== -(1 / 0) && (n = (n > 0 || -1) * Math.floor(Math.abs(n)))), 
        n >= len) return -1;
        for (var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0); len > k; k++) if (k in t && t[k] === searchElement) return k;
        return -1;
    }), Object.isFrozen || (Object.isFrozen = function(obj) {
        for (var key = "tv4_test_frozen_key"; obj.hasOwnProperty(key); ) key += Math.random();
        try {
            return obj[key] = !0, delete obj[key], !1;
        } catch (e) {
            return !0;
        }
    });
    var ValidatorContext = function(parent, collectMultiple, errorMessages, checkRecursive, trackUnknownProperties) {
        if (this.missing = [], this.missingMap = {}, this.formatValidators = parent ? Object.create(parent.formatValidators) : {}, 
        this.schemas = parent ? Object.create(parent.schemas) : {}, this.collectMultiple = collectMultiple, 
        this.errors = [], this.handleError = collectMultiple ? this.collectError : this.returnError, 
        checkRecursive && (this.checkRecursive = !0, this.scanned = [], this.scannedFrozen = [], 
        this.scannedFrozenSchemas = [], this.scannedFrozenValidationErrors = [], this.validatedSchemasKey = "tv4_validation_id", 
        this.validationErrorsKey = "tv4_validation_errors_id"), trackUnknownProperties && (this.trackUnknownProperties = !0, 
        this.knownPropertyPaths = {}, this.unknownPropertyPaths = {}), this.errorMessages = errorMessages, 
        this.definedKeywords = {}, parent) for (var key in parent.definedKeywords) this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
    };
    ValidatorContext.prototype.defineKeyword = function(keyword, keywordFunction) {
        this.definedKeywords[keyword] = this.definedKeywords[keyword] || [], this.definedKeywords[keyword].push(keywordFunction);
    }, ValidatorContext.prototype.createError = function(code, messageParams, dataPath, schemaPath, subErrors) {
        var messageTemplate = this.errorMessages[code] || ErrorMessagesDefault[code];
        if ("string" != typeof messageTemplate) return new ValidationError(code, "Unknown error code " + code + ": " + JSON.stringify(messageParams), dataPath, schemaPath, subErrors);
        var message = messageTemplate.replace(/\{([^{}]*)\}/g, function(whole, varName) {
            var subValue = messageParams[varName];
            return "string" == typeof subValue || "number" == typeof subValue ? subValue : whole;
        });
        return new ValidationError(code, message, dataPath, schemaPath, subErrors);
    }, ValidatorContext.prototype.returnError = function(error) {
        return error;
    }, ValidatorContext.prototype.collectError = function(error) {
        return error && this.errors.push(error), null;
    }, ValidatorContext.prototype.prefixErrors = function(startIndex, dataPath, schemaPath) {
        for (var i = startIndex; i < this.errors.length; i++) this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
        return this;
    }, ValidatorContext.prototype.banUnknownProperties = function() {
        for (var unknownPath in this.unknownPropertyPaths) {
            var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {
                path: unknownPath
            }, unknownPath, ""), result = this.handleError(error);
            if (result) return result;
        }
        return null;
    }, ValidatorContext.prototype.addFormat = function(format, validator) {
        if ("object" == typeof format) {
            for (var key in format) this.addFormat(key, format[key]);
            return this;
        }
        this.formatValidators[format] = validator;
    }, ValidatorContext.prototype.resolveRefs = function(schema, urlHistory) {
        if (void 0 !== schema.$ref) {
            if (urlHistory = urlHistory || {}, urlHistory[schema.$ref]) return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {
                urls: Object.keys(urlHistory).join(", ")
            }, "", "");
            urlHistory[schema.$ref] = !0, schema = this.getSchema(schema.$ref, urlHistory);
        }
        return schema;
    }, ValidatorContext.prototype.getSchema = function(url, urlHistory) {
        var schema;
        if (void 0 !== this.schemas[url]) return schema = this.schemas[url], this.resolveRefs(schema, urlHistory);
        var baseUrl = url, fragment = "";
        if (-1 !== url.indexOf("#") && (fragment = url.substring(url.indexOf("#") + 1), 
        baseUrl = url.substring(0, url.indexOf("#"))), "object" == typeof this.schemas[baseUrl]) {
            schema = this.schemas[baseUrl];
            var pointerPath = decodeURIComponent(fragment);
            if ("" === pointerPath) return this.resolveRefs(schema, urlHistory);
            if ("/" !== pointerPath.charAt(0)) return void 0;
            for (var parts = pointerPath.split("/").slice(1), i = 0; i < parts.length; i++) {
                var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
                if (void 0 === schema[component]) {
                    schema = void 0;
                    break;
                }
                schema = schema[component];
            }
            if (void 0 !== schema) return this.resolveRefs(schema, urlHistory);
        }
        void 0 === this.missing[baseUrl] && (this.missing.push(baseUrl), this.missing[baseUrl] = baseUrl, 
        this.missingMap[baseUrl] = baseUrl);
    }, ValidatorContext.prototype.searchSchemas = function(schema, url) {
        if (schema && "object" == typeof schema) {
            "string" == typeof schema.id && isTrustedUrl(url, schema.id) && void 0 === this.schemas[schema.id] && (this.schemas[schema.id] = schema);
            for (var key in schema) if ("enum" !== key) if ("object" == typeof schema[key]) this.searchSchemas(schema[key], url); else if ("$ref" === key) {
                var uri = getDocumentUri(schema[key]);
                uri && void 0 === this.schemas[uri] && void 0 === this.missingMap[uri] && (this.missingMap[uri] = uri);
            }
        }
    }, ValidatorContext.prototype.addSchema = function(url, schema) {
        if ("string" != typeof url || "undefined" == typeof schema) {
            if ("object" != typeof url || "string" != typeof url.id) return;
            schema = url, url = schema.id;
        }
        (url = getDocumentUri(url) + "#") && (url = getDocumentUri(url)), this.schemas[url] = schema, 
        delete this.missingMap[url], normSchema(schema, url), this.searchSchemas(schema, url);
    }, ValidatorContext.prototype.getSchemaMap = function() {
        var map = {};
        for (var key in this.schemas) map[key] = this.schemas[key];
        return map;
    }, ValidatorContext.prototype.getSchemaUris = function(filterRegExp) {
        var list = [];
        for (var key in this.schemas) (!filterRegExp || filterRegExp.test(key)) && list.push(key);
        return list;
    }, ValidatorContext.prototype.getMissingUris = function(filterRegExp) {
        var list = [];
        for (var key in this.missingMap) (!filterRegExp || filterRegExp.test(key)) && list.push(key);
        return list;
    }, ValidatorContext.prototype.dropSchemas = function() {
        this.schemas = {}, this.reset();
    }, ValidatorContext.prototype.reset = function() {
        this.missing = [], this.missingMap = {}, this.errors = [];
    }, ValidatorContext.prototype.validateAll = function(data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
        var topLevel;
        if (schema = this.resolveRefs(schema), !schema) return null;
        if (schema instanceof ValidationError) return this.errors.push(schema), schema;
        var frozenIndex, startErrorCount = this.errors.length, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
        if (this.checkRecursive && data && "object" == typeof data) {
            if (topLevel = !this.scanned.length, data[this.validatedSchemasKey]) {
                var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
                if (-1 !== schemaIndex) return this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]), 
                null;
            }
            if (Object.isFrozen(data) && (frozenIndex = this.scannedFrozen.indexOf(data), -1 !== frozenIndex)) {
                var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
                if (-1 !== frozenSchemaIndex) return this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]), 
                null;
            }
            if (this.scanned.push(data), Object.isFrozen(data)) -1 === frozenIndex && (frozenIndex = this.scannedFrozen.length, 
            this.scannedFrozen.push(data), this.scannedFrozenSchemas.push([])), scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length, 
            this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema, this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = []; else {
                if (!data[this.validatedSchemasKey]) try {
                    Object.defineProperty(data, this.validatedSchemasKey, {
                        value: [],
                        configurable: !0
                    }), Object.defineProperty(data, this.validationErrorsKey, {
                        value: [],
                        configurable: !0
                    });
                } catch (e) {
                    data[this.validatedSchemasKey] = [], data[this.validationErrorsKey] = [];
                }
                scannedSchemasIndex = data[this.validatedSchemasKey].length, data[this.validatedSchemasKey][scannedSchemasIndex] = schema, 
                data[this.validationErrorsKey][scannedSchemasIndex] = [];
            }
        }
        var errorCount = this.errors.length, error = this.validateBasic(data, schema, dataPointerPath) || this.validateNumeric(data, schema, dataPointerPath) || this.validateString(data, schema, dataPointerPath) || this.validateArray(data, schema, dataPointerPath) || this.validateObject(data, schema, dataPointerPath) || this.validateCombinations(data, schema, dataPointerPath) || this.validateFormat(data, schema, dataPointerPath) || this.validateDefinedKeywords(data, schema, dataPointerPath) || null;
        if (topLevel) {
            for (;this.scanned.length; ) {
                var item = this.scanned.pop();
                delete item[this.validatedSchemasKey];
            }
            this.scannedFrozen = [], this.scannedFrozenSchemas = [];
        }
        if (error || errorCount !== this.errors.length) for (;dataPathParts && dataPathParts.length || schemaPathParts && schemaPathParts.length; ) {
            var dataPart = dataPathParts && dataPathParts.length ? "" + dataPathParts.pop() : null, schemaPart = schemaPathParts && schemaPathParts.length ? "" + schemaPathParts.pop() : null;
            error && (error = error.prefixWith(dataPart, schemaPart)), this.prefixErrors(errorCount, dataPart, schemaPart);
        }
        return null !== scannedFrozenSchemaIndex ? this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount) : null !== scannedSchemasIndex && (data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount)), 
        this.handleError(error);
    }, ValidatorContext.prototype.validateFormat = function(data, schema) {
        if ("string" != typeof schema.format || !this.formatValidators[schema.format]) return null;
        var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
        return "string" == typeof errorMessage || "number" == typeof errorMessage ? this.createError(ErrorCodes.FORMAT_CUSTOM, {
            message: errorMessage
        }).prefixWith(null, "format") : errorMessage && "object" == typeof errorMessage ? this.createError(ErrorCodes.FORMAT_CUSTOM, {
            message: errorMessage.message || "?"
        }, errorMessage.dataPath || null, errorMessage.schemaPath || "/format") : null;
    }, ValidatorContext.prototype.validateDefinedKeywords = function(data, schema) {
        for (var key in this.definedKeywords) for (var validationFunctions = this.definedKeywords[key], i = 0; i < validationFunctions.length; i++) {
            var func = validationFunctions[i], result = func(data, schema[key], schema);
            if ("string" == typeof result || "number" == typeof result) return this.createError(ErrorCodes.KEYWORD_CUSTOM, {
                key: key,
                message: result
            }).prefixWith(null, "format");
            if (result && "object" == typeof result) {
                var code = result.code || ErrorCodes.KEYWORD_CUSTOM;
                if ("string" == typeof code) {
                    if (!ErrorCodes[code]) throw new Error("Undefined error code (use defineError): " + code);
                    code = ErrorCodes[code];
                }
                var messageParams = "object" == typeof result.message ? result.message : {
                    key: key,
                    message: result.message || "?"
                }, schemaPath = result.schemaPath || "/" + key.replace(/~/g, "~0").replace(/\//g, "~1");
                return this.createError(code, messageParams, result.dataPath || null, schemaPath);
            }
        }
        return null;
    }, ValidatorContext.prototype.validateBasic = function(data, schema, dataPointerPath) {
        var error;
        return (error = this.validateType(data, schema, dataPointerPath)) ? error.prefixWith(null, "type") : (error = this.validateEnum(data, schema, dataPointerPath)) ? error.prefixWith(null, "type") : null;
    }, ValidatorContext.prototype.validateType = function(data, schema) {
        if (void 0 === schema.type) return null;
        var dataType = typeof data;
        null === data ? dataType = "null" : Array.isArray(data) && (dataType = "array");
        var allowedTypes = schema.type;
        "object" != typeof allowedTypes && (allowedTypes = [ allowedTypes ]);
        for (var i = 0; i < allowedTypes.length; i++) {
            var type = allowedTypes[i];
            if (type === dataType || "integer" === type && "number" === dataType && data % 1 === 0) return null;
        }
        return this.createError(ErrorCodes.INVALID_TYPE, {
            type: dataType,
            expected: allowedTypes.join("/")
        });
    }, ValidatorContext.prototype.validateEnum = function(data, schema) {
        if (void 0 === schema["enum"]) return null;
        for (var i = 0; i < schema["enum"].length; i++) {
            var enumVal = schema["enum"][i];
            if (recursiveCompare(data, enumVal)) return null;
        }
        return this.createError(ErrorCodes.ENUM_MISMATCH, {
            value: "undefined" != typeof JSON ? JSON.stringify(data) : data
        });
    }, ValidatorContext.prototype.validateNumeric = function(data, schema, dataPointerPath) {
        return this.validateMultipleOf(data, schema, dataPointerPath) || this.validateMinMax(data, schema, dataPointerPath) || null;
    }, ValidatorContext.prototype.validateMultipleOf = function(data, schema) {
        var multipleOf = schema.multipleOf || schema.divisibleBy;
        return void 0 === multipleOf ? null : "number" == typeof data && data % multipleOf !== 0 ? this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {
            value: data,
            multipleOf: multipleOf
        }) : null;
    }, ValidatorContext.prototype.validateMinMax = function(data, schema) {
        if ("number" != typeof data) return null;
        if (void 0 !== schema.minimum) {
            if (data < schema.minimum) return this.createError(ErrorCodes.NUMBER_MINIMUM, {
                value: data,
                minimum: schema.minimum
            }).prefixWith(null, "minimum");
            if (schema.exclusiveMinimum && data === schema.minimum) return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {
                value: data,
                minimum: schema.minimum
            }).prefixWith(null, "exclusiveMinimum");
        }
        if (void 0 !== schema.maximum) {
            if (data > schema.maximum) return this.createError(ErrorCodes.NUMBER_MAXIMUM, {
                value: data,
                maximum: schema.maximum
            }).prefixWith(null, "maximum");
            if (schema.exclusiveMaximum && data === schema.maximum) return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {
                value: data,
                maximum: schema.maximum
            }).prefixWith(null, "exclusiveMaximum");
        }
        return null;
    }, ValidatorContext.prototype.validateString = function(data, schema, dataPointerPath) {
        return this.validateStringLength(data, schema, dataPointerPath) || this.validateStringPattern(data, schema, dataPointerPath) || null;
    }, ValidatorContext.prototype.validateStringLength = function(data, schema) {
        return "string" != typeof data ? null : void 0 !== schema.minLength && data.length < schema.minLength ? this.createError(ErrorCodes.STRING_LENGTH_SHORT, {
            length: data.length,
            minimum: schema.minLength
        }).prefixWith(null, "minLength") : void 0 !== schema.maxLength && data.length > schema.maxLength ? this.createError(ErrorCodes.STRING_LENGTH_LONG, {
            length: data.length,
            maximum: schema.maxLength
        }).prefixWith(null, "maxLength") : null;
    }, ValidatorContext.prototype.validateStringPattern = function(data, schema) {
        if ("string" != typeof data || void 0 === schema.pattern) return null;
        var regexp = new RegExp(schema.pattern);
        return regexp.test(data) ? null : this.createError(ErrorCodes.STRING_PATTERN, {
            pattern: schema.pattern
        }).prefixWith(null, "pattern");
    }, ValidatorContext.prototype.validateArray = function(data, schema, dataPointerPath) {
        return Array.isArray(data) ? this.validateArrayLength(data, schema, dataPointerPath) || this.validateArrayUniqueItems(data, schema, dataPointerPath) || this.validateArrayItems(data, schema, dataPointerPath) || null : null;
    }, ValidatorContext.prototype.validateArrayLength = function(data, schema) {
        var error;
        return void 0 !== schema.minItems && data.length < schema.minItems && (error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {
            length: data.length,
            minimum: schema.minItems
        }).prefixWith(null, "minItems"), this.handleError(error)) ? error : void 0 !== schema.maxItems && data.length > schema.maxItems && (error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {
            length: data.length,
            maximum: schema.maxItems
        }).prefixWith(null, "maxItems"), this.handleError(error)) ? error : null;
    }, ValidatorContext.prototype.validateArrayUniqueItems = function(data, schema) {
        if (schema.uniqueItems) for (var i = 0; i < data.length; i++) for (var j = i + 1; j < data.length; j++) if (recursiveCompare(data[i], data[j])) {
            var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {
                match1: i,
                match2: j
            }).prefixWith(null, "uniqueItems");
            if (this.handleError(error)) return error;
        }
        return null;
    }, ValidatorContext.prototype.validateArrayItems = function(data, schema, dataPointerPath) {
        if (void 0 === schema.items) return null;
        var error, i;
        if (Array.isArray(schema.items)) {
            for (i = 0; i < data.length; i++) if (i < schema.items.length) {
                if (error = this.validateAll(data[i], schema.items[i], [ i ], [ "items", i ], dataPointerPath + "/" + i)) return error;
            } else if (void 0 !== schema.additionalItems) if ("boolean" == typeof schema.additionalItems) {
                if (!schema.additionalItems && (error = this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}).prefixWith("" + i, "additionalItems"), 
                this.handleError(error))) return error;
            } else if (error = this.validateAll(data[i], schema.additionalItems, [ i ], [ "additionalItems" ], dataPointerPath + "/" + i)) return error;
        } else for (i = 0; i < data.length; i++) if (error = this.validateAll(data[i], schema.items, [ i ], [ "items" ], dataPointerPath + "/" + i)) return error;
        return null;
    }, ValidatorContext.prototype.validateObject = function(data, schema, dataPointerPath) {
        return "object" != typeof data || null === data || Array.isArray(data) ? null : this.validateObjectMinMaxProperties(data, schema, dataPointerPath) || this.validateObjectRequiredProperties(data, schema, dataPointerPath) || this.validateObjectProperties(data, schema, dataPointerPath) || this.validateObjectDependencies(data, schema, dataPointerPath) || null;
    }, ValidatorContext.prototype.validateObjectMinMaxProperties = function(data, schema) {
        var error, keys = Object.keys(data);
        return void 0 !== schema.minProperties && keys.length < schema.minProperties && (error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {
            propertyCount: keys.length,
            minimum: schema.minProperties
        }).prefixWith(null, "minProperties"), this.handleError(error)) ? error : void 0 !== schema.maxProperties && keys.length > schema.maxProperties && (error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {
            propertyCount: keys.length,
            maximum: schema.maxProperties
        }).prefixWith(null, "maxProperties"), this.handleError(error)) ? error : null;
    }, ValidatorContext.prototype.validateObjectRequiredProperties = function(data, schema) {
        if (void 0 !== schema.required) for (var i = 0; i < schema.required.length; i++) {
            var key = schema.required[i];
            if (void 0 === data[key]) {
                var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {
                    key: key
                }).prefixWith(null, "" + i).prefixWith(null, "required");
                if (this.handleError(error)) return error;
            }
        }
        return null;
    }, ValidatorContext.prototype.validateObjectProperties = function(data, schema, dataPointerPath) {
        var error;
        for (var key in data) {
            var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, "~0").replace(/\//g, "~1"), foundMatch = !1;
            if (void 0 !== schema.properties && void 0 !== schema.properties[key] && (foundMatch = !0, 
            error = this.validateAll(data[key], schema.properties[key], [ key ], [ "properties", key ], keyPointerPath))) return error;
            if (void 0 !== schema.patternProperties) for (var patternKey in schema.patternProperties) {
                var regexp = new RegExp(patternKey);
                if (regexp.test(key) && (foundMatch = !0, error = this.validateAll(data[key], schema.patternProperties[patternKey], [ key ], [ "patternProperties", patternKey ], keyPointerPath))) return error;
            }
            if (foundMatch) this.trackUnknownProperties && (this.knownPropertyPaths[keyPointerPath] = !0, 
            delete this.unknownPropertyPaths[keyPointerPath]); else if (void 0 !== schema.additionalProperties) {
                if (this.trackUnknownProperties && (this.knownPropertyPaths[keyPointerPath] = !0, 
                delete this.unknownPropertyPaths[keyPointerPath]), "boolean" == typeof schema.additionalProperties) {
                    if (!schema.additionalProperties && (error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {}).prefixWith(key, "additionalProperties"), 
                    this.handleError(error))) return error;
                } else if (error = this.validateAll(data[key], schema.additionalProperties, [ key ], [ "additionalProperties" ], keyPointerPath)) return error;
            } else this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath] && (this.unknownPropertyPaths[keyPointerPath] = !0);
        }
        return null;
    }, ValidatorContext.prototype.validateObjectDependencies = function(data, schema, dataPointerPath) {
        var error;
        if (void 0 !== schema.dependencies) for (var depKey in schema.dependencies) if (void 0 !== data[depKey]) {
            var dep = schema.dependencies[depKey];
            if ("string" == typeof dep) {
                if (void 0 === data[dep] && (error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {
                    key: depKey,
                    missing: dep
                }).prefixWith(null, depKey).prefixWith(null, "dependencies"), this.handleError(error))) return error;
            } else if (Array.isArray(dep)) for (var i = 0; i < dep.length; i++) {
                var requiredKey = dep[i];
                if (void 0 === data[requiredKey] && (error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {
                    key: depKey,
                    missing: requiredKey
                }).prefixWith(null, "" + i).prefixWith(null, depKey).prefixWith(null, "dependencies"), 
                this.handleError(error))) return error;
            } else if (error = this.validateAll(data, dep, [], [ "dependencies", depKey ], dataPointerPath)) return error;
        }
        return null;
    }, ValidatorContext.prototype.validateCombinations = function(data, schema, dataPointerPath) {
        return this.validateAllOf(data, schema, dataPointerPath) || this.validateAnyOf(data, schema, dataPointerPath) || this.validateOneOf(data, schema, dataPointerPath) || this.validateNot(data, schema, dataPointerPath) || null;
    }, ValidatorContext.prototype.validateAllOf = function(data, schema, dataPointerPath) {
        if (void 0 === schema.allOf) return null;
        for (var error, i = 0; i < schema.allOf.length; i++) {
            var subSchema = schema.allOf[i];
            if (error = this.validateAll(data, subSchema, [], [ "allOf", i ], dataPointerPath)) return error;
        }
        return null;
    }, ValidatorContext.prototype.validateAnyOf = function(data, schema, dataPointerPath) {
        if (void 0 === schema.anyOf) return null;
        var oldUnknownPropertyPaths, oldKnownPropertyPaths, errors = [], startErrorCount = this.errors.length;
        this.trackUnknownProperties && (oldUnknownPropertyPaths = this.unknownPropertyPaths, 
        oldKnownPropertyPaths = this.knownPropertyPaths);
        for (var errorAtEnd = !0, i = 0; i < schema.anyOf.length; i++) {
            this.trackUnknownProperties && (this.unknownPropertyPaths = {}, this.knownPropertyPaths = {});
            var subSchema = schema.anyOf[i], errorCount = this.errors.length, error = this.validateAll(data, subSchema, [], [ "anyOf", i ], dataPointerPath);
            if (null === error && errorCount === this.errors.length) {
                if (this.errors = this.errors.slice(0, startErrorCount), this.trackUnknownProperties) {
                    for (var knownKey in this.knownPropertyPaths) oldKnownPropertyPaths[knownKey] = !0, 
                    delete oldUnknownPropertyPaths[knownKey];
                    for (var unknownKey in this.unknownPropertyPaths) oldKnownPropertyPaths[unknownKey] || (oldUnknownPropertyPaths[unknownKey] = !0);
                    errorAtEnd = !1;
                    continue;
                }
                return null;
            }
            error && errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
        }
        return this.trackUnknownProperties && (this.unknownPropertyPaths = oldUnknownPropertyPaths, 
        this.knownPropertyPaths = oldKnownPropertyPaths), errorAtEnd ? (errors = errors.concat(this.errors.slice(startErrorCount)), 
        this.errors = this.errors.slice(0, startErrorCount), this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors)) : void 0;
    }, ValidatorContext.prototype.validateOneOf = function(data, schema, dataPointerPath) {
        if (void 0 === schema.oneOf) return null;
        var oldUnknownPropertyPaths, oldKnownPropertyPaths, validIndex = null, errors = [], startErrorCount = this.errors.length;
        this.trackUnknownProperties && (oldUnknownPropertyPaths = this.unknownPropertyPaths, 
        oldKnownPropertyPaths = this.knownPropertyPaths);
        for (var i = 0; i < schema.oneOf.length; i++) {
            this.trackUnknownProperties && (this.unknownPropertyPaths = {}, this.knownPropertyPaths = {});
            var subSchema = schema.oneOf[i], errorCount = this.errors.length, error = this.validateAll(data, subSchema, [], [ "oneOf", i ], dataPointerPath);
            if (null === error && errorCount === this.errors.length) {
                if (null !== validIndex) return this.errors = this.errors.slice(0, startErrorCount), 
                this.createError(ErrorCodes.ONE_OF_MULTIPLE, {
                    index1: validIndex,
                    index2: i
                }, "", "/oneOf");
                if (validIndex = i, this.trackUnknownProperties) {
                    for (var knownKey in this.knownPropertyPaths) oldKnownPropertyPaths[knownKey] = !0, 
                    delete oldUnknownPropertyPaths[knownKey];
                    for (var unknownKey in this.unknownPropertyPaths) oldKnownPropertyPaths[unknownKey] || (oldUnknownPropertyPaths[unknownKey] = !0);
                }
            } else error && errors.push(error.prefixWith(null, "" + i).prefixWith(null, "oneOf"));
        }
        return this.trackUnknownProperties && (this.unknownPropertyPaths = oldUnknownPropertyPaths, 
        this.knownPropertyPaths = oldKnownPropertyPaths), null === validIndex ? (errors = errors.concat(this.errors.slice(startErrorCount)), 
        this.errors = this.errors.slice(0, startErrorCount), this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors)) : (this.errors = this.errors.slice(0, startErrorCount), 
        null);
    }, ValidatorContext.prototype.validateNot = function(data, schema, dataPointerPath) {
        if (void 0 === schema.not) return null;
        var oldUnknownPropertyPaths, oldKnownPropertyPaths, oldErrorCount = this.errors.length;
        this.trackUnknownProperties && (oldUnknownPropertyPaths = this.unknownPropertyPaths, 
        oldKnownPropertyPaths = this.knownPropertyPaths, this.unknownPropertyPaths = {}, 
        this.knownPropertyPaths = {});
        var error = this.validateAll(data, schema.not, null, null, dataPointerPath), notErrors = this.errors.slice(oldErrorCount);
        return this.errors = this.errors.slice(0, oldErrorCount), this.trackUnknownProperties && (this.unknownPropertyPaths = oldUnknownPropertyPaths, 
        this.knownPropertyPaths = oldKnownPropertyPaths), null === error && 0 === notErrors.length ? this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not") : null;
    };
    var ErrorCodes = {
        INVALID_TYPE: 0,
        ENUM_MISMATCH: 1,
        ANY_OF_MISSING: 10,
        ONE_OF_MISSING: 11,
        ONE_OF_MULTIPLE: 12,
        NOT_PASSED: 13,
        NUMBER_MULTIPLE_OF: 100,
        NUMBER_MINIMUM: 101,
        NUMBER_MINIMUM_EXCLUSIVE: 102,
        NUMBER_MAXIMUM: 103,
        NUMBER_MAXIMUM_EXCLUSIVE: 104,
        STRING_LENGTH_SHORT: 200,
        STRING_LENGTH_LONG: 201,
        STRING_PATTERN: 202,
        OBJECT_PROPERTIES_MINIMUM: 300,
        OBJECT_PROPERTIES_MAXIMUM: 301,
        OBJECT_REQUIRED: 302,
        OBJECT_ADDITIONAL_PROPERTIES: 303,
        OBJECT_DEPENDENCY_KEY: 304,
        ARRAY_LENGTH_SHORT: 400,
        ARRAY_LENGTH_LONG: 401,
        ARRAY_UNIQUE: 402,
        ARRAY_ADDITIONAL_ITEMS: 403,
        FORMAT_CUSTOM: 500,
        KEYWORD_CUSTOM: 501,
        CIRCULAR_REFERENCE: 600,
        UNKNOWN_PROPERTY: 1e3
    }, ErrorCodeLookup = {};
    for (var key in ErrorCodes) ErrorCodeLookup[ErrorCodes[key]] = key;
    var ErrorMessagesDefault = {
        INVALID_TYPE: "invalid type: {type} (expected {expected})",
        ENUM_MISMATCH: "No enum match for: {value}",
        ANY_OF_MISSING: 'Data does not match any schemas from "anyOf"',
        ONE_OF_MISSING: 'Data does not match any schemas from "oneOf"',
        ONE_OF_MULTIPLE: 'Data is valid against more than one schema from "oneOf": indices {index1} and {index2}',
        NOT_PASSED: 'Data matches schema from "not"',
        NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
        NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
        NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
        NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
        NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
        STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
        STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
        STRING_PATTERN: "String does not match pattern: {pattern}",
        OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
        OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
        OBJECT_REQUIRED: "Missing required property: {key}",
        OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
        OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
        ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
        ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
        ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
        ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
        FORMAT_CUSTOM: "Format validation failed ({message})",
        KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
        CIRCULAR_REFERENCE: "Circular $refs: {urls}",
        UNKNOWN_PROPERTY: "Unknown property (not in schema)"
    };
    ValidationError.prototype = Object.create(Error.prototype), ValidationError.prototype.constructor = ValidationError, 
    ValidationError.prototype.name = "ValidationError", ValidationError.prototype.prefixWith = function(dataPrefix, schemaPrefix) {
        if (null !== dataPrefix && (dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1"), 
        this.dataPath = "/" + dataPrefix + this.dataPath), null !== schemaPrefix && (schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1"), 
        this.schemaPath = "/" + schemaPrefix + this.schemaPath), null !== this.subErrors) for (var i = 0; i < this.subErrors.length; i++) this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
        return this;
    };
    var languages = {}, tv4 = createApi();
    return tv4.addLanguage("en-gb", ErrorMessagesDefault), tv4.tv4 = tv4, tv4;
}), !function(undefined) {
    var ObjectPath = {
        parse: function(str) {
            if ("string" != typeof str) throw new TypeError("ObjectPath.parse must be passed a string");
            for (var d, b, q, c, i = 0, parts = []; i < str.length; ) if (d = str.indexOf(".", i), 
            b = str.indexOf("[", i), -1 === d && -1 === b) parts.push(str.slice(i, str.length)), 
            i = str.length; else if (-1 === b || -1 !== d && b > d) parts.push(str.slice(i, d)), 
            i = d + 1; else if (b > i && (parts.push(str.slice(i, b)), i = b), q = str.slice(b + 1, b + 2), 
            '"' !== q && "'" !== q) c = str.indexOf("]", b), -1 === c && (c = str.length), parts.push(str.slice(i + 1, c)), 
            i = "." === str.slice(c + 1, c + 2) ? c + 2 : c + 1; else {
                for (c = str.indexOf(q + "]", b), -1 === c && (c = str.length); "\\" === str.slice(c - 1, c) && b < str.length; ) b++, 
                c = str.indexOf(q + "]", b);
                parts.push(str.slice(i + 2, c).replace(new RegExp("\\" + q, "g"), q)), i = "." === str.slice(c + 2, c + 3) ? c + 3 : c + 2;
            }
            return parts;
        },
        stringify: function(arr, quote) {
            return Array.isArray(arr) || (arr = [ arr.toString() ]), quote = '"' === quote ? '"' : "'", 
            arr.map(function(n) {
                return "[" + quote + n.toString().replace(new RegExp(quote, "g"), "\\" + quote) + quote + "]";
            }).join("");
        },
        normalize: function(data, quote) {
            return ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);
        },
        registerModule: function(angular) {
            angular.module("ObjectPath", []).provider("ObjectPath", function() {
                this.parse = ObjectPath.parse, this.stringify = ObjectPath.stringify, this.normalize = ObjectPath.normalize, 
                this.$get = function() {
                    return ObjectPath;
                };
            });
        }
    };
    "function" == typeof define && define.amd ? define(function() {
        return ObjectPath;
    }) : "object" == typeof exports ? exports.ObjectPath = ObjectPath : window.ObjectPath = ObjectPath;
}(), function(root, factory) {
    "function" == typeof define && define.amd ? define([ "angular", "objectpath", "tv4" ], factory) : "object" == typeof exports ? module.exports = factory(require("angular"), require("objectpath"), require("tv4")) : root.schemaForm = factory(root.angular, root.objectpath, root.tv4);
}(this, function(angular, objectpath, tv4) {
    var deps = [];
    try {
        angular.module("ngSanitize"), deps.push("ngSanitize");
    } catch (e) {}
    try {
        angular.module("ui.sortable"), deps.push("ui.sortable");
    } catch (e) {}
    try {
        angular.module("angularSpectrumColorpicker"), deps.push("angularSpectrumColorpicker");
    } catch (e) {}
    var schemaForm = angular.module("schemaForm", deps);
    return angular.module("schemaForm").provider("sfPath", [ function() {
        var ObjectPath = window.ObjectPath || objectpath, sfPath = {
            parse: ObjectPath.parse
        };
        1 === angular.version.major && angular.version.minor < 3 ? sfPath.stringify = function(arr) {
            return Array.isArray(arr) ? arr.join(".") : arr.toString();
        } : sfPath.stringify = ObjectPath.stringify, sfPath.normalize = function(data, quote) {
            return sfPath.stringify(Array.isArray(data) ? data : sfPath.parse(data), quote);
        }, this.parse = sfPath.parse, this.stringify = sfPath.stringify, this.normalize = sfPath.normalize, 
        this.$get = function() {
            return sfPath;
        };
    } ]), angular.module("schemaForm").factory("sfSelect", [ "sfPath", function(sfPath) {
        var numRe = /^\d+$/;
        return function(projection, obj, valueToSet) {
            obj || (obj = this);
            var parts = "string" == typeof projection ? sfPath.parse(projection) : projection;
            if ("undefined" != typeof valueToSet && 1 === parts.length) return obj[parts[0]] = valueToSet, 
            obj;
            "undefined" != typeof valueToSet && "undefined" == typeof obj[parts[0]] && (obj[parts[0]] = parts.length > 2 && numRe.test(parts[1]) ? [] : {});
            for (var value = obj[parts[0]], i = 1; i < parts.length; i++) {
                if ("" === parts[i]) return void 0;
                if ("undefined" != typeof valueToSet) {
                    if (i === parts.length - 1) return value[parts[i]] = valueToSet, valueToSet;
                    var tmp = value[parts[i]];
                    ("undefined" == typeof tmp || null === tmp) && (tmp = numRe.test(parts[i + 1]) ? [] : {}, 
                    value[parts[i]] = tmp), value = tmp;
                } else value && (value = value[parts[i]]);
            }
            return value;
        };
    } ]), angular.module("schemaForm").provider("sfBuilder", [ "sfPathProvider", function(sfPathProvider) {
        var SNAKE_CASE_REGEXP = /[A-Z]/g, snakeCase = function(name, separator) {
            return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? separator : "") + letter.toLowerCase();
            });
        }, builders = {
            ngModel: function(args) {
                if (args.form.key) {
                    var key = args.form.key;
                    args.state.keyRedaction && (key = key.slice(args.state.keyRedaction));
                    var modelValue;
                    if (args.state.modelValue) modelValue = args.state.modelValue; else {
                        var strKey = sfPathProvider.stringify(key).replace(/"/g, "&quot;");
                        modelValue = args.state.modelName || "model", strKey && (modelValue += ("[" !== strKey[0] ? "." : "") + strKey);
                    }
                    for (var nodes = args.fieldFrag.querySelectorAll("[sf-field-model]"), i = 0; i < nodes.length; i++) {
                        var n = nodes[i], conf = n.getAttribute("sf-field-model");
                        if (conf && "" !== conf) if ("replaceAll" === conf) for (var attributes = n.attributes, j = 0; attributes.length; j++) attributes[j].value && -1 !== attributes[j].value.indexOf("$$value") && (attributes[j].value = attributes[j].value.replace(/\$\$value\$\$/g, modelValue)); else {
                            var val = n.getAttribute(conf);
                            val && val.indexOf("$$value$$") ? n.setAttribute(conf, val.replace(/\$\$value\$\$/g, modelValue)) : n.setAttribute(conf, modelValue);
                        } else n.setAttribute("ng-model", modelValue);
                    }
                }
            },
            simpleTransclusion: function(args) {
                var children = args.build(args.form.items, args.path + ".items", args.state);
                args.fieldFrag.firstChild.appendChild(children);
            },
            ngModelOptions: function(args) {
                args.form.ngModelOptions && Object.keys(args.form.ngModelOptions).length > 0 && args.fieldFrag.firstChild.setAttribute("ng-model-options", JSON.stringify(args.form.ngModelOptions));
            },
            transclusion: function(args) {
                var transclusions = args.fieldFrag.querySelectorAll("[sf-field-transclude]");
                if (transclusions.length) for (var i = 0; i < transclusions.length; i++) {
                    var n = transclusions[i], sub = args.form[n.getAttribute("sf-field-transclude")];
                    if (sub) {
                        sub = Array.isArray(sub) ? sub : [ sub ];
                        var childFrag = args.build(sub, args.path + "." + sub, args.state);
                        n.appendChild(childFrag);
                    }
                }
            }
        };
        this.builders = builders, this.$get = [ "$templateCache", "schemaFormDecorators", "sfPath", function($templateCache, schemaFormDecorators, sfPath) {
            var checkForSlot = function(form, slots) {
                if (form.key) {
                    var slot = slots[sfPath.stringify(form.key)];
                    if (slot) {
                        for (;slot.firstChild; ) slot.removeChild(slot.firstChild);
                        return slot;
                    }
                }
            }, build = function(items, decorator, templateFn, slots, path, state) {
                state = state || {}, path = path || "schemaForm.form";
                var container = document.createDocumentFragment();
                return items.reduce(function(frag, f, index) {
                    if (f.type) {
                        var field = decorator[f.type] || decorator["default"];
                        if (field.replace) {
                            var tmpl, div = document.createElement("div"), template = templateFn(field.template) || templateFn([ decorator["default"].template ]);
                            for (div.innerHTML = template, tmpl = document.createDocumentFragment(); div.childNodes.length > 0; ) tmpl.appendChild(div.childNodes[0]);
                            tmpl.firstChild.setAttribute("sf-field", path + "[" + index + "]");
                            var args = {
                                fieldFrag: tmpl,
                                form: f,
                                state: state,
                                path: path + "[" + index + "]",
                                build: function(items, path, state) {
                                    return build(items, decorator, templateFn, slots, path, state);
                                }
                            };
                            "function" == typeof field.builder ? field.builder(args) : field.builder.forEach(function(fn) {
                                fn(args);
                            }), (checkForSlot(f, slots) || frag).appendChild(tmpl);
                        } else {
                            var n = document.createElement(snakeCase(decorator.__name, "-"));
                            n.setAttribute("form", path + "[" + index + "]"), (checkForSlot(f, slots) || frag).appendChild(n);
                        }
                        return frag;
                    }
                }, container), container;
            };
            return {
                build: function(form, decorator, slots) {
                    return build(form, decorator, function(url) {
                        return $templateCache.get(url);
                    }, slots);
                },
                builder: builders,
                internalBuild: build
            };
        } ];
    } ]), angular.module("schemaForm").provider("schemaFormDecorators", [ "$compileProvider", "sfPathProvider", function($compileProvider, sfPathProvider) {
        var defaultDecorator = "", decorators = {}, templateUrl = function(name, form) {
            "sfDecorator" === name && (name = defaultDecorator);
            var decorator = decorators[name];
            return decorator[form.type] ? decorator[form.type].template : decorator["default"].template;
        }, createDirective = function(name) {
            $compileProvider.directive(name, [ "$parse", "$compile", "$http", "$templateCache", "$interpolate", "$q", "sfErrorMessage", "sfPath", "sfSelect", function($parse, $compile, $http, $templateCache, $interpolate, $q, sfErrorMessage, sfPath, sfSelect) {
                return {
                    restrict: "AE",
                    replace: !1,
                    transclude: !1,
                    scope: !0,
                    require: "?^sfSchema",
                    link: function(scope, element, attrs, sfSchema) {
                        scope.$on("schemaFormPropagateNgModelController", function(event, ngModel) {
                            event.stopPropagation(), event.preventDefault(), scope.ngModel = ngModel;
                        }), scope.showTitle = function() {
                            return scope.form && scope.form.notitle !== !0 && scope.form.title;
                        }, scope.listToCheckboxValues = function(list) {
                            var values = {};
                            return angular.forEach(list, function(v) {
                                values[v] = !0;
                            }), values;
                        }, scope.checkboxValuesToList = function(values) {
                            var lst = [];
                            return angular.forEach(values, function(v, k) {
                                v && lst.push(k);
                            }), lst;
                        }, scope.buttonClick = function($event, form) {
                            angular.isFunction(form.onClick) ? form.onClick($event, form) : angular.isString(form.onClick) && (sfSchema ? sfSchema.evalInParentScope(form.onClick, {
                                $event: $event,
                                form: form
                            }) : scope.$eval(form.onClick, {
                                $event: $event,
                                form: form
                            }));
                        }, scope.evalExpr = function(expression, locals) {
                            return sfSchema ? sfSchema.evalInParentScope(expression, locals) : scope.$eval(expression, locals);
                        }, scope.evalInScope = function(expression, locals) {
                            return expression ? scope.$eval(expression, locals) : void 0;
                        }, scope.interp = function(expression, locals) {
                            return expression && $interpolate(expression)(locals);
                        }, scope.hasSuccess = function() {
                            return scope.ngModel ? scope.ngModel.$valid && (!scope.ngModel.$pristine || !scope.ngModel.$isEmpty(scope.ngModel.$modelValue)) : !1;
                        }, scope.hasError = function() {
                            return scope.ngModel ? scope.ngModel.$invalid && !scope.ngModel.$pristine : !1;
                        }, scope.errorMessage = function(schemaError) {
                            return sfErrorMessage.interpolate(schemaError && schemaError.code + "" || "default", scope.ngModel && scope.ngModel.$modelValue || "", scope.ngModel && scope.ngModel.$viewValue || "", scope.form, scope.options && scope.options.validationMessage);
                        };
                        var once = scope.$watch(attrs.form, function(form) {
                            if (form) {
                                form.ngModelOptions = form.ngModelOptions || {}, scope.form = form;
                                var templatePromise;
                                if ("template" === form.type && form.template) templatePromise = $q.when(form.template); else {
                                    var url = "template" === form.type ? form.templateUrl : templateUrl(name, form);
                                    templatePromise = $http.get(url, {
                                        cache: $templateCache
                                    }).then(function(res) {
                                        return res.data;
                                    });
                                }
                                templatePromise.then(function(template) {
                                    if (form.key) {
                                        var key = form.key ? sfPathProvider.stringify(form.key).replace(/"/g, "&quot;") : "";
                                        template = template.replace(/\$\$value\$\$/g, "model" + ("[" !== key[0] ? "." : "") + key);
                                    }
                                    if (element.html(template), form.condition) {
                                        var evalExpr = 'evalExpr(form.condition,{ model: model, "arrayIndex": arrayIndex})';
                                        form.key && (evalExpr = 'evalExpr(form.condition,{ model: model, "arrayIndex": arrayIndex, "modelValue": model' + sfPath.stringify(form.key) + "})"), 
                                        angular.forEach(element.children(), function(child) {
                                            var ngIf = child.getAttribute("ng-if");
                                            child.setAttribute("ng-if", ngIf ? "(" + ngIf + ") || (" + evalExpr + ")" : evalExpr);
                                        });
                                    }
                                    $compile(element.contents())(scope);
                                }), form.key && (scope.$on("schemaForm.error." + form.key.join("."), function(event, error, validationMessage, validity) {
                                    (validationMessage === !0 || validationMessage === !1) && (validity = validationMessage, 
                                    validationMessage = void 0), scope.ngModel && error && (scope.ngModel.$setDirty ? scope.ngModel.$setDirty() : (scope.ngModel.$dirty = !0, 
                                    scope.ngModel.$pristine = !1), validationMessage && (form.validationMessage || (form.validationMessage = {}), 
                                    form.validationMessage[error] = validationMessage), scope.ngModel.$setValidity(error, validity === !0), 
                                    validity === !0 && scope.$broadcast("schemaFormValidate"));
                                }), scope.$on("$destroy", function() {
                                    if (!scope.externalDestructionInProgress) {
                                        var destroyStrategy = form.destroyStrategy || scope.options && scope.options.destroyStrategy || "remove";
                                        if (form.key && "retain" !== destroyStrategy) {
                                            var obj = scope.model;
                                            if (form.key.length > 1 && (obj = sfSelect(form.key.slice(0, form.key.length - 1), obj)), 
                                            void 0 === obj) return;
                                            var type = form.schema && form.schema.type || "";
                                            "empty" === destroyStrategy && -1 !== type.indexOf("string") ? obj[form.key.slice(-1)] = "" : "empty" === destroyStrategy && -1 !== type.indexOf("object") ? obj[form.key.slice(-1)] = {} : "empty" === destroyStrategy && -1 !== type.indexOf("array") ? obj[form.key.slice(-1)] = [] : "null" === destroyStrategy ? obj[form.key.slice(-1)] = null : delete obj[form.key.slice(-1)];
                                        }
                                    }
                                })), once();
                            }
                        });
                    }
                };
            } ]);
        }, createManualDirective = function(type, templateUrl, transclude) {
            transclude = angular.isDefined(transclude) ? transclude : !1, $compileProvider.directive("sf" + angular.uppercase(type[0]) + type.substr(1), function() {
                return {
                    restrict: "EAC",
                    scope: !0,
                    replace: !0,
                    transclude: transclude,
                    template: '<sf-decorator form="form"></sf-decorator>',
                    link: function(scope, element, attrs) {
                        var watchThis = {
                            items: "c",
                            titleMap: "c",
                            schema: "c"
                        }, form = {
                            type: type
                        }, once = !0;
                        angular.forEach(attrs, function(value, name) {
                            if ("$" !== name[0] && 0 !== name.indexOf("ng") && "sfField" !== name) {
                                var updateForm = function(val) {
                                    angular.isDefined(val) && val !== form[name] && (form[name] = val, once && form.type && (form.key || angular.isUndefined(attrs.key)) && (scope.form = form, 
                                    once = !1));
                                };
                                "model" === name ? scope.$watch(value, function(val) {
                                    val && scope.model !== val && (scope.model = val);
                                }) : "c" === watchThis[name] ? scope.$watchCollection(value, updateForm) : attrs.$observe(name, updateForm);
                            }
                        });
                    }
                };
            });
        };
        this.createDecorator = function(name, templates) {
            decorators[name] = {
                __name: name
            }, angular.forEach(templates, function(url, type) {
                decorators[name][type] = {
                    template: url,
                    replace: !1,
                    builder: []
                };
            }), decorators[defaultDecorator] || (defaultDecorator = name), createDirective(name);
        }, this.defineDecorator = function(name, fields) {
            decorators[name] = {
                __name: name
            }, angular.forEach(fields, function(field, type) {
                field.builder = field.builder || [], field.replace = angular.isDefined(field.replace) ? field.replace : !0, 
                decorators[name][type] = field;
            }), decorators[defaultDecorator] || (defaultDecorator = name), createDirective(name);
        }, this.createDirective = createManualDirective, this.createDirectives = function(templates) {
            angular.forEach(templates, function(url, type) {
                createManualDirective(type, url);
            });
        }, this.decorator = function(name) {
            return name = name || defaultDecorator, decorators[name];
        }, this.addMapping = function(name, type, url, builder, replace) {
            decorators[name] && (decorators[name][type] = {
                template: url,
                builder: builder,
                replace: !!replace
            });
        }, this.$get = function() {
            return {
                decorator: function(name) {
                    return decorators[name] || decorators[defaultDecorator];
                },
                defaultDecorator: defaultDecorator
            };
        }, createDirective("sfDecorator");
    } ]), angular.module("schemaForm").provider("sfErrorMessage", function() {
        var defaultMessages = {
            "default": "Field does not validate",
            0: "Invalid type, expected {{schema.type}}",
            1: "No enum match for: {{viewValue}}",
            10: 'Data does not match any schemas from "anyOf"',
            11: 'Data does not match any schemas from "oneOf"',
            12: 'Data is valid against more than one schema from "oneOf"',
            13: 'Data matches schema from "not"',
            100: "Value is not a multiple of {{schema.divisibleBy}}",
            101: "{{viewValue}} is less than the allowed minimum of {{schema.minimum}}",
            102: "{{viewValue}} is equal to the exclusive minimum {{schema.minimum}}",
            103: "{{viewValue}} is greater than the allowed maximum of {{schema.maximum}}",
            104: "{{viewValue}} is equal to the exclusive maximum {{schema.maximum}}",
            105: "Value is not a valid number",
            200: "String is too short ({{viewValue.length}} chars), minimum {{schema.minLength}}",
            201: "String is too long ({{viewValue.length}} chars), maximum {{schema.maxLength}}",
            202: "String does not match pattern: {{schema.pattern}}",
            300: "Too few properties defined, minimum {{schema.minProperties}}",
            301: "Too many properties defined, maximum {{schema.maxProperties}}",
            302: "Required",
            303: "Additional properties not allowed",
            304: "Dependency failed - key must exist",
            400: "Array is too short ({{value.length}}), minimum {{schema.minItems}}",
            401: "Array is too long ({{value.length}}), maximum {{schema.maxItems}}",
            402: "Array items are not unique",
            403: "Additional items not allowed",
            500: "Format validation failed",
            501: 'Keyword failed: "{{title}}"',
            600: "Circular $refs",
            1e3: "Unknown property (not in schema)"
        };
        defaultMessages.number = defaultMessages[105], defaultMessages.required = defaultMessages[302], 
        defaultMessages.min = defaultMessages[101], defaultMessages.max = defaultMessages[103], 
        defaultMessages.maxlength = defaultMessages[201], defaultMessages.minlength = defaultMessages[200], 
        defaultMessages.pattern = defaultMessages[202], this.setDefaultMessages = function(messages) {
            defaultMessages = messages;
        }, this.getDefaultMessages = function() {
            return defaultMessages;
        }, this.setDefaultMessage = function(error, msg) {
            defaultMessages[error] = msg;
        }, this.$get = [ "$interpolate", function($interpolate) {
            var service = {};
            return service.defaultMessages = defaultMessages, service.interpolate = function(error, value, viewValue, form, global) {
                global = global || {};
                var validationMessage = form.validationMessage || {};
                0 === error.indexOf("tv4-") && (error = error.substring(4));
                var message = validationMessage["default"] || global["default"] || "";
                [ validationMessage, global, defaultMessages ].some(function(val) {
                    return angular.isString(val) || angular.isFunction(val) ? (message = val, !0) : val && val[error] ? (message = val[error], 
                    !0) : void 0;
                });
                var context = {
                    error: error,
                    value: value,
                    viewValue: viewValue,
                    form: form,
                    schema: form.schema,
                    title: form.title || form.schema && form.schema.title
                };
                return angular.isFunction(message) ? message(context) : $interpolate(message)(context);
            }, service;
        } ];
    }), angular.module("schemaForm").provider("schemaForm", [ "sfPathProvider", function(sfPathProvider) {
        var stripNullType = function(type) {
            if (Array.isArray(type) && 2 == type.length) {
                if ("null" === type[0]) return type[1];
                if ("null" === type[1]) return type[0];
            }
            return type;
        }, enumToTitleMap = function(enm) {
            var titleMap = [];
            return enm.forEach(function(name) {
                titleMap.push({
                    name: name,
                    value: name
                });
            }), titleMap;
        }, canonicalTitleMap = function(titleMap, originalEnum) {
            if (!angular.isArray(titleMap)) {
                var canonical = [];
                return originalEnum ? angular.forEach(originalEnum, function(value, index) {
                    canonical.push({
                        name: titleMap[value],
                        value: value
                    });
                }) : angular.forEach(titleMap, function(name, value) {
                    canonical.push({
                        name: name,
                        value: value
                    });
                }), canonical;
            }
            return titleMap;
        }, defaultFormDefinition = function(name, schema, options) {
            var rules = defaults[stripNullType(schema.type)];
            if (rules) for (var def, i = 0; i < rules.length; i++) if (def = rules[i](name, schema, options)) return def.schema["x-schema-form"] && angular.isObject(def.schema["x-schema-form"]) && (def = angular.extend(def, def.schema["x-schema-form"])), 
            def;
        }, stdFormObj = function(name, schema, options) {
            options = options || {};
            var f = options.global && options.global.formDefaults ? angular.copy(options.global.formDefaults) : {};
            return options.global && options.global.supressPropertyTitles === !0 ? f.title = schema.title : f.title = schema.title || name, 
            schema.description && (f.description = schema.description), (options.required === !0 || schema.required === !0) && (f.required = !0), 
            schema.maxLength && (f.maxlength = schema.maxLength), schema.minLength && (f.minlength = schema.maxLength), 
            (schema.readOnly || schema.readonly) && (f.readonly = !0), schema.minimum && (f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0)), 
            schema.maximum && (f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0)), 
            schema.validationMessage && (f.validationMessage = schema.validationMessage), schema.enumNames && (f.titleMap = canonicalTitleMap(schema.enumNames, schema["enum"])), 
            f.schema = schema, f.ngModelOptions = f.ngModelOptions || {}, f;
        }, text = function(name, schema, options) {
            if ("string" === stripNullType(schema.type) && !schema["enum"]) {
                var f = stdFormObj(name, schema, options);
                return f.key = options.path, f.type = "text", options.lookup[sfPathProvider.stringify(options.path)] = f, 
                f;
            }
        }, number = function(name, schema, options) {
            if ("number" === stripNullType(schema.type)) {
                var f = stdFormObj(name, schema, options);
                return f.key = options.path, f.type = "number", options.lookup[sfPathProvider.stringify(options.path)] = f, 
                f;
            }
        }, integer = function(name, schema, options) {
            if ("integer" === stripNullType(schema.type)) {
                var f = stdFormObj(name, schema, options);
                return f.key = options.path, f.type = "number", options.lookup[sfPathProvider.stringify(options.path)] = f, 
                f;
            }
        }, checkbox = function(name, schema, options) {
            if ("boolean" === stripNullType(schema.type)) {
                var f = stdFormObj(name, schema, options);
                return f.key = options.path, f.type = "checkbox", options.lookup[sfPathProvider.stringify(options.path)] = f, 
                f;
            }
        }, select = function(name, schema, options) {
            if ("string" === stripNullType(schema.type) && schema["enum"]) {
                var f = stdFormObj(name, schema, options);
                return f.key = options.path, f.type = "select", f.titleMap || (f.titleMap = enumToTitleMap(schema["enum"])), 
                f.trackBy = "value", options.lookup[sfPathProvider.stringify(options.path)] = f, 
                f;
            }
        }, checkboxes = function(name, schema, options) {
            if ("array" === stripNullType(schema.type) && schema.items && schema.items["enum"]) {
                var f = stdFormObj(name, schema, options);
                return f.key = options.path, f.type = "checkboxes", f.titleMap || (f.titleMap = enumToTitleMap(schema.items["enum"])), 
                options.lookup[sfPathProvider.stringify(options.path)] = f, f;
            }
        }, fieldset = function(name, schema, options) {
            if ("object" === stripNullType(schema.type)) {
                var f = stdFormObj(name, schema, options);
                return f.type = "fieldset", f.items = [], options.lookup[sfPathProvider.stringify(options.path)] = f, 
                angular.forEach(schema.properties, function(v, k) {
                    var path = options.path.slice();
                    if (path.push(k), options.ignore[sfPathProvider.stringify(path)] !== !0) {
                        var required = schema.required && -1 !== schema.required.indexOf(k), def = defaultFormDefinition(k, v, {
                            path: path,
                            required: required || !1,
                            lookup: options.lookup,
                            ignore: options.ignore,
                            global: options.global
                        });
                        def && f.items.push(def);
                    }
                }), f;
            }
        }, array = function(name, schema, options) {
            if ("array" === stripNullType(schema.type)) {
                var f = stdFormObj(name, schema, options);
                f.type = "array", f.key = options.path, options.lookup[sfPathProvider.stringify(options.path)] = f;
                var required = schema.required && -1 !== schema.required.indexOf(options.path[options.path.length - 1]), arrPath = options.path.slice();
                return arrPath.push(""), f.items = [ defaultFormDefinition(name, schema.items, {
                    path: arrPath,
                    required: required || !1,
                    lookup: options.lookup,
                    ignore: options.ignore,
                    global: options.global
                }) ], f;
            }
        }, defaults = {
            string: [ select, text ],
            object: [ fieldset ],
            number: [ number ],
            integer: [ integer ],
            "boolean": [ checkbox ],
            array: [ checkboxes, array ]
        }, postProcessFn = function(form) {
            return form;
        };
        this.defaults = defaults, this.stdFormObj = stdFormObj, this.defaultFormDefinition = defaultFormDefinition, 
        this.postProcess = function(fn) {
            postProcessFn = fn;
        }, this.appendRule = function(type, rule) {
            defaults[type] || (defaults[type] = []), defaults[type].push(rule);
        }, this.prependRule = function(type, rule) {
            defaults[type] || (defaults[type] = []), defaults[type].unshift(rule);
        }, this.createStandardForm = stdFormObj, this.$get = function() {
            var service = {};
            return service.merge = function(schema, form, ignore, options, readonly) {
                form = form || [ "*" ], options = options || {}, readonly = readonly || schema.readonly || schema.readOnly;
                var stdForm = service.defaults(schema, ignore, options), idx = form.indexOf("*");
                -1 !== idx && (form = form.slice(0, idx).concat(stdForm.form).concat(form.slice(idx + 1)));
                var lookup = stdForm.lookup;
                return postProcessFn(form.map(function(obj) {
                    if ("string" == typeof obj && (obj = {
                        key: obj
                    }), obj.key && "string" == typeof obj.key && (obj.key = sfPathProvider.parse(obj.key)), 
                    obj.titleMap && (obj.titleMap = canonicalTitleMap(obj.titleMap)), "select" === obj.type && (obj.trackBy = obj.trackBy || "value"), 
                    obj.itemForm) {
                        obj.items = [];
                        var str = sfPathProvider.stringify(obj.key), stdForm = lookup[str];
                        angular.forEach(stdForm.items, function(item) {
                            var o = angular.copy(obj.itemForm);
                            o.key = item.key, obj.items.push(o);
                        });
                    }
                    if (obj.key) {
                        var strid = sfPathProvider.stringify(obj.key);
                        if (lookup[strid]) {
                            var schemaDefaults = lookup[strid];
                            angular.forEach(schemaDefaults, function(value, attr) {
                                void 0 === obj[attr] && (obj[attr] = schemaDefaults[attr]);
                            });
                        }
                    }
                    return readonly === !0 && (obj.readonly = !0), obj.items && (obj.items = service.merge(schema, obj.items, ignore, options, obj.readonly)), 
                    obj.tabs && angular.forEach(obj.tabs, function(tab) {
                        tab.items = service.merge(schema, tab.items, ignore, options, obj.readonly);
                    }), "checkbox" === obj.type && angular.isUndefined(obj.schema["default"]) && (obj.schema["default"] = !1), 
                    obj;
                }));
            }, service.defaults = function(schema, ignore, globalOptions) {
                var form = [], lookup = {};
                if (ignore = ignore || {}, globalOptions = globalOptions || {}, "object" !== stripNullType(schema.type)) throw new Error('Not implemented. Only type "object" allowed at root level of schema.');
                return angular.forEach(schema.properties, function(v, k) {
                    if (ignore[k] !== !0) {
                        var required = schema.required && -1 !== schema.required.indexOf(k), def = defaultFormDefinition(k, v, {
                            path: [ k ],
                            lookup: lookup,
                            ignore: ignore,
                            required: required,
                            global: globalOptions
                        });
                        def && form.push(def);
                    }
                }), {
                    form: form,
                    lookup: lookup
                };
            }, service.traverseSchema = function(schema, fn, path, ignoreArrays) {
                ignoreArrays = angular.isDefined(ignoreArrays) ? ignoreArrays : !0, path = path || [];
                var traverse = function(schema, fn, path) {
                    if (fn(schema, path), angular.forEach(schema.properties, function(prop, name) {
                        var currentPath = path.slice();
                        currentPath.push(name), traverse(prop, fn, currentPath);
                    }), !ignoreArrays && schema.items) {
                        var arrPath = path.slice();
                        arrPath.push(""), traverse(schema.items, fn, arrPath);
                    }
                };
                traverse(schema, fn, path || []);
            }, service.traverseForm = function(form, fn) {
                fn(form), angular.forEach(form.items, function(f) {
                    service.traverseForm(f, fn);
                }), form.tabs && angular.forEach(form.tabs, function(tab) {
                    angular.forEach(tab.items, function(f) {
                        service.traverseForm(f, fn);
                    });
                });
            }, service;
        };
    } ]), angular.module("schemaForm").factory("sfValidator", [ function() {
        var validator = {};
        return validator.validate = function(form, value) {
            if (!form) return {
                valid: !0
            };
            var schema = form.schema;
            if (!schema) return {
                valid: !0
            };
            "" === value && (value = void 0), "number" === form.type && null === value && (value = void 0);
            var wrap = {
                type: "object",
                properties: {}
            }, propName = form.key[form.key.length - 1];
            wrap.properties[propName] = schema, form.required && (wrap.required = [ propName ]);
            var valueWrap = {};
            return angular.isDefined(value) && (valueWrap[propName] = value), tv4.validateResult(valueWrap, wrap);
        }, validator;
    } ]), angular.module("schemaForm").directive("sfArray", [ "sfSelect", "schemaForm", "sfValidator", "sfPath", function(sfSelect, schemaForm, sfValidator, sfPath) {
        var setIndex = function(index) {
            return function(form) {
                form.key && (form.key[form.key.indexOf("")] = index);
            };
        };
        return {
            restrict: "A",
            scope: !0,
            require: "?ngModel",
            link: function(scope, element, attrs, ngModel) {
                var formDefCache = {};
                scope.validateArray = angular.noop, ngModel && scope.$emit("schemaFormPropagateNgModelController", ngModel);
                var once = scope.$watch(attrs.sfArray, function(form) {
                    var list = sfSelect(form.key, scope.model);
                    if (scope.$watch("model" + sfPath.normalize(form.key), function(value) {
                        list = scope.modelArray = value;
                    }), angular.isUndefined(list) && (list = [], sfSelect(form.key, scope.model, list)), 
                    scope.modelArray = list, form.items) {
                        var subForm = form.items[0];
                        form.items.length > 1 && (subForm = {
                            type: "section",
                            items: form.items.map(function(item) {
                                return item.ngModelOptions = form.ngModelOptions, angular.isUndefined(item.readonly) && (item.readonly = form.readonly), 
                                item;
                            })
                        });
                    }
                    if (scope.copyWithIndex = function(index) {
                        if (!formDefCache[index] && subForm) {
                            var copy = angular.copy(subForm);
                            copy.arrayIndex = index, schemaForm.traverseForm(copy, setIndex(index)), formDefCache[index] = copy;
                        }
                        return formDefCache[index];
                    }, scope.appendToArray = function() {
                        var len = list.length, copy = scope.copyWithIndex(len);
                        if (schemaForm.traverseForm(copy, function(part) {
                            if (part.key) {
                                var def;
                                angular.isDefined(part["default"]) && (def = part["default"]), angular.isDefined(part.schema) && angular.isDefined(part.schema["default"]) && (def = part.schema["default"]), 
                                angular.isDefined(def) && sfSelect(part.key, scope.model, def);
                            }
                        }), len === list.length) {
                            var dflt, type = sfSelect("schema.items.type", form);
                            "object" === type ? dflt = {} : "array" === type && (dflt = []), list.push(dflt);
                        }
                        return scope.validateArray(), list;
                    }, scope.deleteFromArray = function(index) {
                        return list.splice(index, 1), scope.validateArray(), ngModel && ngModel.$setDirty && ngModel.$setDirty(), 
                        list;
                    }, form.titleMap || form.startEmpty === !0 || 0 !== list.length || scope.appendToArray(), 
                    form.titleMap && form.titleMap.length > 0) {
                        scope.titleMapValues = [];
                        var updateTitleMapValues = function(arr) {
                            scope.titleMapValues = [], arr = arr || [], form.titleMap.forEach(function(item) {
                                scope.titleMapValues.push(-1 !== arr.indexOf(item.value));
                            });
                        };
                        updateTitleMapValues(scope.modelArray), scope.$watchCollection("modelArray", updateTitleMapValues), 
                        scope.$watchCollection("titleMapValues", function(vals, old) {
                            if (vals && vals !== old) {
                                for (var arr = scope.modelArray; arr.length > 0; ) arr.pop();
                                form.titleMap.forEach(function(item, index) {
                                    vals[index] && arr.push(item.value);
                                }), scope.validateArray();
                            }
                        });
                    }
                    if (ngModel) {
                        var error;
                        scope.validateArray = function() {
                            var result = sfValidator.validate(form, scope.modelArray.length > 0 ? scope.modelArray : void 0);
                            Object.keys(ngModel.$error).filter(function(k) {
                                return 0 === k.indexOf("tv4-");
                            }).forEach(function(k) {
                                ngModel.$setValidity(k, !0);
                            }), result.valid !== !1 || !result.error || "" !== result.error.dataPath && result.error.dataPath !== "/" + form.key[form.key.length - 1] || (ngModel.$setViewValue(scope.modelArray), 
                            error = result.error, ngModel.$setValidity("tv4-" + result.error.code, !1));
                        }, scope.$on("schemaFormValidate", scope.validateArray), scope.hasSuccess = function() {
                            return ngModel.$valid && !ngModel.$pristine;
                        }, scope.hasError = function() {
                            return ngModel.$invalid;
                        }, scope.schemaError = function() {
                            return error;
                        };
                    }
                    once();
                });
            }
        };
    } ]), angular.module("schemaForm").directive("sfChanged", function() {
        return {
            require: "ngModel",
            restrict: "AC",
            scope: !1,
            link: function(scope, element, attrs, ctrl) {
                var form = scope.$eval(attrs.sfChanged);
                form && form.onChange && ctrl.$viewChangeListeners.push(function() {
                    angular.isFunction(form.onChange) ? form.onChange(ctrl.$modelValue, form) : scope.evalExpr(form.onChange, {
                        modelValue: ctrl.$modelValue,
                        form: form
                    });
                });
            }
        };
    }), angular.module("schemaForm").directive("sfField", [ "$parse", "$compile", "$http", "$templateCache", "$interpolate", "$q", "sfErrorMessage", "sfPath", "sfSelect", function($parse, $compile, $http, $templateCache, $interpolate, $q, sfErrorMessage, sfPath, sfSelect) {
        return {
            restrict: "AE",
            replace: !1,
            transclude: !1,
            scope: !0,
            require: "?^sfSchema",
            link: {
                pre: function(scope) {
                    scope.$on("schemaFormPropagateNgModelController", function(event, ngModel) {
                        event.stopPropagation(), event.preventDefault(), scope.ngModel = ngModel;
                    }), scope.form = null;
                },
                post: function(scope, element, attrs, sfSchema) {
                    scope.showTitle = function() {
                        return scope.form && scope.form.notitle !== !0 && scope.form.title;
                    }, scope.listToCheckboxValues = function(list) {
                        var values = {};
                        return angular.forEach(list, function(v) {
                            values[v] = !0;
                        }), values;
                    }, scope.checkboxValuesToList = function(values) {
                        var lst = [];
                        return angular.forEach(values, function(v, k) {
                            v && lst.push(k);
                        }), lst;
                    }, scope.buttonClick = function($event, form) {
                        angular.isFunction(form.onClick) ? form.onClick($event, form) : angular.isString(form.onClick) && (sfSchema ? sfSchema.evalInParentScope(form.onClick, {
                            $event: $event,
                            form: form
                        }) : scope.$eval(form.onClick, {
                            $event: $event,
                            form: form
                        }));
                    }, scope.evalExpr = function(expression, locals) {
                        return sfSchema ? sfSchema.evalInParentScope(expression, locals) : scope.$eval(expression, locals);
                    }, scope.evalInScope = function(expression, locals) {
                        return expression ? scope.$eval(expression, locals) : void 0;
                    }, scope.interp = function(expression, locals) {
                        return expression && $interpolate(expression)(locals);
                    }, scope.hasSuccess = function() {
                        return scope.ngModel ? scope.ngModel.$valid && (!scope.ngModel.$pristine || !scope.ngModel.$isEmpty(scope.ngModel.$modelValue)) : !1;
                    }, scope.hasError = function() {
                        return scope.ngModel ? scope.ngModel.$invalid && !scope.ngModel.$pristine : !1;
                    }, scope.errorMessage = function(schemaError) {
                        return sfErrorMessage.interpolate(schemaError && schemaError.code + "" || "default", scope.ngModel && scope.ngModel.$modelValue || "", scope.ngModel && scope.ngModel.$viewValue || "", scope.form, scope.options && scope.options.validationMessage);
                    };
                    var once = scope.$watch(attrs.sfField, function(form) {
                        form && (form.ngModelOptions = form.ngModelOptions || {}, scope.form = form, form.key && (scope.$on("schemaForm.error." + form.key.join("."), function(event, error, validationMessage, validity) {
                            (validationMessage === !0 || validationMessage === !1) && (validity = validationMessage, 
                            validationMessage = void 0), scope.ngModel && error && (scope.ngModel.$setDirty ? scope.ngModel.$setDirty() : (scope.ngModel.$dirty = !0, 
                            scope.ngModel.$pristine = !1), validationMessage && (form.validationMessage || (form.validationMessage = {}), 
                            form.validationMessage[error] = validationMessage), scope.ngModel.$setValidity(error, validity === !0), 
                            validity === !0 && scope.$broadcast("schemaFormValidate"));
                        }), scope.$on("$destroy", function() {
                            if (!scope.externalDestructionInProgress) {
                                var destroyStrategy = form.destroyStrategy || scope.options && scope.options.destroyStrategy || "remove";
                                if (form.key && "retain" !== destroyStrategy) {
                                    var obj = scope.model;
                                    if (form.key.length > 1 && (obj = sfSelect(form.key.slice(0, form.key.length - 1), obj)), 
                                    void 0 === obj) return;
                                    var type = form.schema && form.schema.type || "";
                                    "empty" === destroyStrategy && -1 !== type.indexOf("string") ? obj[form.key.slice(-1)] = "" : "empty" === destroyStrategy && -1 !== type.indexOf("object") ? obj[form.key.slice(-1)] = {} : "empty" === destroyStrategy && -1 !== type.indexOf("array") ? obj[form.key.slice(-1)] = [] : "null" === destroyStrategy ? obj[form.key.slice(-1)] = null : delete obj[form.key.slice(-1)];
                                }
                            }
                        })), once());
                    });
                }
            }
        };
    } ]), angular.module("schemaForm").directive("sfMessage", [ "$injector", "sfErrorMessage", function($injector, sfErrorMessage) {
        return {
            scope: !1,
            restrict: "EA",
            link: function(scope, element, attrs) {
                var $sanitize = $injector.has("$sanitize") ? $injector.get("$sanitize") : function(html) {
                    return html;
                }, message = "";
                attrs.sfMessage && scope.$watch(attrs.sfMessage, function(msg) {
                    msg && (message = $sanitize(msg), scope.ngModel ? update(scope.ngModel.$valid) : update());
                });
                var update = function(valid) {
                    if (valid && !scope.hasError()) element.html(message); else {
                        var errors = [];
                        angular.forEach(scope.ngModel && scope.ngModel.$error || {}, function(status, code) {
                            status && errors.push(code);
                        }), errors = errors.filter(function(e) {
                            return "schemaForm" !== e;
                        });
                        var error = errors[0];
                        error ? element.html(sfErrorMessage.interpolate(error, scope.ngModel.$modelValue, scope.ngModel.$viewValue, scope.form, scope.options && scope.options.validationMessage)) : element.html(message);
                    }
                };
                update(), scope.$watchCollection("ngModel.$error", function() {
                    scope.ngModel && update(scope.ngModel.$valid);
                });
            }
        };
    } ]), angular.module("schemaForm").directive("sfSchema", [ "$compile", "schemaForm", "schemaFormDecorators", "sfSelect", "sfPath", "sfBuilder", function($compile, schemaForm, schemaFormDecorators, sfSelect, sfPath, sfBuilder) {
        return {
            scope: {
                schema: "=sfSchema",
                initialForm: "=sfForm",
                model: "=sfModel",
                options: "=sfOptions"
            },
            controller: [ "$scope", function($scope) {
                this.evalInParentScope = function(expr, locals) {
                    return $scope.$parent.$eval(expr, locals);
                };
            } ],
            replace: !1,
            restrict: "A",
            transclude: !0,
            require: "?form",
            link: function(scope, element, attrs, formCtrl, transclude) {
                scope.formCtrl = formCtrl;
                var ignore = {};
                transclude(scope, function(clone) {
                    if (clone.addClass("schema-form-ignore"), element.prepend(clone), element[0].querySelectorAll) {
                        var models = element[0].querySelectorAll("[ng-model]");
                        if (models) for (var i = 0; i < models.length; i++) {
                            var key = models[i].getAttribute("ng-model");
                            ignore[key.substring(key.indexOf(".") + 1)] = !0;
                        }
                    }
                });
                var childScope, lastDigest = {}, render = function(schema, form) {
                    var merged = schemaForm.merge(schema, form, ignore, scope.options);
                    childScope && (scope.externalDestructionInProgress = !0, childScope.$destroy(), 
                    scope.externalDestructionInProgress = !1), childScope = scope.$new(), childScope.schemaForm = {
                        form: merged,
                        schema: schema
                    }, element.children(":not(.schema-form-ignore)").remove();
                    for (var slots = {}, slotsFound = element[0].querySelectorAll("*[sf-insert-field]"), i = 0; i < slotsFound.length; i++) slots[slotsFound[i].getAttribute("sf-insert-field")] = slotsFound[i];
                    var decorator = schemaFormDecorators.decorator(attrs.sfUseDecorator);
                    element[0].appendChild(sfBuilder.build(merged, decorator, slots)), $compile(element.children())(childScope), 
                    scope.options && scope.options.setSchemaDefaults === !1 || schemaForm.traverseSchema(schema, function(prop, path) {
                        if (angular.isDefined(prop["default"])) {
                            var val = sfSelect(path, scope.model);
                            angular.isUndefined(val) && sfSelect(path, scope.model, prop["default"]);
                        }
                    }), scope.$emit("sf-render-finished", element);
                };
                scope.$watch(function() {
                    var schema = scope.schema, form = scope.initialForm || [ "*" ];
                    form && schema && schema.type && (lastDigest.form !== form || lastDigest.schema !== schema) && Object.keys(schema.properties).length > 0 && (lastDigest.schema = schema, 
                    lastDigest.form = form, render(schema, form));
                }), scope.$on("schemaFormRedraw", function() {
                    var schema = scope.schema, form = scope.initialForm || [ "*" ];
                    schema && render(schema, form);
                }), scope.$on("$destroy", function() {
                    scope.externalDestructionInProgress = !0;
                });
            }
        };
    } ]), angular.module("schemaForm").directive("schemaValidate", [ "sfValidator", "$parse", "sfSelect", function(sfValidator, $parse, sfSelect) {
        return {
            restrict: "A",
            scope: !1,
            priority: 500,
            require: "ngModel",
            link: function(scope, element, attrs, ngModel) {
                scope.$emit("schemaFormPropagateNgModelController", ngModel);
                var error = null, once = scope.$watch(attrs.schemaValidate, function(form) {
                    if (form) {
                        form.copyValueTo && ngModel.$viewChangeListeners.push(function() {
                            var paths = form.copyValueTo;
                            angular.forEach(paths, function(path) {
                                sfSelect(path, scope.model, ngModel.$modelValue);
                            });
                        });
                        var validate = function(viewValue) {
                            if (!form) return viewValue;
                            if (scope.options && scope.options.tv4Validation === !1) return viewValue;
                            var result = sfValidator.validate(form, viewValue);
                            return Object.keys(ngModel.$error).filter(function(k) {
                                return 0 === k.indexOf("tv4-");
                            }).forEach(function(k) {
                                ngModel.$setValidity(k, !0);
                            }), result.valid ? viewValue : (ngModel.$setValidity("tv4-" + result.error.code, !1), 
                            error = result.error, ngModel.$validators ? viewValue : void 0);
                        };
                        "function" == typeof form.ngModel && form.ngModel(ngModel), [ "$parsers", "$viewChangeListeners", "$formatters" ].forEach(function(attr) {
                            form[attr] && ngModel[attr] && form[attr].forEach(function(fn) {
                                ngModel[attr].push(fn);
                            });
                        }), [ "$validators", "$asyncValidators" ].forEach(function(attr) {
                            form[attr] && ngModel[attr] && angular.forEach(form[attr], function(fn, name) {
                                ngModel[attr][name] = fn;
                            });
                        }), ngModel.$parsers.push(validate), ngModel.$validators && (ngModel.$validators.schemaForm = function() {
                            return !Object.keys(ngModel.$error).some(function(e) {
                                return "schemaForm" !== e;
                            });
                        }), scope.$on("schemaFormValidate", function() {
                            ngModel.$setDirty ? (ngModel.$setDirty(), ngModel.$setViewValue(ngModel.$viewValue), 
                            ngModel.$commitViewValue(), form.required && ngModel.$isEmpty(ngModel.$modelValue) && ngModel.$setValidity("tv4-302", !1)) : ngModel.$setViewValue(ngModel.$viewValue);
                        }), scope.schemaError = function() {
                            return error;
                        }, once();
                    }
                });
            }
        };
    } ]), schemaForm;
}), angular.module("schemaForm").run([ "$templateCache", function($templateCache) {
    $templateCache.put("directives/decorators/bootstrap/actions-trcl.html", '<div class="btn-group schema-form-actions {{form.htmlClass}}" ng-transclude=""></div>'), 
    $templateCache.put("directives/decorators/bootstrap/actions.html", '<div class="btn-group schema-form-actions {{form.htmlClass}}"><input ng-repeat-start="item in form.items" type="submit" class="btn {{ item.style || \'btn-default\' }} {{form.fieldHtmlClass}}" value="{{item.title}}" ng-if="item.type === \'submit\'"> <button ng-repeat-end="" class="btn {{ item.style || \'btn-default\' }} {{form.fieldHtmlClass}}" type="button" ng-disabled="form.readonly" ng-if="item.type !== \'submit\'" ng-click="buttonClick($event,item)"><span ng-if="item.icon" class="{{item.icon}}"></span>{{item.title}}</button></div>'), 
    $templateCache.put("directives/decorators/bootstrap/array.html", '<div sf-array="form" class="schema-form-array {{form.htmlClass}}" ng-model="$$value$$" ng-model-options="form.ngModelOptions"><h3 ng-show="form.title && form.notitle !== true">{{ form.title }}</h3><ol class="list-group" ng-model="modelArray" ui-sortable=""><li class="list-group-item {{form.fieldHtmlClass}}" ng-repeat="item in modelArray track by $index"><button ng-hide="form.readonly || form.remove === null" ng-click="deleteFromArray($index)" style="position: relative; z-index: 20;" type="button" class="close pull-right"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button><sf-decorator ng-init="arrayIndex = $index" form="copyWithIndex($index)"></sf-decorator></li></ol><div class="clearfix" style="padding: 15px;"><button ng-hide="form.readonly || form.add === null" ng-click="appendToArray()" type="button" class="btn {{ form.style.add || \'btn-default\' }} pull-right"><i class="glyphicon glyphicon-plus"></i> {{ form.add || \'Add\'}}</button></div><div class="help-block" ng-show="(hasError() && errorMessage(schemaError())) || form.description" ng-bind-html="(hasError() && errorMessage(schemaError())) || form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/checkbox.html", '<div class="checkbox schema-form-checkbox {{form.htmlClass}}" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess()}"><label class="{{form.labelHtmlClass}}"><input type="checkbox" sf-changed="form" ng-disabled="form.readonly" ng-model="$$value$$" ng-model-options="form.ngModelOptions" schema-validate="form" class="{{form.fieldHtmlClass}}" name="{{form.key.slice(-1)[0]}}"> <span ng-bind-html="form.title"></span></label><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/checkboxes.html", '<div sf-array="form" ng-model="$$value$$" class="form-group schema-form-checkboxes {{form.htmlClass}}" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess()}"><label class="control-label {{form.labelHtmlClass}}" ng-show="showTitle()">{{form.title}}</label><div class="checkbox" ng-repeat="val in titleMapValues track by $index"><label><input type="checkbox" ng-disabled="form.readonly" sf-changed="form" class="{{form.fieldHtmlClass}}" ng-model="titleMapValues[$index]" name="{{form.key.slice(-1)[0]}}"> <span ng-bind-html="form.titleMap[$index].name"></span></label></div><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/default.html", '<div class="form-group schema-form-{{form.type}} {{form.htmlClass}}" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess(), \'has-feedback\': form.feedback !== false }"><label class="control-label {{form.labelHtmlClass}}" ng-class="{\'sr-only\': !showTitle()}" for="{{form.key.slice(-1)[0]}}">{{form.title}}</label> <input ng-if="!form.fieldAddonLeft && !form.fieldAddonRight" ng-show="form.key" type="{{form.type}}" step="any" sf-changed="form" placeholder="{{form.placeholder}}" class="form-control {{form.fieldHtmlClass}}" id="{{form.key.slice(-1)[0]}}" ng-model-options="form.ngModelOptions" ng-model="$$value$$" ng-disabled="form.readonly" schema-validate="form" name="{{form.key.slice(-1)[0]}}" aria-describedby="{{form.key.slice(-1)[0] + \'Status\'}}"><div ng-if="form.fieldAddonLeft || form.fieldAddonRight" ng-class="{\'input-group\': (form.fieldAddonLeft || form.fieldAddonRight)}"><span ng-if="form.fieldAddonLeft" class="input-group-addon" ng-bind-html="form.fieldAddonLeft"></span> <input ng-show="form.key" type="{{form.type}}" step="any" sf-changed="form" placeholder="{{form.placeholder}}" class="form-control {{form.fieldHtmlClass}}" id="{{form.key.slice(-1)[0]}}" ng-model-options="form.ngModelOptions" ng-model="$$value$$" ng-disabled="form.readonly" schema-validate="form" name="{{form.key.slice(-1)[0]}}" aria-describedby="{{form.key.slice(-1)[0] + \'Status\'}}"> <span ng-if="form.fieldAddonRight" class="input-group-addon" ng-bind-html="form.fieldAddonRight"></span></div><span ng-if="form.feedback !== false" class="form-control-feedback" ng-class="evalInScope(form.feedback) || {\'glyphicon\': true, \'glyphicon-ok\': hasSuccess(), \'glyphicon-remove\': hasError() }" aria-hidden="true"></span> <span ng-if="hasError() || hasSuccess()" id="{{form.key.slice(-1)[0] + \'Status\'}}" class="sr-only">{{ hasSuccess() ? \'(success)\' : \'(error)\' }}</span><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/fieldset-trcl.html", '<fieldset ng-disabled="form.readonly" class="schema-form-fieldset {{form.htmlClass}}"><legend ng-class="{\'sr-only\': !showTitle() }">{{ form.title }}</legend><div class="help-block" ng-show="form.description" ng-bind-html="form.description"></div><div ng-transclude=""></div></fieldset>'), 
    $templateCache.put("directives/decorators/bootstrap/fieldset.html", '<fieldset ng-disabled="form.readonly" class="schema-form-fieldset {{form.htmlClass}}"><legend ng-class="{\'sr-only\': !showTitle() }">{{ form.title }}</legend><div class="help-block" ng-show="form.description" ng-bind-html="form.description"></div><sf-decorator ng-repeat="item in form.items" form="item"></sf-decorator></fieldset>'), 
    $templateCache.put("directives/decorators/bootstrap/help.html", '<div class="helpvalue schema-form-helpvalue {{form.htmlClass}}" ng-bind-html="form.helpvalue"></div>'), 
    $templateCache.put("directives/decorators/bootstrap/radio-buttons.html", '<div class="form-group schema-form-radiobuttons {{form.htmlClass}}" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess()}"><div><label class="control-label {{form.labelHtmlClass}}" ng-show="showTitle()">{{form.title}}</label></div><div class="btn-group"><label class="btn {{ (item.value === $$value$$) ? form.style.selected || \'btn-default\' : form.style.unselected || \'btn-default\'; }}" ng-class="{ active: item.value === $$value$$ }" ng-repeat="item in form.titleMap"><input type="radio" class="{{form.fieldHtmlClass}}" sf-changed="form" style="display: none;" ng-disabled="form.readonly" ng-model="$$value$$" ng-model-options="form.ngModelOptions" schema-validate="form" ng-value="item.value" name="{{form.key.join(\'.\')}}"> <span ng-bind-html="item.name"></span></label></div><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/radios-inline.html", '<div class="form-group schema-form-radios-inline {{form.htmlClass}}" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess()}"><label class="control-label {{form.labelHtmlClass}}" ng-show="showTitle()">{{form.title}}</label><div><label class="radio-inline" ng-repeat="item in form.titleMap"><input type="radio" class="{{form.fieldHtmlClass}}" sf-changed="form" ng-disabled="form.readonly" ng-model="$$value$$" schema-validate="form" ng-value="item.value" name="{{form.key.join(\'.\')}}"> <span ng-bind-html="item.name"></span></label></div><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/radios.html", '<div class="form-group schema-form-radios {{form.htmlClass}}" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess()}"><label class="control-label {{form.labelHtmlClass}}" ng-show="showTitle()">{{form.title}}</label><div class="radio" ng-repeat="item in form.titleMap"><label><input type="radio" class="{{form.fieldHtmlClass}}" sf-changed="form" ng-disabled="form.readonly" ng-model="$$value$$" ng-model-options="form.ngModelOptions" schema-validate="form" ng-value="item.value" name="{{form.key.join(\'.\')}}"> <span ng-bind-html="item.name"></span></label></div><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/section.html", '<div class="schema-form-section {{form.htmlClass}}"><sf-decorator ng-repeat="item in form.items" form="item"></sf-decorator></div>'), 
    $templateCache.put("directives/decorators/bootstrap/select.html", '<div class="form-group {{form.htmlClass}} schema-form-select" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess(), \'has-feedback\': form.feedback !== false}"><label class="control-label {{form.labelHtmlClass}}" ng-show="showTitle()">{{form.title}}</label><select ng-model="$$value$$" ng-model-options="form.ngModelOptions" ng-disabled="form.readonly" sf-changed="form" class="form-control {{form.fieldHtmlClass}}" schema-validate="form" ng-options="item.value as item.name group by item.group for item in form.titleMap track by item[form.trackBy]" name="{{form.key.slice(-1)[0]}}"></select><div class="help-block" sf-message="form.description"></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/submit.html", '<div class="form-group schema-form-submit {{form.htmlClass}}"><input type="submit" class="btn {{ form.style || \'btn-primary\' }} {{form.fieldHtmlClass}}" value="{{form.title}}" ng-disabled="form.readonly" ng-if="form.type === \'submit\'"> <button class="btn {{ form.style || \'btn-default\' }}" type="button" ng-click="buttonClick($event,form)" ng-disabled="form.readonly" ng-if="form.type !== \'submit\'"><span ng-if="form.icon" class="{{form.icon}}"></span> {{form.title}}</button></div>'), 
    $templateCache.put("directives/decorators/bootstrap/tabarray.html", '<div sf-array="form" ng-init="selected = { tab: 0 }" class="clearfix schema-form-tabarray schema-form-tabarray-{{form.tabType || \'left\'}} {{form.htmlClass}}"><div ng-if="!form.tabType || form.tabType !== \'right\'" ng-class="{\'col-xs-3\': !form.tabType || form.tabType === \'left\'}"><ul class="nav nav-tabs" ng-class="{ \'tabs-left\': !form.tabType || form.tabType === \'left\'}"><li ng-repeat="item in modelArray track by $index" ng-click="$event.preventDefault() || (selected.tab = $index)" ng-class="{active: selected.tab === $index}"><a href="#">{{interp(form.title,{\'$index\':$index, value: item}) || $index}}</a></li><li ng-hide="form.readonly" ng-click="$event.preventDefault() || (selected.tab = appendToArray().length - 1)"><a href="#"><i class="glyphicon glyphicon-plus"></i> {{ form.add || \'Add\'}}</a></li></ul></div><div ng-class="{\'col-xs-9\': !form.tabType || form.tabType === \'left\' || form.tabType === \'right\'}"><div class="tab-content {{form.fieldHtmlClass}}"><div class="tab-pane clearfix" ng-repeat="item in modelArray track by $index" ng-show="selected.tab === $index" ng-class="{active: selected.tab === $index}"><sf-decorator ng-init="arrayIndex = $index" form="copyWithIndex($index)"></sf-decorator><button ng-hide="form.readonly" ng-click="selected.tab = deleteFromArray($index).length - 1" type="button" class="btn {{ form.style.remove || \'btn-default\' }} pull-right"><i class="glyphicon glyphicon-trash"></i> {{ form.remove || \'Remove\'}}</button></div></div></div><div ng-if="form.tabType === \'right\'" class="col-xs-3"><ul class="nav nav-tabs tabs-right"><li ng-repeat="item in modelArray track by $index" ng-click="$event.preventDefault() || (selected.tab = $index)" ng-class="{active: selected.tab === $index}"><a href="#">{{interp(form.title,{\'$index\':$index, value: item}) || $index}}</a></li><li ng-hide="form.readonly" ng-click="$event.preventDefault() || appendToArray()"><a href="#"><i class="glyphicon glyphicon-plus"></i> {{ form.add || \'Add\'}}</a></li></ul></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/tabs.html", '<div ng-init="selected = { tab: 0 }" class="schema-form-tabs {{form.htmlClass}}"><ul class="nav nav-tabs"><li ng-repeat="tab in form.tabs" ng-disabled="form.readonly" ng-click="$event.preventDefault() || (selected.tab = $index)" ng-class="{active: selected.tab === $index}"><a href="#">{{ tab.title }}</a></li></ul><div class="tab-content {{form.fieldHtmlClass}}"><div class="tab-pane" ng-disabled="form.readonly" ng-repeat="tab in form.tabs" ng-show="selected.tab === $index" ng-class="{active: selected.tab === $index}"><bootstrap-decorator ng-repeat="item in tab.items" form="item"></bootstrap-decorator></div></div></div>'), 
    $templateCache.put("directives/decorators/bootstrap/textarea.html", '<div class="form-group has-feedback {{form.htmlClass}} schema-form-textarea" ng-class="{\'has-error\': form.disableErrorState !== true && hasError(), \'has-success\': form.disableSuccessState !== true && hasSuccess()}"><label class="{{form.labelHtmlClass}}" ng-class="{\'sr-only\': !showTitle()}" for="{{form.key.slice(-1)[0]}}">{{form.title}}</label> <textarea ng-if="!form.fieldAddonLeft && !form.fieldAddonRight" class="form-control {{form.fieldHtmlClass}}" id="{{form.key.slice(-1)[0]}}" sf-changed="form" placeholder="{{form.placeholder}}" ng-disabled="form.readonly" ng-model="$$value$$" ng-model-options="form.ngModelOptions" schema-validate="form" name="{{form.key.slice(-1)[0]}}"></textarea><div ng-if="form.fieldAddonLeft || form.fieldAddonRight" ng-class="{\'input-group\': (form.fieldAddonLeft || form.fieldAddonRight)}"><span ng-if="form.fieldAddonLeft" class="input-group-addon" ng-bind-html="form.fieldAddonLeft"></span> <textarea class="form-control {{form.fieldHtmlClass}}" id="{{form.key.slice(-1)[0]}}" sf-changed="form" placeholder="{{form.placeholder}}" ng-disabled="form.readonly" ng-model="$$value$$" ng-model-options="form.ngModelOptions" schema-validate="form" name="{{form.key.slice(-1)[0]}}"></textarea> <span ng-if="form.fieldAddonRight" class="input-group-addon" ng-bind-html="form.fieldAddonRight"></span></div><span class="help-block" sf-message="form.description"></span></div>');
} ]), angular.module("schemaForm").config([ "schemaFormDecoratorsProvider", function(decoratorsProvider) {
    var base = "directives/decorators/bootstrap/";
    decoratorsProvider.defineDecorator("bootstrapDecorator", {
        textarea: {
            template: base + "textarea.html",
            replace: !1
        },
        fieldset: {
            template: base + "fieldset.html",
            replace: !1
        },
        array: {
            template: base + "array.html",
            replace: !1
        },
        tabarray: {
            template: base + "tabarray.html",
            replace: !1
        },
        tabs: {
            template: base + "tabs.html",
            replace: !1
        },
        section: {
            template: base + "section.html",
            replace: !1
        },
        conditional: {
            template: base + "section.html",
            replace: !1
        },
        actions: {
            template: base + "actions.html",
            replace: !1
        },
        select: {
            template: base + "select.html",
            replace: !1
        },
        checkbox: {
            template: base + "checkbox.html",
            replace: !1
        },
        checkboxes: {
            template: base + "checkboxes.html",
            replace: !1
        },
        number: {
            template: base + "default.html",
            replace: !1
        },
        password: {
            template: base + "default.html",
            replace: !1
        },
        submit: {
            template: base + "submit.html",
            replace: !1
        },
        button: {
            template: base + "submit.html",
            replace: !1
        },
        radios: {
            template: base + "radios.html",
            replace: !1
        },
        "radios-inline": {
            template: base + "radios-inline.html",
            replace: !1
        },
        radiobuttons: {
            template: base + "radio-buttons.html",
            replace: !1
        },
        help: {
            template: base + "help.html",
            replace: !1
        },
        "default": {
            template: base + "default.html",
            replace: !1
        }
    }, []), decoratorsProvider.createDirectives({
        textarea: base + "textarea.html",
        select: base + "select.html",
        checkbox: base + "checkbox.html",
        checkboxes: base + "checkboxes.html",
        number: base + "default.html",
        submit: base + "submit.html",
        button: base + "submit.html",
        text: base + "default.html",
        date: base + "default.html",
        password: base + "default.html",
        datepicker: base + "datepicker.html",
        input: base + "default.html",
        radios: base + "radios.html",
        "radios-inline": base + "radios-inline.html",
        radiobuttons: base + "radio-buttons.html"
    });
} ]).directive("sfFieldset", function() {
    return {
        transclude: !0,
        scope: !0,
        templateUrl: "directives/decorators/bootstrap/fieldset-trcl.html",
        link: function(scope, element, attrs) {
            scope.title = scope.$eval(attrs.title);
        }
    };
}), this.org = this.org || {}, org.cometd = {}, org.cometd.JSON = {}, org.cometd.JSON.toJSON = org.cometd.JSON.fromJSON = function(object) {
    throw "Abstract";
}, org.cometd.Cometd = function(name) {
    function _fieldValue(object, name) {
        try {
            return object[name];
        } catch (x) {
            return void 0;
        }
    }
    function _isString(value) {
        return org.cometd.Utils.isString(value);
    }
    function _isFunction(value) {
        return void 0 === value || null === value ? !1 : "function" == typeof value;
    }
    function _log(level, args) {
        if (window.console) {
            var logger = window.console[level];
            _isFunction(logger) && logger.apply(window.console, args);
        }
    }
    function _configure(configuration) {
        _cometd._debug("Configuring cometd object with", configuration), _isString(configuration) && (configuration = {
            url: configuration
        }), configuration || (configuration = {}), _config = _cometd._mixin(!1, _config, configuration);
        var url = _cometd.getURL();
        if (!url) throw "Missing required configuration parameter 'url' specifying the Bayeux server URL";
        var urlParts = /(^https?:\/\/)?(((\[[^\]]+\])|([^:\/\?#]+))(:(\d+))?)?([^\?#]*)(.*)?/.exec(url), hostAndPort = urlParts[2], uri = urlParts[8], afterURI = urlParts[9];
        if (_crossDomain = _cometd._isCrossDomain(hostAndPort), _config.appendMessageTypeToURL) if (void 0 !== afterURI && afterURI.length > 0) _cometd._info("Appending message type to URI " + uri + afterURI + " is not supported, disabling 'appendMessageTypeToURL' configuration"), 
        _config.appendMessageTypeToURL = !1; else {
            var uriSegments = uri.split("/"), lastSegmentIndex = uriSegments.length - 1;
            uri.match(/\/$/) && (lastSegmentIndex -= 1), uriSegments[lastSegmentIndex].indexOf(".") >= 0 && (_cometd._info("Appending message type to URI " + uri + " is not supported, disabling 'appendMessageTypeToURL' configuration"), 
            _config.appendMessageTypeToURL = !1);
        }
    }
    function _removeListener(subscription) {
        if (subscription) {
            var subscriptions = _listeners[subscription.channel];
            subscriptions && subscriptions[subscription.id] && (delete subscriptions[subscription.id], 
            _cometd._debug("Removed", subscription.listener ? "listener" : "subscription", subscription));
        }
    }
    function _removeSubscription(subscription) {
        subscription && !subscription.listener && _removeListener(subscription);
    }
    function _clearSubscriptions() {
        for (var channel in _listeners) {
            var subscriptions = _listeners[channel];
            if (subscriptions) for (var i = 0; i < subscriptions.length; ++i) _removeSubscription(subscriptions[i]);
        }
    }
    function _setStatus(newStatus) {
        _status !== newStatus && (_cometd._debug("Status", _status, "->", newStatus), _status = newStatus);
    }
    function _isDisconnected() {
        return "disconnecting" === _status || "disconnected" === _status;
    }
    function _nextMessageId() {
        return ++_messageId;
    }
    function _applyExtension(scope, callback, name, message, outgoing) {
        try {
            return callback.call(scope, message);
        } catch (x) {
            _cometd._debug("Exception during execution of extension", name, x);
            var exceptionCallback = _cometd.onExtensionException;
            if (_isFunction(exceptionCallback)) {
                _cometd._debug("Invoking extension exception callback", name, x);
                try {
                    exceptionCallback.call(_cometd, x, name, outgoing, message);
                } catch (xx) {
                    _cometd._info("Exception during execution of exception callback in extension", name, xx);
                }
            }
            return message;
        }
    }
    function _applyIncomingExtensions(message) {
        for (var i = 0; i < _extensions.length && (void 0 !== message && null !== message); ++i) {
            var index = _config.reverseIncomingExtensions ? _extensions.length - 1 - i : i, extension = _extensions[index], callback = extension.extension.incoming;
            if (_isFunction(callback)) {
                var result = _applyExtension(extension.extension, callback, extension.name, message, !1);
                message = void 0 === result ? message : result;
            }
        }
        return message;
    }
    function _applyOutgoingExtensions(message) {
        for (var i = 0; i < _extensions.length && (void 0 !== message && null !== message); ++i) {
            var extension = _extensions[i], callback = extension.extension.outgoing;
            if (_isFunction(callback)) {
                var result = _applyExtension(extension.extension, callback, extension.name, message, !0);
                message = void 0 === result ? message : result;
            }
        }
        return message;
    }
    function _notify(channel, message) {
        var subscriptions = _listeners[channel];
        if (subscriptions && subscriptions.length > 0) for (var i = 0; i < subscriptions.length; ++i) {
            var subscription = subscriptions[i];
            if (subscription) try {
                subscription.callback.call(subscription.scope, message);
            } catch (x) {
                _cometd._debug("Exception during notification", subscription, message, x);
                var listenerCallback = _cometd.onListenerException;
                if (_isFunction(listenerCallback)) {
                    _cometd._debug("Invoking listener exception callback", subscription, x);
                    try {
                        listenerCallback.call(_cometd, x, subscription, subscription.listener, message);
                    } catch (xx) {
                        _cometd._info("Exception during execution of listener callback", subscription, xx);
                    }
                }
            }
        }
    }
    function _notifyListeners(channel, message) {
        _notify(channel, message);
        for (var channelParts = channel.split("/"), last = channelParts.length - 1, i = last; i > 0; --i) {
            var channelPart = channelParts.slice(0, i).join("/") + "/*";
            i === last && _notify(channelPart, message), channelPart += "*", _notify(channelPart, message);
        }
    }
    function _cancelDelayedSend() {
        null !== _scheduledSend && org.cometd.Utils.clearTimeout(_scheduledSend), _scheduledSend = null;
    }
    function _delayedSend(operation) {
        _cancelDelayedSend();
        var delay = _advice.interval + _backoff;
        _cometd._debug("Function scheduled in", delay, "ms, interval =", _advice.interval, "backoff =", _backoff, operation), 
        _scheduledSend = org.cometd.Utils.setTimeout(_cometd, operation, delay);
    }
    function _send(sync, messages, longpoll, extraPath) {
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i];
            message.id = "" + _nextMessageId(), _clientId && (message.clientId = _clientId);
            var callback = void 0;
            _isFunction(message._callback) && (callback = message._callback, delete message._callback), 
            message = _applyOutgoingExtensions(message), void 0 !== message && null !== message ? (messages[i] = message, 
            callback && (_publishCallbacks[message.id] = callback)) : messages.splice(i--, 1);
        }
        if (0 !== messages.length) {
            var url = _cometd.getURL();
            _config.appendMessageTypeToURL && (url.match(/\/$/) || (url += "/"), extraPath && (url += extraPath));
            var envelope = {
                url: url,
                sync: sync,
                messages: messages,
                onSuccess: function(rcvdMessages) {
                    try {
                        _handleMessages.call(_cometd, rcvdMessages);
                    } catch (x) {
                        _cometd._debug("Exception during handling of messages", x);
                    }
                },
                onFailure: function(conduit, messages, failure) {
                    try {
                        failure.connectionType = _cometd.getTransport().getType(), _handleFailure.call(_cometd, conduit, messages, failure);
                    } catch (x) {
                        _cometd._debug("Exception during handling of failure", x);
                    }
                }
            };
            _cometd._debug("Send", envelope), _transport.send(envelope, longpoll);
        }
    }
    function _queueSend(message) {
        _batch > 0 || _internalBatch === !0 ? _messageQueue.push(message) : _send(!1, [ message ], !1);
    }
    function _resetBackoff() {
        _backoff = 0;
    }
    function _increaseBackoff() {
        _backoff < _config.maxBackoff && (_backoff += _config.backoffIncrement);
    }
    function _startBatch() {
        ++_batch;
    }
    function _flushBatch() {
        var messages = _messageQueue;
        _messageQueue = [], messages.length > 0 && _send(!1, messages, !1);
    }
    function _endBatch() {
        if (--_batch, 0 > _batch) throw "Calls to startBatch() and endBatch() are not paired";
        0 !== _batch || _isDisconnected() || _internalBatch || _flushBatch();
    }
    function _connect() {
        if (!_isDisconnected()) {
            var message = {
                channel: "/meta/connect",
                connectionType: _transport.getType()
            };
            _connected || (message.advice = {
                timeout: 0
            }), _setStatus("connecting"), _cometd._debug("Connect sent", message), _send(!1, [ message ], !0, "connect"), 
            _setStatus("connected");
        }
    }
    function _delayedConnect() {
        _setStatus("connecting"), _delayedSend(function() {
            _connect();
        });
    }
    function _updateAdvice(newAdvice) {
        newAdvice && (_advice = _cometd._mixin(!1, {}, _config.advice, newAdvice), _cometd._debug("New advice", _advice));
    }
    function _disconnect(abort) {
        _cancelDelayedSend(), abort && _transport.abort(), _clientId = null, _setStatus("disconnected"), 
        _batch = 0, _resetBackoff(), _messageQueue.length > 0 && (_handleFailure.call(_cometd, void 0, _messageQueue, {
            reason: "Disconnected"
        }), _messageQueue = []);
    }
    function _handshake(handshakeProps) {
        _clientId = null, _clearSubscriptions(), _isDisconnected() ? (_transports.reset(), 
        _updateAdvice(_config.advice)) : _updateAdvice(_cometd._mixin(!1, _advice, {
            reconnect: "retry"
        })), _batch = 0, _internalBatch = !0, _handshakeProps = handshakeProps;
        var version = "1.0", url = _cometd.getURL(), transportTypes = _transports.findTransportTypes(version, _crossDomain, url), bayeuxMessage = {
            version: version,
            minimumVersion: "0.9",
            channel: "/meta/handshake",
            supportedConnectionTypes: transportTypes,
            advice: {
                timeout: _advice.timeout,
                interval: _advice.interval
            }
        }, message = _cometd._mixin(!1, {}, _handshakeProps, bayeuxMessage);
        if (_transport = _transports.negotiateTransport(transportTypes, version, _crossDomain, url), 
        !_transport) {
            var error = "Could not find initial transport among: " + _transports.getTransportTypes();
            throw _cometd._warn(error), error;
        }
        _cometd._debug("Initial transport is", _transport.getType()), _setStatus("handshaking"), 
        _cometd._debug("Handshake sent", message), _send(!1, [ message ], !1, "handshake");
    }
    function _delayedHandshake() {
        _setStatus("handshaking"), _internalBatch = !0, _delayedSend(function() {
            _handshake(_handshakeProps);
        });
    }
    function _failHandshake(message) {
        _notifyListeners("/meta/handshake", message), _notifyListeners("/meta/unsuccessful", message);
        var retry = !_isDisconnected() && "none" !== _advice.reconnect;
        retry ? (_increaseBackoff(), _delayedHandshake()) : _disconnect(!1);
    }
    function _handshakeResponse(message) {
        if (message.successful) {
            _clientId = message.clientId;
            var url = _cometd.getURL(), newTransport = _transports.negotiateTransport(message.supportedConnectionTypes, message.version, _crossDomain, url);
            if (null === newTransport) throw "Could not negotiate transport with server; client " + _transports.findTransportTypes(message.version, _crossDomain, url) + ", server " + message.supportedConnectionTypes;
            _transport !== newTransport && (_cometd._debug("Transport", _transport, "->", newTransport), 
            _transport = newTransport), _internalBatch = !1, _flushBatch(), message.reestablish = _reestablish, 
            _reestablish = !0, _notifyListeners("/meta/handshake", message);
            var action = _isDisconnected() ? "none" : _advice.reconnect;
            switch (action) {
              case "retry":
                _resetBackoff(), _delayedConnect();
                break;

              case "none":
                _disconnect(!1);
                break;

              default:
                throw "Unrecognized advice action " + action;
            }
        } else _failHandshake(message);
    }
    function _handshakeFailure(message) {
        _failHandshake(message);
    }
    function _failConnect(message) {
        _notifyListeners("/meta/connect", message), _notifyListeners("/meta/unsuccessful", message);
        var action = _isDisconnected() ? "none" : _advice.reconnect;
        switch (action) {
          case "retry":
            _delayedConnect(), _increaseBackoff();
            break;

          case "handshake":
            _transports.reset(), _resetBackoff(), _delayedHandshake();
            break;

          case "none":
            _disconnect(!1);
            break;

          default:
            throw "Unrecognized advice action" + action;
        }
    }
    function _connectResponse(message) {
        if (_connected = message.successful) {
            _notifyListeners("/meta/connect", message);
            var action = _isDisconnected() ? "none" : _advice.reconnect;
            switch (action) {
              case "retry":
                _resetBackoff(), _delayedConnect();
                break;

              case "none":
                _disconnect(!1);
                break;

              default:
                throw "Unrecognized advice action " + action;
            }
        } else _failConnect(message);
    }
    function _connectFailure(message) {
        _connected = !1, _failConnect(message);
    }
    function _failDisconnect(message) {
        _disconnect(!0), _notifyListeners("/meta/disconnect", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _disconnectResponse(message) {
        message.successful ? (_disconnect(!1), _notifyListeners("/meta/disconnect", message)) : _failDisconnect(message);
    }
    function _disconnectFailure(message) {
        _failDisconnect(message);
    }
    function _failSubscribe(message) {
        var subscriptions = _listeners[message.subscription];
        if (subscriptions) for (var i = subscriptions.length - 1; i >= 0; --i) {
            var subscription = subscriptions[i];
            if (subscription && !subscription.listener) {
                delete subscriptions[i], _cometd._debug("Removed failed subscription", subscription);
                break;
            }
        }
        _notifyListeners("/meta/subscribe", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _subscribeResponse(message) {
        message.successful ? _notifyListeners("/meta/subscribe", message) : _failSubscribe(message);
    }
    function _subscribeFailure(message) {
        _failSubscribe(message);
    }
    function _failUnsubscribe(message) {
        _notifyListeners("/meta/unsubscribe", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _unsubscribeResponse(message) {
        message.successful ? _notifyListeners("/meta/unsubscribe", message) : _failUnsubscribe(message);
    }
    function _unsubscribeFailure(message) {
        _failUnsubscribe(message);
    }
    function _handlePublishCallback(message) {
        var callback = _publishCallbacks[message.id];
        _isFunction(callback) && (delete _publishCallbacks[message.id], callback.call(_cometd, message));
    }
    function _failMessage(message) {
        _handlePublishCallback(message), _notifyListeners("/meta/publish", message), _notifyListeners("/meta/unsuccessful", message);
    }
    function _messageResponse(message) {
        void 0 === message.successful ? void 0 !== message.data ? _notifyListeners(message.channel, message) : _cometd._warn("Unknown Bayeux Message", message) : message.successful ? (_handlePublishCallback(message), 
        _notifyListeners("/meta/publish", message)) : _failMessage(message);
    }
    function _messageFailure(failure) {
        _failMessage(failure);
    }
    function _receive(message) {
        if (message = _applyIncomingExtensions(message), void 0 !== message && null !== message) {
            _updateAdvice(message.advice);
            var channel = message.channel;
            switch (channel) {
              case "/meta/handshake":
                _handshakeResponse(message);
                break;

              case "/meta/connect":
                _connectResponse(message);
                break;

              case "/meta/disconnect":
                _disconnectResponse(message);
                break;

              case "/meta/subscribe":
                _subscribeResponse(message);
                break;

              case "/meta/unsubscribe":
                _unsubscribeResponse(message);
                break;

              default:
                _messageResponse(message);
            }
        }
    }
    function _hasSubscriptions(channel) {
        var subscriptions = _listeners[channel];
        if (subscriptions) for (var i = 0; i < subscriptions.length; ++i) if (subscriptions[i]) return !0;
        return !1;
    }
    function _resolveScopedCallback(scope, callback) {
        var delegate = {
            scope: scope,
            method: callback
        };
        if (_isFunction(scope)) delegate.scope = void 0, delegate.method = scope; else if (_isString(callback)) {
            if (!scope) throw "Invalid scope " + scope;
            if (delegate.method = scope[callback], !_isFunction(delegate.method)) throw "Invalid callback " + callback + " for scope " + scope;
        } else if (!_isFunction(callback)) throw "Invalid callback " + callback;
        return delegate;
    }
    function _addListener(channel, scope, callback, isListener) {
        var delegate = _resolveScopedCallback(scope, callback);
        _cometd._debug("Adding", isListener ? "listener" : "subscription", "on", channel, "with scope", delegate.scope, "and callback", delegate.method);
        var subscription = {
            channel: channel,
            scope: delegate.scope,
            callback: delegate.method,
            listener: isListener
        }, subscriptions = _listeners[channel];
        return subscriptions || (subscriptions = [], _listeners[channel] = subscriptions), 
        subscription.id = subscriptions.push(subscription) - 1, _cometd._debug("Added", isListener ? "listener" : "subscription", subscription), 
        subscription[0] = channel, subscription[1] = subscription.id, subscription;
    }
    var _transport, _handshakeProps, _cometd = this, _name = name || "default", _crossDomain = !1, _transports = new org.cometd.TransportRegistry(), _status = "disconnected", _messageId = 0, _clientId = null, _batch = 0, _messageQueue = [], _internalBatch = !1, _listeners = {}, _backoff = 0, _scheduledSend = null, _extensions = [], _advice = {}, _publishCallbacks = {}, _reestablish = !1, _connected = !1, _config = {
        protocol: null,
        connectTimeout: 0,
        maxConnections: 2,
        backoffIncrement: 1e3,
        maxBackoff: 6e4,
        logLevel: "info",
        reverseIncomingExtensions: !0,
        maxNetworkDelay: 1e4,
        requestHeaders: {},
        appendMessageTypeToURL: !0,
        autoBatch: !1,
        advice: {
            timeout: 6e4,
            interval: 0,
            reconnect: "retry"
        }
    };
    this._mixin = function(deep, target, objects) {
        for (var result = target || {}, i = 2; i < arguments.length; ++i) {
            var object = arguments[i];
            if (void 0 !== object && null !== object) for (var propName in object) {
                var prop = _fieldValue(object, propName), targ = _fieldValue(result, propName);
                if (prop !== target && void 0 !== prop) if (deep && "object" == typeof prop && null !== prop) if (prop instanceof Array) result[propName] = this._mixin(deep, targ instanceof Array ? targ : [], prop); else {
                    var source = "object" != typeof targ || targ instanceof Array ? {} : targ;
                    result[propName] = this._mixin(deep, source, prop);
                } else result[propName] = prop;
            }
        }
        return result;
    }, this._warn = function() {
        _log("warn", arguments);
    }, this._info = function() {
        "warn" !== _config.logLevel && _log("info", arguments);
    }, this._debug = function() {
        "debug" === _config.logLevel && _log("debug", arguments);
    }, this._isCrossDomain = function(hostAndPort) {
        return hostAndPort && hostAndPort !== window.location.host;
    };
    var _handleMessages, _handleFailure;
    this.send = _queueSend, this.receive = _receive, _handleMessages = function(rcvdMessages) {
        _cometd._debug("Received", rcvdMessages);
        for (var i = 0; i < rcvdMessages.length; ++i) {
            var message = rcvdMessages[i];
            _receive(message);
        }
    }, _handleFailure = function(conduit, messages, failure) {
        _cometd._debug("handleFailure", conduit, messages, failure), failure.transport = conduit;
        for (var i = 0; i < messages.length; ++i) {
            var message = messages[i], failureMessage = {
                successful: !1,
                channel: message.channel,
                failure: failure
            };
            switch (failure.message = message, message.channel) {
              case "/meta/handshake":
                failureMessage.id = message.id, _handshakeFailure(failureMessage);
                break;

              case "/meta/connect":
                failureMessage.id = message.id, _connectFailure(failureMessage);
                break;

              case "/meta/disconnect":
                failureMessage.id = message.id, _disconnectFailure(failureMessage);
                break;

              case "/meta/subscribe":
                failureMessage.id = message.id, failureMessage.subscription = message.subscription, 
                _subscribeFailure(failureMessage);
                break;

              case "/meta/unsubscribe":
                failureMessage.id = message.id, failureMessage.subscription = message.subscription, 
                _unsubscribeFailure(failureMessage);
                break;

              default:
                _messageFailure(failureMessage);
            }
        }
    }, this.registerTransport = function(type, transport, index) {
        var result = _transports.add(type, transport, index);
        return result && (this._debug("Registered transport", type), _isFunction(transport.registered) && transport.registered(type, this)), 
        result;
    }, this.getTransportTypes = function() {
        return _transports.getTransportTypes();
    }, this.unregisterTransport = function(type) {
        var transport = _transports.remove(type);
        return null !== transport && (this._debug("Unregistered transport", type), _isFunction(transport.unregistered) && transport.unregistered()), 
        transport;
    }, this.unregisterTransports = function() {
        _transports.clear();
    }, this.findTransport = function(name) {
        return _transports.find(name);
    }, this.configure = function(configuration) {
        _configure.call(this, configuration);
    }, this.init = function(configuration, handshakeProps) {
        this.configure(configuration), this.handshake(handshakeProps);
    }, this.handshake = function(handshakeProps) {
        _setStatus("disconnected"), _reestablish = !1, _handshake(handshakeProps);
    }, this.disconnect = function(sync, disconnectProps) {
        if (!_isDisconnected()) {
            void 0 === disconnectProps && "boolean" != typeof sync && (disconnectProps = sync, 
            sync = !1);
            var bayeuxMessage = {
                channel: "/meta/disconnect"
            }, message = this._mixin(!1, {}, disconnectProps, bayeuxMessage);
            _setStatus("disconnecting"), _send(sync === !0, [ message ], !1, "disconnect");
        }
    }, this.startBatch = function() {
        _startBatch();
    }, this.endBatch = function() {
        _endBatch();
    }, this.batch = function(scope, callback) {
        var delegate = _resolveScopedCallback(scope, callback);
        this.startBatch();
        try {
            delegate.method.call(delegate.scope), this.endBatch();
        } catch (x) {
            throw this._info("Exception during execution of batch", x), this.endBatch(), x;
        }
    }, this.addListener = function(channel, scope, callback) {
        if (arguments.length < 2) throw "Illegal arguments number: required 2, got " + arguments.length;
        if (!_isString(channel)) throw "Illegal argument type: channel must be a string";
        return _addListener(channel, scope, callback, !0);
    }, this.removeListener = function(subscription) {
        if (!(subscription && subscription.channel && "id" in subscription)) throw "Invalid argument: expected subscription, not " + subscription;
        _removeListener(subscription);
    }, this.clearListeners = function() {
        _listeners = {};
    }, this.subscribe = function(channel, scope, callback, subscribeProps) {
        if (arguments.length < 2) throw "Illegal arguments number: required 2, got " + arguments.length;
        if (!_isString(channel)) throw "Illegal argument type: channel must be a string";
        if (_isDisconnected()) throw "Illegal state: already disconnected";
        _isFunction(scope) && (subscribeProps = callback, callback = scope, scope = void 0);
        var send = !_hasSubscriptions(channel), subscription = _addListener(channel, scope, callback, !1);
        if (send) {
            var bayeuxMessage = {
                channel: "/meta/subscribe",
                subscription: channel
            }, message = this._mixin(!1, {}, subscribeProps, bayeuxMessage);
            _queueSend(message);
        }
        return subscription;
    }, this.unsubscribe = function(subscription, unsubscribeProps) {
        if (arguments.length < 1) throw "Illegal arguments number: required 1, got " + arguments.length;
        if (_isDisconnected()) throw "Illegal state: already disconnected";
        this.removeListener(subscription);
        var channel = subscription.channel;
        if (!_hasSubscriptions(channel)) {
            var bayeuxMessage = {
                channel: "/meta/unsubscribe",
                subscription: channel
            }, message = this._mixin(!1, {}, unsubscribeProps, bayeuxMessage);
            _queueSend(message);
        }
    }, this.resubscribe = function(subscription, subscribeProps) {
        return _removeSubscription(subscription), subscription ? this.subscribe(subscription.channel, subscription.scope, subscription.callback, subscribeProps) : void 0;
    }, this.clearSubscriptions = function() {
        _clearSubscriptions();
    }, this.publish = function(channel, content, publishProps, publishCallback) {
        if (arguments.length < 1) throw "Illegal arguments number: required 1, got " + arguments.length;
        if (!_isString(channel)) throw "Illegal argument type: channel must be a string";
        if (/^\/meta\//.test(channel)) throw "Illegal argument: cannot publish to meta channels";
        if (_isDisconnected()) throw "Illegal state: already disconnected";
        _isFunction(content) ? (publishCallback = content, content = publishProps = {}) : _isFunction(publishProps) && (publishCallback = publishProps, 
        publishProps = {});
        var bayeuxMessage = {
            channel: channel,
            data: content,
            _callback: publishCallback
        }, message = this._mixin(!1, {}, publishProps, bayeuxMessage);
        _queueSend(message);
    }, this.getStatus = function() {
        return _status;
    }, this.isDisconnected = _isDisconnected, this.setBackoffIncrement = function(period) {
        _config.backoffIncrement = period;
    }, this.getBackoffIncrement = function() {
        return _config.backoffIncrement;
    }, this.getBackoffPeriod = function() {
        return _backoff;
    }, this.setLogLevel = function(level) {
        _config.logLevel = level;
    }, this.registerExtension = function(name, extension) {
        if (arguments.length < 2) throw "Illegal arguments number: required 2, got " + arguments.length;
        if (!_isString(name)) throw "Illegal argument type: extension name must be a string";
        for (var existing = !1, i = 0; i < _extensions.length; ++i) {
            var existingExtension = _extensions[i];
            if (existingExtension.name === name) {
                existing = !0;
                break;
            }
        }
        return existing ? (this._info("Could not register extension with name", name, "since another extension with the same name already exists"), 
        !1) : (_extensions.push({
            name: name,
            extension: extension
        }), this._debug("Registered extension", name), _isFunction(extension.registered) && extension.registered(name, this), 
        !0);
    }, this.unregisterExtension = function(name) {
        if (!_isString(name)) throw "Illegal argument type: extension name must be a string";
        for (var unregistered = !1, i = 0; i < _extensions.length; ++i) {
            var extension = _extensions[i];
            if (extension.name === name) {
                _extensions.splice(i, 1), unregistered = !0, this._debug("Unregistered extension", name);
                var ext = extension.extension;
                _isFunction(ext.unregistered) && ext.unregistered();
                break;
            }
        }
        return unregistered;
    }, this.getExtension = function(name) {
        for (var i = 0; i < _extensions.length; ++i) {
            var extension = _extensions[i];
            if (extension.name === name) return extension.extension;
        }
        return null;
    }, this.getName = function() {
        return _name;
    }, this.getClientId = function() {
        return _clientId;
    }, this.getURL = function() {
        if (_transport && "object" == typeof _config.urls) {
            var url = _config.urls[_transport.getType()];
            if (url) return url;
        }
        return _config.url;
    }, this.getTransport = function() {
        return _transport;
    }, this.getConfiguration = function() {
        return this._mixin(!0, {}, _config);
    }, this.getAdvice = function() {
        return this._mixin(!0, {}, _advice);
    }, org.cometd.WebSocket = window.WebSocket, org.cometd.WebSocket || (org.cometd.WebSocket = window.MozWebSocket);
}, org.cometd.Utils = {}, org.cometd.Utils.isString = function(value) {
    return void 0 === value || null === value ? !1 : "string" == typeof value || value instanceof String;
}, org.cometd.Utils.isArray = function(value) {
    return void 0 === value || null === value ? !1 : value instanceof Array;
}, org.cometd.Utils.inArray = function(element, array) {
    for (var i = 0; i < array.length; ++i) if (element === array[i]) return i;
    return -1;
}, org.cometd.Utils.setTimeout = function(cometd, funktion, delay) {
    return window.setTimeout(function() {
        try {
            funktion();
        } catch (x) {
            cometd._debug("Exception invoking timed function", funktion, x);
        }
    }, delay);
}, org.cometd.Utils.clearTimeout = function(timeoutHandle) {
    window.clearTimeout(timeoutHandle);
}, org.cometd.TransportRegistry = function() {
    var _types = [], _transports = {};
    this.getTransportTypes = function() {
        return _types.slice(0);
    }, this.findTransportTypes = function(version, crossDomain, url) {
        for (var result = [], i = 0; i < _types.length; ++i) {
            var type = _types[i];
            _transports[type].accept(version, crossDomain, url) === !0 && result.push(type);
        }
        return result;
    }, this.negotiateTransport = function(types, version, crossDomain, url) {
        for (var i = 0; i < _types.length; ++i) for (var type = _types[i], j = 0; j < types.length; ++j) if (type === types[j]) {
            var transport = _transports[type];
            if (transport.accept(version, crossDomain, url) === !0) return transport;
        }
        return null;
    }, this.add = function(type, transport, index) {
        for (var existing = !1, i = 0; i < _types.length; ++i) if (_types[i] === type) {
            existing = !0;
            break;
        }
        return existing || ("number" != typeof index ? _types.push(type) : _types.splice(index, 0, type), 
        _transports[type] = transport), !existing;
    }, this.find = function(type) {
        for (var i = 0; i < _types.length; ++i) if (_types[i] === type) return _transports[type];
        return null;
    }, this.remove = function(type) {
        for (var i = 0; i < _types.length; ++i) if (_types[i] === type) {
            _types.splice(i, 1);
            var transport = _transports[type];
            return delete _transports[type], transport;
        }
        return null;
    }, this.clear = function() {
        _types = [], _transports = {};
    }, this.reset = function() {
        for (var i = 0; i < _types.length; ++i) _transports[_types[i]].reset();
    };
}, org.cometd.Transport = function() {
    var _type, _cometd;
    this.registered = function(type, cometd) {
        _type = type, _cometd = cometd;
    }, this.unregistered = function() {
        _type = null, _cometd = null;
    }, this._debug = function() {
        _cometd._debug.apply(_cometd, arguments);
    }, this._mixin = function() {
        return _cometd._mixin.apply(_cometd, arguments);
    }, this.getConfiguration = function() {
        return _cometd.getConfiguration();
    }, this.getAdvice = function() {
        return _cometd.getAdvice();
    }, this.setTimeout = function(funktion, delay) {
        return org.cometd.Utils.setTimeout(_cometd, funktion, delay);
    }, this.clearTimeout = function(handle) {
        org.cometd.Utils.clearTimeout(handle);
    }, this.convertToMessages = function(response) {
        if (org.cometd.Utils.isString(response)) try {
            return org.cometd.JSON.fromJSON(response);
        } catch (x) {
            throw this._debug("Could not convert to JSON the following string", '"' + response + '"'), 
            x;
        }
        if (org.cometd.Utils.isArray(response)) return response;
        if (void 0 === response || null === response) return [];
        if (response instanceof Object) return [ response ];
        throw "Conversion Error " + response + ", typeof " + typeof response;
    }, this.accept = function(version, crossDomain, url) {
        throw "Abstract";
    }, this.getType = function() {
        return _type;
    }, this.send = function(envelope, metaConnect) {
        throw "Abstract";
    }, this.reset = function() {
        this._debug("Transport", _type, "reset");
    }, this.abort = function() {
        this._debug("Transport", _type, "aborted");
    }, this.toString = function() {
        return this.getType();
    };
}, org.cometd.Transport.derive = function(baseObject) {
    function F() {}
    return F.prototype = baseObject, new F();
}, org.cometd.RequestTransport = function() {
    function _coalesceEnvelopes(envelope) {
        for (;_envelopes.length > 0; ) {
            var envelopeAndRequest = _envelopes[0], newEnvelope = envelopeAndRequest[0], newRequest = envelopeAndRequest[1];
            if (newEnvelope.url !== envelope.url || newEnvelope.sync !== envelope.sync) break;
            _envelopes.shift(), envelope.messages = envelope.messages.concat(newEnvelope.messages), 
            this._debug("Coalesced", newEnvelope.messages.length, "messages from request", newRequest.id);
        }
    }
    function _transportSend(envelope, request) {
        if (this.transportSend(envelope, request), request.expired = !1, !envelope.sync) {
            var maxDelay = this.getConfiguration().maxNetworkDelay, delay = maxDelay;
            request.metaConnect === !0 && (delay += this.getAdvice().timeout), this._debug("Transport", this.getType(), "waiting at most", delay, "ms for the response, maxNetworkDelay", maxDelay);
            var self = this;
            request.timeout = this.setTimeout(function() {
                request.expired = !0;
                var errorMessage = "Request " + request.id + " of transport " + self.getType() + " exceeded " + delay + " ms max network delay", failure = {
                    reason: errorMessage
                }, xhr = request.xhr;
                failure.httpCode = self.xhrStatus(xhr), self.abortXHR(xhr), self._debug(errorMessage), 
                self.complete(request, !1, request.metaConnect), envelope.onFailure(xhr, envelope.messages, failure);
            }, delay);
        }
    }
    function _queueSend(envelope) {
        var requestId = ++_requestIds, request = {
            id: requestId,
            metaConnect: !1
        };
        _requests.length < this.getConfiguration().maxConnections - 1 ? (_requests.push(request), 
        _transportSend.call(this, envelope, request)) : (this._debug("Transport", this.getType(), "queueing request", requestId, "envelope", envelope), 
        _envelopes.push([ envelope, request ]));
    }
    function _metaConnectComplete(request) {
        var requestId = request.id;
        if (this._debug("Transport", this.getType(), "metaConnect complete, request", requestId), 
        null !== _metaConnectRequest && _metaConnectRequest.id !== requestId) throw "Longpoll request mismatch, completing request " + requestId;
        _metaConnectRequest = null;
    }
    function _complete(request, success) {
        var index = org.cometd.Utils.inArray(request, _requests);
        if (index >= 0 && _requests.splice(index, 1), _envelopes.length > 0) {
            var envelopeAndRequest = _envelopes.shift(), nextEnvelope = envelopeAndRequest[0], nextRequest = envelopeAndRequest[1];
            if (this._debug("Transport dequeued request", nextRequest.id), success) this.getConfiguration().autoBatch && _coalesceEnvelopes.call(this, nextEnvelope), 
            _queueSend.call(this, nextEnvelope), this._debug("Transport completed request", request.id, nextEnvelope); else {
                var self = this;
                this.setTimeout(function() {
                    self.complete(nextRequest, !1, nextRequest.metaConnect);
                    var failure = {
                        reason: "Previous request failed"
                    }, xhr = nextRequest.xhr;
                    failure.httpCode = self.xhrStatus(xhr), nextEnvelope.onFailure(xhr, nextEnvelope.messages, failure);
                }, 0);
            }
        }
    }
    function _metaConnectSend(envelope) {
        if (null !== _metaConnectRequest) throw "Concurrent metaConnect requests not allowed, request id=" + _metaConnectRequest.id + " not yet completed";
        var requestId = ++_requestIds;
        this._debug("Transport", this.getType(), "metaConnect send, request", requestId, "envelope", envelope);
        var request = {
            id: requestId,
            metaConnect: !0
        };
        _transportSend.call(this, envelope, request), _metaConnectRequest = request;
    }
    var _super = new org.cometd.Transport(), _self = org.cometd.Transport.derive(_super), _requestIds = 0, _metaConnectRequest = null, _requests = [], _envelopes = [];
    return _self.complete = function(request, success, metaConnect) {
        metaConnect ? _metaConnectComplete.call(this, request) : _complete.call(this, request, success);
    }, _self.transportSend = function(envelope, request) {
        throw "Abstract";
    }, _self.transportSuccess = function(envelope, request, responses) {
        request.expired || (this.clearTimeout(request.timeout), this.complete(request, !0, request.metaConnect), 
        responses && responses.length > 0 ? envelope.onSuccess(responses) : envelope.onFailure(request.xhr, envelope.messages, {
            httpCode: 204
        }));
    }, _self.transportFailure = function(envelope, request, failure) {
        request.expired || (this.clearTimeout(request.timeout), this.complete(request, !1, request.metaConnect), 
        envelope.onFailure(request.xhr, envelope.messages, failure));
    }, _self.send = function(envelope, metaConnect) {
        metaConnect ? _metaConnectSend.call(this, envelope) : _queueSend.call(this, envelope);
    }, _self.abort = function() {
        _super.abort();
        for (var i = 0; i < _requests.length; ++i) {
            var request = _requests[i];
            this._debug("Aborting request", request), this.abortXHR(request.xhr);
        }
        _metaConnectRequest && (this._debug("Aborting metaConnect request", _metaConnectRequest), 
        this.abortXHR(_metaConnectRequest.xhr)), this.reset();
    }, _self.reset = function() {
        _super.reset(), _metaConnectRequest = null, _requests = [], _envelopes = [];
    }, _self.abortXHR = function(xhr) {
        if (xhr) try {
            xhr.abort();
        } catch (x) {
            this._debug(x);
        }
    }, _self.xhrStatus = function(xhr) {
        if (xhr) try {
            return xhr.status;
        } catch (x) {
            this._debug(x);
        }
        return -1;
    }, _self;
}, org.cometd.LongPollingTransport = function() {
    var _super = new org.cometd.RequestTransport(), _self = org.cometd.Transport.derive(_super), _supportsCrossDomain = !0;
    return _self.accept = function(version, crossDomain, url) {
        return _supportsCrossDomain || !crossDomain;
    }, _self.xhrSend = function(packet) {
        throw "Abstract";
    }, _self.transportSend = function(envelope, request) {
        this._debug("Transport", this.getType(), "sending request", request.id, "envelope", envelope);
        var self = this;
        try {
            var sameStack = !0;
            request.xhr = this.xhrSend({
                transport: this,
                url: envelope.url,
                sync: envelope.sync,
                headers: this.getConfiguration().requestHeaders,
                body: org.cometd.JSON.toJSON(envelope.messages),
                onSuccess: function(response) {
                    self._debug("Transport", self.getType(), "received response", response);
                    var success = !1;
                    try {
                        var received = self.convertToMessages(response);
                        0 === received.length ? (_supportsCrossDomain = !1, self.transportFailure(envelope, request, {
                            httpCode: 204
                        })) : (success = !0, self.transportSuccess(envelope, request, received));
                    } catch (x) {
                        if (self._debug(x), !success) {
                            _supportsCrossDomain = !1;
                            var failure = {
                                exception: x
                            };
                            failure.httpCode = self.xhrStatus(request.xhr), self.transportFailure(envelope, request, failure);
                        }
                    }
                },
                onError: function(reason, exception) {
                    _supportsCrossDomain = !1;
                    var failure = {
                        reason: reason,
                        exception: exception
                    };
                    failure.httpCode = self.xhrStatus(request.xhr), sameStack ? self.setTimeout(function() {
                        self.transportFailure(envelope, request, failure);
                    }, 0) : self.transportFailure(envelope, request, failure);
                }
            }), sameStack = !1;
        } catch (x) {
            _supportsCrossDomain = !1, this.setTimeout(function() {
                self.transportFailure(envelope, request, {
                    exception: x
                });
            }, 0);
        }
    }, _self.reset = function() {
        _super.reset(), _supportsCrossDomain = !0;
    }, _self;
}, org.cometd.CallbackPollingTransport = function() {
    var _super = new org.cometd.RequestTransport(), _self = org.cometd.Transport.derive(_super), _maxLength = 2e3;
    return _self.accept = function(version, crossDomain, url) {
        return !0;
    }, _self.jsonpSend = function(packet) {
        throw "Abstract";
    }, _self.transportSend = function(envelope, request) {
        for (var self = this, start = 0, length = envelope.messages.length, lengths = []; length > 0; ) {
            var json = org.cometd.JSON.toJSON(envelope.messages.slice(start, start + length)), urlLength = envelope.url.length + encodeURI(json).length;
            if (urlLength > _maxLength) {
                if (1 === length) return void this.setTimeout(function() {
                    self.transportFailure(envelope, request, {
                        reason: "Bayeux message too big, max is " + _maxLength
                    });
                }, 0);
                --length;
            } else lengths.push(length), start += length, length = envelope.messages.length - start;
        }
        var envelopeToSend = envelope;
        if (lengths.length > 1) {
            var begin = 0, end = lengths[0];
            this._debug("Transport", this.getType(), "split", envelope.messages.length, "messages into", lengths.join(" + ")), 
            envelopeToSend = this._mixin(!1, {}, envelope), envelopeToSend.messages = envelope.messages.slice(begin, end), 
            envelopeToSend.onSuccess = envelope.onSuccess, envelopeToSend.onFailure = envelope.onFailure;
            for (var i = 1; i < lengths.length; ++i) {
                var nextEnvelope = this._mixin(!1, {}, envelope);
                begin = end, end += lengths[i], nextEnvelope.messages = envelope.messages.slice(begin, end), 
                nextEnvelope.onSuccess = envelope.onSuccess, nextEnvelope.onFailure = envelope.onFailure, 
                this.send(nextEnvelope, request.metaConnect);
            }
        }
        this._debug("Transport", this.getType(), "sending request", request.id, "envelope", envelopeToSend);
        try {
            var sameStack = !0;
            this.jsonpSend({
                transport: this,
                url: envelopeToSend.url,
                sync: envelopeToSend.sync,
                headers: this.getConfiguration().requestHeaders,
                body: org.cometd.JSON.toJSON(envelopeToSend.messages),
                onSuccess: function(responses) {
                    var success = !1;
                    try {
                        var received = self.convertToMessages(responses);
                        0 === received.length ? self.transportFailure(envelopeToSend, request, {
                            httpCode: 204
                        }) : (success = !0, self.transportSuccess(envelopeToSend, request, received));
                    } catch (x) {
                        self._debug(x), success || self.transportFailure(envelopeToSend, request, {
                            exception: x
                        });
                    }
                },
                onError: function(reason, exception) {
                    var failure = {
                        reason: reason,
                        exception: exception
                    };
                    sameStack ? self.setTimeout(function() {
                        self.transportFailure(envelopeToSend, request, failure);
                    }, 0) : self.transportFailure(envelopeToSend, request, failure);
                }
            }), sameStack = !1;
        } catch (xx) {
            this.setTimeout(function() {
                self.transportFailure(envelopeToSend, request, {
                    exception: xx
                });
            }, 0);
        }
    }, _self;
}, org.cometd.WebSocketTransport = function() {
    function _websocketConnect() {
        var url = _cometd.getURL().replace(/^http/, "ws");
        this._debug("Transport", this.getType(), "connecting to URL", url);
        var self = this, connectTimer = null, connectTimeout = _cometd.getConfiguration().connectTimeout;
        connectTimeout > 0 && (connectTimer = this.setTimeout(function() {
            connectTimer = null, _opened || (self._debug("Transport", self.getType(), "timed out while connecting to URL", url, ":", connectTimeout, "ms"), 
            self.onClose(1002, "Connect Timeout"));
        }, connectTimeout));
        var protocol = _cometd.getConfiguration().protocol, webSocket = protocol ? new org.cometd.WebSocket(url, protocol) : new org.cometd.WebSocket(url), onopen = function() {
            return self._debug("WebSocket opened", webSocket), connectTimer && (self.clearTimeout(connectTimer), 
            connectTimer = null), webSocket !== _webSocket ? void self._debug("Ignoring open event, WebSocket", _webSocket) : void self.onOpen();
        }, onclose = function(event) {
            var code = event ? event.code : 1e3, reason = event ? event.reason : void 0;
            return self._debug("WebSocket closed", code, "/", reason, webSocket), connectTimer && (self.clearTimeout(connectTimer), 
            connectTimer = null), webSocket !== _webSocket ? void self._debug("Ignoring close event, WebSocket", _webSocket) : void self.onClose(code, reason);
        }, onmessage = function(message) {
            return self._debug("WebSocket message", message, webSocket), webSocket !== _webSocket ? void self._debug("Ignoring message event, WebSocket", _webSocket) : void self.onMessage(message);
        };
        webSocket.onopen = onopen, webSocket.onclose = onclose, webSocket.onerror = function() {
            onclose({
                code: 1002,
                reason: "Error"
            });
        }, webSocket.onmessage = onmessage, _webSocket = webSocket, this._debug("Transport", this.getType(), "configured callbacks on", webSocket);
    }
    function _webSocketSend(envelope, metaConnect) {
        var json = org.cometd.JSON.toJSON(envelope.messages);
        _webSocket.send(json), this._debug("Transport", this.getType(), "sent", envelope, "metaConnect =", metaConnect);
        var maxDelay = this.getConfiguration().maxNetworkDelay, delay = maxDelay;
        metaConnect && (delay += this.getAdvice().timeout, _connected = !0);
        for (var self = this, webSocket = _webSocket, messageIds = [], i = 0; i < envelope.messages.length; ++i) {
            var message = envelope.messages[i];
            message.id && (messageIds.push(message.id), _timeouts[message.id] = this.setTimeout(function() {
                self.webSocketClose(webSocket, 1e3, "Timeout");
            }, delay));
        }
        this._debug("Transport", this.getType(), "waiting at most", delay, "ms for messages", messageIds, "maxNetworkDelay", maxDelay, ", timeouts:", _timeouts);
    }
    function _send(envelope, metaConnect) {
        try {
            null === _webSocket ? _websocketConnect.call(this) : _opened && _webSocketSend.call(this, envelope, metaConnect);
        } catch (x) {
            var webSocket = _webSocket;
            this.setTimeout(function() {
                envelope.onFailure(webSocket, envelope.messages, {
                    exception: x
                });
            }, 0);
        }
    }
    var _cometd, _successCallback, _super = new org.cometd.Transport(), _self = org.cometd.Transport.derive(_super), _supportsWebSocket = !0, _webSocketSupported = !1, _envelopes = {}, _timeouts = {}, _webSocket = null, _opened = !1, _connected = !1;
    return _self.onOpen = function() {
        this._debug("Transport", this.getType(), "opened", _webSocket), _opened = !0, _webSocketSupported = !0, 
        this._debug("Sending pending messages", _envelopes);
        for (var key in _envelopes) {
            var element = _envelopes[key], envelope = element[0], metaConnect = element[1];
            _successCallback = envelope.onSuccess, _webSocketSend.call(this, envelope, metaConnect);
        }
    }, _self.onMessage = function(wsMessage) {
        this._debug("Transport", this.getType(), "received websocket message", wsMessage, _webSocket);
        for (var close = !1, messages = this.convertToMessages(wsMessage.data), messageIds = [], i = 0; i < messages.length; ++i) {
            var message = messages[i];
            if ((/^\/meta\//.test(message.channel) || void 0 === message.data) && message.id) {
                messageIds.push(message.id);
                var timeout = _timeouts[message.id];
                timeout && (this.clearTimeout(timeout), delete _timeouts[message.id], this._debug("Transport", this.getType(), "removed timeout for message", message.id, ", timeouts", _timeouts));
            }
            "/meta/connect" === message.channel && (_connected = !1), "/meta/disconnect" !== message.channel || _connected || (close = !0);
        }
        for (var removed = !1, j = 0; j < messageIds.length; ++j) {
            var id = messageIds[j];
            for (var key in _envelopes) {
                var ids = key.split(","), index = org.cometd.Utils.inArray(id, ids);
                if (index >= 0) {
                    removed = !0, ids.splice(index, 1);
                    var envelope = _envelopes[key][0], metaConnect = _envelopes[key][1];
                    delete _envelopes[key], ids.length > 0 && (_envelopes[ids.join(",")] = [ envelope, metaConnect ]);
                    break;
                }
            }
        }
        removed && this._debug("Transport", this.getType(), "removed envelope, envelopes", _envelopes), 
        _successCallback.call(this, messages), close && this.webSocketClose(_webSocket, 1e3, "Disconnect");
    }, _self.onClose = function(code, reason) {
        this._debug("Transport", this.getType(), "closed", code, reason, _webSocket), _supportsWebSocket = _webSocketSupported;
        for (var id in _timeouts) this.clearTimeout(_timeouts[id]);
        _timeouts = {};
        for (var key in _envelopes) {
            var envelope = _envelopes[key][0], metaConnect = _envelopes[key][1];
            metaConnect && (_connected = !1), envelope.onFailure(_webSocket, envelope.messages, {
                websocketCode: code,
                reason: reason
            });
        }
        _envelopes = {}, _opened && this.webSocketClose(_webSocket, 1e3, "Close"), _opened = !1, 
        _webSocket = null;
    }, _self.registered = function(type, cometd) {
        _super.registered(type, cometd), _cometd = cometd;
    }, _self.accept = function(version, crossDomain, url) {
        return _supportsWebSocket && !!org.cometd.WebSocket && _cometd.websocketEnabled !== !1;
    }, _self.send = function(envelope, metaConnect) {
        this._debug("Transport", this.getType(), "sending", envelope, "metaConnect =", metaConnect);
        for (var messageIds = [], i = 0; i < envelope.messages.length; ++i) {
            var message = envelope.messages[i];
            message.id && messageIds.push(message.id);
        }
        _envelopes[messageIds.join(",")] = [ envelope, metaConnect ], this._debug("Transport", this.getType(), "stored envelope, envelopes", _envelopes), 
        _send.call(this, envelope, metaConnect);
    }, _self.webSocketClose = function(webSocket, code, reason) {
        if (webSocket) try {
            webSocket.close(code, reason);
        } catch (x) {
            this._debug(x);
        }
    }, _self.abort = function() {
        _super.abort(), this.webSocketClose(_webSocket, 1001, "Abort"), this.reset();
    }, _self.reset = function() {
        _super.reset(), _opened && this.webSocketClose(_webSocket, 1e3, "Reset"), _supportsWebSocket = !0, 
        _webSocketSupported = !1, _timeouts = {}, _envelopes = {}, _webSocket = null, _opened = !1, 
        _successCallback = null;
    }, _self;
}, function($) {
    function bind($, org_cometd) {
        function _setHeaders(xhr, headers) {
            if (headers) for (var headerName in headers) "content-type" !== headerName.toLowerCase() && xhr.setRequestHeader(headerName, headers[headerName]);
        }
        function LongPollingTransport() {
            var _super = new org_cometd.LongPollingTransport(), that = org_cometd.Transport.derive(_super);
            return that.xhrSend = function(packet) {
                return $.ajax({
                    url: packet.url,
                    async: packet.sync !== !0,
                    type: "POST",
                    contentType: "application/json;charset=UTF-8",
                    data: packet.body,
                    xhrFields: {
                        withCredentials: !0
                    },
                    beforeSend: function(xhr) {
                        return _setHeaders(xhr, packet.headers), !0;
                    },
                    success: packet.onSuccess,
                    error: function(xhr, reason, exception) {
                        packet.onError(reason, exception);
                    }
                });
            }, that;
        }
        function CallbackPollingTransport() {
            var _super = new org_cometd.CallbackPollingTransport(), that = org_cometd.Transport.derive(_super);
            return that.jsonpSend = function(packet) {
                $.ajax({
                    url: packet.url,
                    async: packet.sync !== !0,
                    type: "GET",
                    dataType: "jsonp",
                    jsonp: "jsonp",
                    data: {
                        message: packet.body
                    },
                    beforeSend: function(xhr) {
                        return _setHeaders(xhr, packet.headers), !0;
                    },
                    success: packet.onSuccess,
                    error: function(xhr, reason, exception) {
                        packet.onError(reason, exception);
                    }
                });
            }, that;
        }
        return org_cometd.JSON.toJSON = JSON.stringify, org_cometd.JSON.fromJSON = JSON.parse, 
        $.Cometd = function(name) {
            var cometd = new org_cometd.Cometd(name);
            return org_cometd.WebSocket && cometd.registerTransport("websocket", new org_cometd.WebSocketTransport()), 
            cometd.registerTransport("long-polling", new LongPollingTransport()), cometd.registerTransport("callback-polling", new CallbackPollingTransport()), 
            cometd;
        }, $.cometd = new $.Cometd(), $.cometd;
    }
    "function" == typeof define && define.amd ? define([ "jquery", "org/cometd" ], bind) : bind($, org.cometd);
}(jQuery), function(o) {
    function G(a) {
        return "[object Function]" == Object.prototype.toString.call(a);
    }
    function H(a) {
        return "[object Array]" == Object.prototype.toString.call(a);
    }
    function N(a, c) {
        var b = /^\w+\:\/\//;
        return /^\/\/\/?/.test(a) ? a = location.protocol + a : b.test(a) || "/" == a.charAt(0) || (a = (c || "") + a), 
        b.test(a) ? a : ("/" == a.charAt(0) ? D : C) + a;
    }
    function s(a, c) {
        for (var b in a) a.hasOwnProperty(b) && (c[b] = a[b]);
        return c;
    }
    function O(a) {
        for (var c = !1, b = 0; b < a.scripts.length; b++) a.scripts[b].ready && a.scripts[b].exec_trigger && (c = !0, 
        a.scripts[b].exec_trigger(), a.scripts[b].exec_trigger = null);
        return c;
    }
    function t(a, c, b, d) {
        a.onload = a.onreadystatechange = function() {
            a.readyState && "complete" != a.readyState && "loaded" != a.readyState || c[b] || (a.onload = a.onreadystatechange = null, 
            d());
        };
    }
    function I(a) {
        a.ready = a.finished = !0;
        for (var c = 0; c < a.finished_listeners.length; c++) a.finished_listeners[c]();
        a.ready_listeners = [], a.finished_listeners = [];
    }
    function P(d, f, e, g, h) {
        setTimeout(function() {
            var a, b, c = f.real_src;
            if ("item" in i) {
                if (!i[0]) return void setTimeout(arguments.callee, 25);
                i = i[0];
            }
            a = document.createElement("script"), f.type && (a.type = f.type), f.charset && (a.charset = f.charset), 
            h ? r ? (e.elem = a, E ? (a.preload = !0, a.onpreload = g) : a.onreadystatechange = function() {
                "loaded" == a.readyState && g();
            }, a.src = c) : h && 0 == c.indexOf(D) && d[y] ? (b = new XMLHttpRequest(), b.onreadystatechange = function() {
                4 == b.readyState && (b.onreadystatechange = function() {}, e.text = b.responseText + "\n//@ sourceURL=" + c, 
                g());
            }, b.open("GET", c), b.send()) : (a.type = "text/cache-script", t(a, e, "ready", function() {
                i.removeChild(a), g();
            }), a.src = c, i.insertBefore(a, i.firstChild)) : F ? (a.async = !1, t(a, e, "finished", g), 
            a.src = c, i.insertBefore(a, i.firstChild)) : (t(a, e, "finished", g), a.src = c, 
            i.insertBefore(a, i.firstChild));
        }, 0);
    }
    function J() {
        function R(a, c, b) {
            function f() {
                null != d && (d = null, I(b));
            }
            var d;
            p[c.src].finished || (a[u] || (p[c.src].finished = !0), d = b.elem || document.createElement("script"), 
            c.type && (d.type = c.type), c.charset && (d.charset = c.charset), t(d, b, "finished", f), 
            b.elem ? b.elem = null : b.text ? (d.onload = d.onreadystatechange = null, d.text = b.text) : d.src = c.real_src, 
            i.insertBefore(d, i.firstChild), b.text && f());
        }
        function S(c, b, d, f) {
            var e, g, h = function() {
                b.ready_cb(b, function() {
                    R(c, b, e);
                });
            }, j = function() {
                b.finished_cb(b, d);
            };
            b.src = N(b.src, c[B]), b.real_src = b.src + (c[A] ? (/\?.*$/.test(b.src) ? "&_" : "?_") + ~~(1e9 * Math.random()) + "=" : ""), 
            p[b.src] || (p[b.src] = {
                items: [],
                finished: !1
            }), g = p[b.src].items, c[u] || 0 == g.length ? (e = g[g.length] = {
                ready: !1,
                finished: !1,
                ready_listeners: [ h ],
                finished_listeners: [ j ]
            }, P(c, b, e, f ? function() {
                e.ready = !0;
                for (var a = 0; a < e.ready_listeners.length; a++) e.ready_listeners[a]();
                e.ready_listeners = [];
            } : function() {
                I(e);
            }, f)) : (e = g[0], e.finished ? j() : e.finished_listeners.push(j));
        }
        function v() {
            function T(a, c) {
                a.ready = !0, a.exec_trigger = c, x();
            }
            function U(a, c) {
                a.ready = a.finished = !0, a.exec_trigger = null;
                for (var b = 0; b < c.scripts.length; b++) if (!c.scripts[b].finished) return;
                c.finished = !0, x();
            }
            function x() {
                for (;j < h.length; ) if (G(h[j])) try {
                    h[j++]();
                } catch (err) {} else {
                    if (!h[j].finished) {
                        if (O(h[j])) continue;
                        break;
                    }
                    j++;
                }
                j == h.length && (w = !1, k = !1);
            }
            function V() {
                k && k.scripts || h.push(k = {
                    scripts: [],
                    finished: !0
                });
            }
            var e, k, g = s(l, {}), h = [], j = 0, w = !1;
            return e = {
                script: function() {
                    for (var f = 0; f < arguments.length; f++) !function(a, c) {
                        var b;
                        H(a) || (c = [ a ]);
                        for (var d = 0; d < c.length; d++) V(), a = c[d], G(a) && (a = a()), a && (H(a) ? (b = [].slice.call(a), 
                        b.unshift(d, 1), [].splice.apply(c, b), d--) : ("string" == typeof a && (a = {
                            src: a
                        }), a = s(a, {
                            ready: !1,
                            ready_cb: T,
                            finished: !1,
                            finished_cb: U
                        }), k.finished = !1, k.scripts.push(a), S(g, a, k, Q && w), w = !0, g[z] && e.wait()));
                    }(arguments[f], arguments[f]);
                    return e;
                },
                wait: function() {
                    if (arguments.length > 0) {
                        for (var a = 0; a < arguments.length; a++) h.push(arguments[a]);
                        k = h[h.length - 1];
                    } else k = !1;
                    return x(), e;
                }
            }, {
                script: e.script,
                wait: e.wait,
                setOptions: function(a) {
                    return s(a, g), e;
                }
            };
        }
        var m, l = {}, Q = r || M, n = [], p = {};
        return l[y] = !0, l[z] = !1, l[u] = !1, l[A] = !1, l[B] = "", m = {
            setGlobalDefaults: function(a) {
                return s(a, l), m;
            },
            setOptions: function() {
                return v().setOptions.apply(null, arguments);
            },
            script: function() {
                return v().script.apply(null, arguments);
            },
            wait: function() {
                return v().wait.apply(null, arguments);
            },
            queueScript: function() {
                return n[n.length] = {
                    type: "script",
                    args: [].slice.call(arguments)
                }, m;
            },
            queueWait: function() {
                return n[n.length] = {
                    type: "wait",
                    args: [].slice.call(arguments)
                }, m;
            },
            runQueue: function() {
                for (var d, a = m, c = n.length, b = c; --b >= 0; ) d = n.shift(), a = a[d.type].apply(null, d.args);
                return a;
            },
            noConflict: function() {
                return o.$LAB = K, m;
            },
            sandbox: function() {
                return J();
            }
        };
    }
    var K = o.$LAB, y = "UseLocalXHR", z = "AlwaysPreserveOrder", u = "AllowDuplicates", A = "CacheBust", B = "BasePath", C = /^[^?#]*\//.exec(location.href)[0], D = /^\w+\:\/\/\/?[^\/]+/.exec(C)[0], i = document.head || document.getElementsByTagName("head"), L = o.opera && "[object Opera]" == Object.prototype.toString.call(o.opera) || "MozAppearance" in document.documentElement.style, q = document.createElement("script"), E = "boolean" == typeof q.preload, r = E || q.readyState && "uninitialized" == q.readyState, F = !r && q.async === !0, M = !r && !F && !L;
    o.$LAB = J(), function(a, c, b) {
        null == document.readyState && document[a] && (document.readyState = "loading", 
        document[a](c, b = function() {
            document.removeEventListener(c, b, !1), document.readyState = "complete";
        }, !1));
    }("addEventListener", "DOMContentLoaded");
}(this), function() {
    angular.module("app", []).constant("info", {});
}(), function() {
    function run(info, c8yUser) {
        info.token && !info.preventGetUser && c8yUser.current();
    }
    var core = angular.module("c8y.core", [ "angularFileUpload" ]);
    core.run([ "info", "c8yUser", run ]);
}(), function() {
    function run($rootScope, $window, $q, info, c8yUser) {
        function setTokenFromStorage() {
            var token = $window.localStorage.getItem(STORAGE_KEY) || $window.sessionStorage.getItem(STORAGE_KEY);
            info.token = token;
        }
        function setupAfterLogin() {
            return !info.token || info.preventGetUser ? $q.reject("No token") : void c8yUser.current().then(function(user) {
                var c8y = $rootScope.c8y = $rootScope.c8y || {};
                c8y.user = user, $rootScope.$emit("c8y.api.login");
            });
        }
        setTokenFromStorage(), setupAfterLogin();
    }
    function createGetters(info) {
        function getBaseUrl() {
            return info.baseUrl;
        }
        function getAppKey() {
            return info.appKey;
        }
        function getTenant() {
            return info.tenant;
        }
        return {
            getBaseUrl: getBaseUrl,
            getAppKey: getAppKey,
            getTenant: getTenant
        };
    }
    function c8yCumulocityProvider(info) {
        function setBaseUrl(baseUrl) {
            info.baseUrl = baseUrl;
        }
        function setAppKey(appKey) {
            info.appKey = appKey;
        }
        function setTenant(tenant) {
            info.tenant = tenant;
        }
        var result = {
            setBaseUrl: setBaseUrl,
            setAppKey: setAppKey,
            setTenant: setTenant,
            $get: [ "info", "$window", "$rootScope", "c8yUser", c8yCumulocity ]
        };
        return _.assign(result, createGetters(info)), result;
    }
    function c8yCumulocity(info, $window, $rootScope, c8yUser) {
        function login(tenant, user, password, remember) {
            return tenant = tenant || getters.getTenant(), c8yUser.login(tenant, user, password, remember).then(setUser).then(function() {
                $rootScope.$emit("c8y.api.login");
            });
        }
        function setUser(user) {
            var c8y = $rootScope.c8y = $rootScope.c8y || {};
            c8y.user = user;
        }
        function logout() {
            setUser(null), c8yUser.logout(), $rootScope.$emit("c8y.api.logout");
        }
        var getters = createGetters(info), result = {
            login: login,
            logout: logout
        };
        return _.assign(result, getters), result;
    }
    var STORAGE_KEY = "_tcy8";
    angular.module("c8y.core").provider("c8yCumulocity", [ "info", c8yCumulocityProvider ]).run([ "$rootScope", "$window", "$q", "info", "c8yUser", run ]);
}(), angular.module("c8y.core").factory("c8yAlarms", [ "$http", "c8yBase", "c8yCounter", "$q", function($http, c8yBase, c8yCounter, $q) {
    function buildDetailUrl(alarm) {
        var id = alarm.id || alarm;
        return c8yBase.url(path + "/" + id);
    }
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.timeOrderFilter(c8yBase.pageSizeNoTotalFilter(filters)), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("alarms", list, _filters);
        return $http.get(url, cfg).then(onList);
    }
    function detail(alarm) {
        var url = buildDetailUrl(alarm);
        return $http.get(url);
    }
    function create(alarm) {
        var url = c8yBase.url(path), data = clean(alarm, removeKeys);
        return $http.post(url, data, defaultConfig);
    }
    function update(alarm) {
        var url = buildDetailUrl(alarm), data = clean(alarm, removeKeysOnUpdate);
        return $http.put(url, data, defaultConfig);
    }
    function save(alarm) {
        return alarm.id ? update(alarm) : create(alarm);
    }
    function acknowledgedBy(alarm) {
        var history = alarm.history && alarm.history.auditRecords || [], ackBy = "--";
        return alarm.status === status.ACKNOWLEDGED && (ackBy = history[history.length - 1].user), 
        history.forEach(function(historyItem) {
            var changes = historyItem.changes || [], acknowledged = !1;
            return changes.forEach(function(change) {
                return change.attribute === statusAttribute && change.newValue === status.ACKNOWLEDGED ? (acknowledged = !0, 
                !1) : void 0;
            }), acknowledged ? (ackBy = historyItem.user || ackBy, !1) : void 0;
        }), ackBy;
    }
    function ackTime(alarm) {
        var history = alarm.history && alarm.history.auditRecords || [], time = history.length ? history[history.length - 1].creationTime : void 0;
        return history.forEach(function(historyItem) {
            var changes = historyItem.changes || [], found = !1;
            return changes.forEach(function(change) {
                return change.attribute === statusAttribute && change.newValue === status.ACKNOWLEDGED ? (time = historyItem.creationTime, 
                found = !0, !1) : void 0;
            }), found ? !1 : void 0;
        }), time;
    }
    function alarmDuration(alarm) {
        var history = alarm.history && alarm.history.auditRecords || [], time = alarm.creationTime, endTime = history.length ? history[history.length - 1].creationTime : void 0, diff = "";
        if (_.forEach(history, function(historyItem) {
            var changes = historyItem.changes || [], found = !1;
            return changes.forEach(function(change) {
                return change.attribute === statusAttribute && change.newValue === status.CLEARED ? (endTime = historyItem.creationTime, 
                found = !0, !1) : void 0;
            }), found ? !1 : void 0;
        }), time && endTime) {
            var _time = moment(time), _endTime = moment(endTime);
            diff = moment.duration(_time.diff(_endTime)).humanize();
        }
        return diff;
    }
    function parseChanges(changes) {
        var _changes = changes || [], outList = [];
        return _changes.forEach(function(change) {
            return "revision" === change.attribute ? !0 : void outList.push(change.attribute + ": " + change.previousValue + " > " + change.newValue);
        }), outList.join(" ; ");
    }
    function isReservedKey(key) {
        return -1 !== reservedKeys.indexOf(key);
    }
    function isNotReservedKey(key) {
        return !isReservedKey(key);
    }
    function getKeys(alarm) {
        var _alarm = angular.copy(alarm), props = Object.keys(_alarm);
        return props.filter(isNotReservedKey);
    }
    function icon(alarm) {
        var severity = (angular.isObject(alarm) ? alarm.severity : alarm).toUpperCase();
        return icons[severity];
    }
    function buildReportUrl(report, filters) {
        var parts = [ pathReports, report ];
        return filters.id && parts.push(filters.id), c8yBase.url(parts.join("/"));
    }
    function reportDownTimeDuration(filters) {
        var report = "downtimeDuration", _filters = c8yBase.timeOrderFilter(filters), url = buildReportUrl(report, _filters), cfg = {
            params: _filters
        };
        return $http.get(url, cfg);
    }
    function createCounter(filter) {
        var counter = new c8yCounter.Counter(list, "/alarms/*");
        if (filter) {
            var filterConfig = [ c8yCounter.defaultPropertyMaps.date, c8yCounter.defaultPropertyMaps.source ];
            if (filter.type) {
                var type = filter.type;
                filterConfig.push([ function(obj) {
                    return type === obj.type;
                } ]);
            }
            delete filter.type, counter.filter(filter, filterConfig);
        }
        return counter;
    }
    function listByStatus(status, filters) {
        return $q.all(_.map(status, function(value, key) {
            return value ? (filters.status = key, list(filters)) : void 0;
        })).then(onAlarms);
    }
    function listByDevices(ids, filters) {
        return $q.all(_.map(ids, function(id) {
            return filters.source = id, list(filters);
        })).then(onAlarms);
    }
    function getSeverityCount(alarms, severity) {
        var result = _.where(alarms, {
            severity: severity
        });
        return result.length;
    }
    function onAlarms(alarms) {
        return _.filter(alarms, function(alarm) {
            return angular.isDefined(alarm);
        });
    }
    var clean = c8yBase.cleanFields, path = "alarm/alarms", pathReports = path + "/reports", defaultConfig = {
        headers: c8yBase.contentHeaders("alarm")
    }, severity = {
        WARNING: "WARNING",
        MINOR: "MINOR",
        MAJOR: "MAJOR",
        CRITICAL: "CRITICAL"
    }, severityList = Object.keys(severity), status = {
        ACTIVE: "ACTIVE",
        ACKNOWLEDGED: "ACKNOWLEDGED",
        CLEARED: "CLEARED"
    }, statusList = Object.keys(status), _reservedKeys = [ "history", "id", "severity", "self", "source", "creationTime", "time", "text", "firstOccurrence", "count", "firstOccurrenceTime" ], reservedKeys = [ "status" ].concat(_reservedKeys), removeKeys = [ "id" ], removeKeysOnUpdate = [ "id", "self", "creationTime", "type", "time", "count", "history", "firstOccurence", "firstOccurrenceTime" ], icons = {}, statusAttribute = "status";
    return icons[severity.WARNING] = "circle", icons[severity.MINOR] = "exclamation-circle", 
    icons[severity.MAJOR] = "exclamation-circle", icons[severity.CRITICAL] = "warning", 
    icons[status.CLEARED] = "check-circle", icons[status.ACKNOWLEDGED] = "eye", icons[status.ACTIVE] = "bell", 
    {
        list: list,
        listByStatus: listByStatus,
        listByDevices: listByDevices,
        getSeverityCount: getSeverityCount,
        detail: detail,
        update: update,
        create: create,
        save: save,
        acknowledgedBy: acknowledgedBy,
        ackTime: ackTime,
        alarmDuration: _.memoize(alarmDuration, function(a) {
            return a.id;
        }),
        parseChanges: parseChanges,
        severity: severity,
        severityList: severityList,
        status: status,
        statusList: statusList,
        reservedKeys: reservedKeys,
        icon: icon,
        getKeys: getKeys,
        reports: {
            downtimeDuration: reportDownTimeDuration
        },
        createCounter: createCounter
    };
} ]), angular.module("c8y.core").factory("c8yAudits", [ "$http", "c8yBase", function($http, c8yBase) {
    function create(audit) {
        var url = c8yBase.url(path), data = clean(audit, removeKeys);
        return $http.post(url, data, defaultConfig);
    }
    function isReservedKey(key) {
        return -1 !== reservedKeys.indexOf(key);
    }
    function isNotReservedKey(key) {
        return !isReservedKey(key);
    }
    function getKeys(alarm) {
        var _alarm = angular.copy(alarm), props = Object.keys(_alarm);
        return props.filter(isNotReservedKey);
    }
    var clean = c8yBase.cleanFields, path = "audit/auditRecords", defaultConfig = {
        headers: c8yBase.contentHeaders("auditRecord")
    }, severity = {
        WARNING: "WARNING",
        MINOR: "MINOR",
        MAJOR: "MAJOR",
        CRITICAL: "CRITICAL"
    }, severityList = Object.keys(severity), _reservedKeys = [ "id", "self", "creationTime" ], reservedKeys = _reservedKeys, removeKeys = _reservedKeys;
    return {
        create: create,
        severity: severity,
        severityList: severityList,
        reservedKeys: reservedKeys,
        getKeys: getKeys
    };
} ]), angular.module("c8y.core").factory("c8yApplication", [ "$http", "$location", "$q", "$window", "$interval", "c8yBase", "c8yUser", "c8yInventory", function($http, $location, $q, $window, $interval, c8yBase, c8yUser, c8yInventory) {
    function clean(app) {
        var _app = angular.copy(app);
        return delete _app.type, delete _app.key, _app;
    }
    function _list(path, filters) {
        return c8yUser.current().then(function(user) {
            var tenant = user.tenant, _filters = c8yBase.pageSizeFilter(filters), cfg = {
                params: _filters,
                cache: !0
            }, url = c8yBase.url(path) + "/" + tenant, onList = c8yBase.cleanListCallback("applications", angular.bind(self, _list, path), _filters);
            return $http.get(url, cfg).then(onList);
        });
    }
    function listByUser(user, filters) {
        return c8yUser.current().then(function(currentUser) {
            user = user || currentUser;
            var _filters = c8yBase.pageSizeFilter(filters), cfg = {
                params: _filters,
                cache: !0
            }, url = c8yBase.url(basePath + "applicationsByUser/" + user.id), onList = c8yBase.cleanListCallback("applications", angular.bind(self, listByUser, user), _filters);
            return $http.get(url, cfg).then(onList);
        });
    }
    function listByOwner(filters) {
        return _list(basePath + "applicationsByOwner", filters);
    }
    function listByTenant(filters) {
        return _list(basePath + "applicationsByTenant", filters);
    }
    function listPlugins() {
        var url = c8yBase.url(basePath + "plugins"), cfg = {
            params: c8yBase.pageSizeNoTotalFilter()
        };
        return $http.get(url, cfg).then(function(res) {
            return _.unique(res.data.plugins, "id");
        });
    }
    function listPluginsByTenant() {
        return listByTenant().then(function(apps) {
            apps = _.uniq(apps, "id");
            var pluginPromises = [];
            return angular.forEach(apps, function(app) {
                isHostedApp(app) && pluginPromises.push(listPluginsByApplication(app));
            }), $q.all(pluginPromises).then(_.flatten).then(_.partialRight(_.unique, function(p) {
                return p.id;
            }));
        });
    }
    function listPluginsByApplication(app) {
        var url = c8yBase.url(basePath2 + "/" + app.contextPath + "/manifest"), cfg = {
            params: c8yBase.pageSizeNoTotalFilter()
        };
        return $http.get(url, cfg).then(function(res) {
            return _.map(res.data.imports, getPluginFromImportedManifest);
        });
    }
    function getPluginFromImportedManifest(manifest) {
        return {
            id: manifest.id,
            contextPath: manifest.rootContextPath,
            directoryName: manifest.directoryName,
            manifest: manifest
        };
    }
    function buildDetailUrl(app) {
        var id = app.id || app;
        return c8yBase.url(basePath2 + "/" + id);
    }
    function detail(app) {
        var url = buildDetailUrl(app);
        return $http.get(url);
    }
    function remove(app) {
        var url = buildDetailUrl(app), _app = angular.isObject(app) ? app : {
            id: app
        }, actions = [], configPromise = getConfig(_app).then(function(app) {
            return app.config && app.config.id ? c8yInventory.remove(app.config) : !0;
        });
        return actions.push(configPromise), actions.push($http["delete"](url)), $q.all(actions);
    }
    function update(app) {
        var url = buildDetailUrl(app), cleanData = clean(app), cfg = angular.copy(defaultConfig);
        return $http.put(url, cleanData, cfg)["finally"](function() {
            $window.localStorage.setItem("refresh", app.contextPath);
        });
    }
    function create(app) {
        var url = c8yBase.url(basePath2), cfg = angular.copy(defaultConfig);
        return $http.post(url, app, cfg);
    }
    function updateManifest(appId, manifest) {
        return detail(appId).then(function(res) {
            var app = res.data;
            return app.manifest = manifest, app;
        }).then(update);
    }
    function save(app) {
        return app.id ? update(app) : create(app);
    }
    function createUrl(app) {
        var port = $location.port();
        return port = 80 === port || 443 === port ? "" : ":" + port, $location.protocol() + "://" + $location.host() + port + "/apps/" + app.contextPath;
    }
    function getCurrentContextPath() {
        var match = $window.location.pathname.match(/\/apps\/(\w+)\/?/);
        return match && match[1];
    }
    function getCurrent() {
        var currentContextPath = getCurrentContextPath();
        return listByUser().then(function(applications) {
            var currentApp = {};
            return applications.forEach(function(app) {
                return app.contextPath === currentContextPath ? (currentApp = app, !1) : void 0;
            }), currentApp;
        });
    }
    function getAppConfig(_app) {
        return c8yInventory.list({
            type: "c8y_SmartAppApplication"
        }).then(function(apps) {
            var config = null;
            return apps.forEach(function(app) {
                return app.appId === _app.id ? (config = app, !1) : void 0;
            }), config;
        });
    }
    function getConfig(app) {
        var outputApp, promise = app ? $q.when(app) : getCurrent();
        return promise.then(function(app) {
            return outputApp = app, app;
        }).then(getAppConfig).then(function(config) {
            return outputApp.config = config, outputApp;
        });
    }
    function getRefreshMessage(ignore) {
        var contextPath = $window.localStorage.getItem("refresh");
        contextPath === getCurrentContextPath() && ($window.localStorage.setItem("refresh", void 0), 
        ignore || $window.location.reload());
    }
    function getHref(app) {
        return isHostedApp(app) ? createUrl(app) : app.externalUrl;
    }
    function icon(application) {
        var type = angular.isString(application) ? application : application.type;
        return application.manifest && (type = "SMARTAPP"), iconMap[type];
    }
    function pollRefreshMessages() {
        $interval(function() {
            getRefreshMessage();
        }, 1e3, 0, !1);
    }
    function filterApplications(apps) {
        var unique = _.uniq(apps, function(app) {
            return app.id;
        }), hidden = _.filter(unique, function(app) {
            var noAppSwitcher = app.manifest && app.manifest.noAppSwitcher;
            return noAppSwitcher !== !0;
        });
        return hidden;
    }
    function listByVisibleLinks() {
        return listByUser().then(filterApplications).then(function(applications) {
            return $q.when(applications);
        });
    }
    function isHostedApp(app) {
        return "HOSTED" === app.type;
    }
    var basePath = "application/", basePath2 = basePath + "applications", defaultConfig = {
        headers: c8yBase.contentHeaders("application", !0)
    }, self = this, iconMap = {
        HOSTED: "cloud",
        EXTERNAL: "external-link-square",
        SMARTAPP: "puzzle-piece"
    };
    return getRefreshMessage(!0), {
        list: listByTenant,
        listByUser: listByUser,
        listByTenant: listByTenant,
        listByOwner: listByOwner,
        listPlugins: listPlugins,
        listPluginsByTenant: listPluginsByTenant,
        listPluginsByApplication: listPluginsByApplication,
        listByVisibleLinks: listByVisibleLinks,
        detail: detail,
        update: update,
        create: create,
        remove: remove,
        save: save,
        getHref: getHref,
        icon: icon,
        getCurrent: getCurrent,
        getConfig: getConfig,
        pollRefreshMessages: pollRefreshMessages,
        getCurrentContextPath: getCurrentContextPath,
        updateManifest: updateManifest
    };
} ]), angular.module("c8y.core").factory("c8yAuth", [ "$location", "$window", "info", function($location, $window, info) {
    function decodeToken(token) {
        var decoded = atob(token), split = decoded.match(/(([^\/]*)\/)?([^\/:]+):(.+)/);
        return {
            tenant: split[2],
            user: split[3],
            password: split[4]
        };
    }
    function encodeToken(user, password, tenant) {
        return tenant = tenant ? tenant + "/" : "", btoa(tenant + user + ":" + password);
    }
    function updatePassword(password) {
        var decodedToken = decodeToken(token);
        info.token = token = encodeToken(decodedToken.user, password, decodedToken.tenant), 
        $window.localStorage.setItem(TOKEN_KEY, token);
    }
    function transformRequest(config) {
        var url = config.url, isCumulocity = !url.match(/http/) || url.match(/^https?\:\/\/.*cumulocity\.com/);
        return isCumulocity && (config.headers || (config.headers = {}), config.headers.Authorization || (config.headers.Authorization = "Basic " + info.token), 
        angular.extend(config.headers, {
            UseXBasic: !0
        })), config;
    }
    function logout() {
        angular.isFunction(info.logout) && info.logout();
    }
    var token = info.token, TOKEN_KEY = "_tcy8";
    return {
        decodeToken: decodeToken,
        logout: logout,
        updatePassword: updatePassword,
        request: transformRequest
    };
} ]).config([ "$httpProvider", function($httpProvider) {
    $httpProvider.interceptors.push("c8yAuth");
} ]), angular.module("c8y.core").factory("c8yBase", [ "$rootScope", "$http", "$window", "info", function($rootScope, $http, $window, info) {
    function mimeType(type) {
        return NAMESPACE + type + "+json";
    }
    function contentHeaders(contentType, acceptType) {
        return {
            "Content-Type": mimeType(contentType),
            Accept: acceptType ? mimeType(angular.isString(acceptType) ? acceptType : contentType) : void 0
        };
    }
    function deleteProperties(obj, properties) {
        var _obj = angular.copy(obj);
        return properties.forEach(function(property) {
            delete _obj[property];
        }), _obj;
    }
    function url(path) {
        return basePath() + path;
    }
    function pageSizeNoTotalFilter(filter) {
        return angular.extend({
            pageSize: pageSize
        }, filter);
    }
    function pageSizeFilter(filter) {
        return angular.extend({
            withTotalPages: !0,
            pageSize: pageSize
        }, filter);
    }
    function timeOrderFilter(filter) {
        return angular.extend({
            dateFrom: "1970-01-01",
            dateTo: moment().add(1, "day").format(dateFormat)
        }, filter);
    }
    function lastWeekFilter(filter) {
        return angular.extend({
            dateFrom: moment().subtract(1, "week").format(dateFormat),
            dateTo: moment().add(1, "day").format(dateFormat)
        }, filter);
    }
    function fromThisMonthStartFilter(filter) {
        return angular.extend({
            dateFrom: moment().startOf("month").format(dateFormat)
        }, filter);
    }
    function todayFilter(filter) {
        return angular.extend({
            dateFrom: moment().subtract(1, "day").format(dateFormat),
            dateTo: moment().add(1, "day").format(dateFormat)
        }, filter);
    }
    function getParamFromUrl(paramName, url) {
        var params = {};
        return url && url.split("?")[1].split("&").forEach(function(param) {
            var split = param.split("=");
            params[split[0]] = decodeURIComponent(split[1]);
        }), params[paramName];
    }
    function buildPagingObject(data, step) {
        var stats = data.statistics, page = 1 === step ? "next" : "prev", pageUrl = data[page], result = {
            currentPage: stats.currentPage,
            pageSize: stats.pageSize,
            startkey: getParamFromUrl("startkey", pageUrl),
            startkey_docid: getParamFromUrl("startkey_docid", pageUrl)
        }, currentPageStr = getParamFromUrl("currentPage", pageUrl);
        return result.currentPage = parseInt(currentPageStr), result;
    }
    function buildRefreshObject(data) {
        var stats = data.statistics, result = {
            currentPage: 1,
            pageSize: stats.pageSize * stats.currentPage,
            startkey: null,
            startkey_docid: null
        };
        return angular.isDefined(data.totalPages) && (result.pageSize = stats.pageSize), 
        result;
    }
    function buildPaging(data, fn, filter, blindPaging) {
        var stats = data.statistics, hasPrev = angular.isDefined(data.prev), hasNext = angular.isDefined(data.next), output = {};
        if (hasPrev) {
            var prevFilter = angular.extend(angular.copy(filter), buildPagingObject(data, -1));
            output.prev = angular.bind({}, fn, prevFilter);
        }
        if (hasNext) {
            var nextFilter = angular.extend(angular.copy(filter), buildPagingObject(data, 1));
            output.next = angular.bind({}, fn, nextFilter), angular.isDefined(stats.totalPages) && (output.more = (stats.totalPages - stats.currentPage) * stats.pageSize);
        }
        var refreshFilter = angular.extend(angular.copy(filter), buildRefreshObject(data)), refreshFn = angular.bind({}, fn, refreshFilter);
        return output.statistics = stats, output.blind = blindPaging, output.refresh = function() {
            return refreshFn().then(function(list) {
                return list.statistics = stats, list.paging = buildPaging(data, fn, filter, blindPaging), 
                list;
            });
        }, output;
    }
    function cleanListCallback(name, listFn, filters) {
        return function(res) {
            var data = res.data, list = data[name];
            return list.statistics = data.statistics, filters.withTotalPages || list.length !== parseInt(filters.pageSize, 10) || (data.statistics.totalPages = list.statistics.totalPages = +(1 / 0)), 
            list.paging = buildPaging(data, listFn, filters, !filters.withTotalPages), list;
        };
    }
    function removeFromList(list, item) {
        var ix = list.indexOf(item);
        ix >= 0 && list.splice(ix, 1);
    }
    function cleanFields(obj, fields) {
        var _obj = angular.copy(obj);
        return fields.forEach(function(field) {
            delete _obj[field];
        }), _obj;
    }
    function invalid(scope, _form, _field) {
        var form = scope && scope[_form], field = form && form[_field], pristine = field && field.$pristine, _invalid = field && field.$invalid;
        return pristine === !1 && _invalid === !0;
    }
    function getCount(fn, filters) {
        return filters.pageSize = 1, filters.withTotalPages = !0, fn(filters).then(function(list) {
            return list.statistics.totalPages;
        });
    }
    function humanizeFragment(str) {
        return str || (str = ""), str.replace(/c8y_/, "").replace(/([A-Z])/g, " $1").replace(/^\s*/, "").replace(/\s*$/, "");
    }
    function getResData(res) {
        return res && res.data || res;
    }
    function createEnum(values) {
        var e = {}, ordinal = 0;
        return e.values = _.constant(_.map(values, function(value) {
            return angular.isObject(value) ? e[value.name] = {
                name: value.name,
                ordinal: ordinal++,
                value: value.value
            } : e[value] = {
                name: value,
                ordinal: ordinal++,
                value: value
            };
        })), e;
    }
    function createLocalId(mo, key) {
        if (key = key || "id", !angular.isObject(mo)) throw new Error("mo is not an object");
        return angular.isUndefined(mo[key]) && (mo[key] = String(Math.random()).substr(2)), 
        mo;
    }
    function getId(refId) {
        var id;
        if (angular.isObject(refId) && (id = refId.id), (angular.isNumber(refId) || angular.isString(refId) && refId.match(/^\d+$/)) && (id = String(refId)), 
        !id) throw new Error("id cannot be found");
        return id;
    }
    function checkIfModulesExist(modules) {
        try {
            return _.each(modules, function(module) {
                angular.module(module);
            }), !0;
        } catch (e) {
            return !1;
        }
    }
    var basePath = function() {
        return info.baseUrl || "/";
    }, HEADER_APPKEY = "X-Cumulocity-Application-Key", NAMESPACE = "application/vnd.com.nsn.cumulocity.", appKey = info.appKey, pageSize = info.pageSize || 1e3, dateFormat = "YYYY-MM-DD", dateFullFormat = "YYYY-MM-DDTHH:mm:ssZ";
    if (!appKey) throw new Error("Application key must be defined");
    return $http.defaults.headers.common[HEADER_APPKEY] = appKey, {
        url: url,
        deleteProperties: deleteProperties,
        mimeType: mimeType,
        contentHeaders: contentHeaders,
        PAGESIZE: pageSize,
        pageSizeFilter: pageSizeFilter,
        pageSizeNoTotalFilter: pageSizeNoTotalFilter,
        timeOrderFilter: timeOrderFilter,
        lastWeekFilter: lastWeekFilter,
        todayFilter: todayFilter,
        fromThisMonthStartFilter: fromThisMonthStartFilter,
        cleanListCallback: cleanListCallback,
        removeFromList: removeFromList,
        cleanFields: cleanFields,
        dateFormat: dateFormat,
        dateFullFormat: dateFullFormat,
        invalid: invalid,
        getCount: getCount,
        humanizeFragment: humanizeFragment,
        getResData: getResData,
        createEnum: createEnum,
        createLocalId: createLocalId,
        getId: getId,
        checkIfModulesExist: checkIfModulesExist
    };
} ]), angular.module("c8y.core").factory("c8yBinary", [ "$q", "$upload", "$http", "c8yBase", "c8yInventory", "info", function($q, $upload, $http, c8yBase, c8yInventory, info) {
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filters
        }, blindPaging = !0, onList = c8yBase.cleanListCallback("managedObjects", list, _filters, blindPaging);
        return $http.get(url, cfg).then(onList);
    }
    function upload(binary) {
        return $upload.upload({
            url: c8yBase.url(path),
            method: "POST",
            headers: c8yBase.contentHeaders("managedObject"),
            data: {
                object: {
                    name: binary.name,
                    type: binary.type
                },
                filesize: binary.size
            },
            file: binary
        });
    }
    function downloadAndSaveAs(binary) {
        return download(binary).then(function(xhr) {
            var contentType = xhr.getResponseHeader("Content-Type"), contentDisposition = xhr.getResponseHeader("Content-Disposition"), blob = new Blob([ xhr.response ], {
                type: contentType
            });
            saveAs(blob, getFilenameFromContentDisposition(contentDisposition));
        });
    }
    function getFilenameFromContentDisposition(contentDisposition) {
        return /filename="(.*)"/.exec(contentDisposition)[1];
    }
    function downloadAsDataUri(binary) {
        return download(binary).then(function(xhr) {
            var contentType = xhr.getResponseHeader("Content-Type"), base64 = arrayBufferToBase64(xhr.response);
            return "data:" + contentType + ";base64," + base64;
        });
    }
    function arrayBufferToBase64(buffer) {
        for (var binary = "", bytes = new Uint8Array(buffer), len = bytes.byteLength, i = 0; len > i; i++) binary += String.fromCharCode(bytes[i]);
        return btoa(binary);
    }
    function download(binary) {
        var deferred = $q.defer(), url = buildFileUrl(binary), xhr = new XMLHttpRequest();
        return xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function(e) {
            200 === xhr.status ? deferred.resolve(xhr) : deferred.reject(xhr);
        }, xhr.onprogress = function(e) {
            angular.isDefined(e.loaded) && deferred.notify(e.loaded / size(binary));
        }, xhr.setRequestHeader("Authorization", "Basic " + info.token), xhr.setRequestHeader("UseXBasic", !0), 
        xhr.send(), deferred.promise;
    }
    function buildFileUrl(binary) {
        var id = binary.id || binary;
        return c8yBase.url(path + "/" + id);
    }
    function getDownloadUrl(binary) {
        return binary && binary.self && binary.self.replace(c8yBase.url(managedObjectsPath), c8yBase.url(path));
    }
    function removeBinary(binary) {
        var url = buildFileUrl(binary);
        return $http["delete"](url);
    }
    function icon(binary) {
        var targetIcon = [ "file", "o" ], fileGenericType = getFileGenericType(binary);
        return fileGenericType && targetIcon.splice(1, 0, fileGenericType), targetIcon.join("-");
    }
    function getFileGenericType(binary) {
        var type = "";
        return angular.forEach(fileTypeIconsMap, function(iconCfg, icon) {
            var moExt = fileNameRegexp.exec(binary.name)[1];
            if (angular.forEach(iconCfg.exts, function(ext) {
                return ext === moExt ? (type = icon, !1) : void 0;
            }), !type) {
                var moMime = binary._attachments[Object.keys(binary._attachments)[0]].content_type;
                angular.forEach(iconCfg.mimes, function(mime) {
                    return mime === moMime ? (type = icon, !1) : void 0;
                });
            }
        }), type;
    }
    function size(binary) {
        return binary._attachments[Object.keys(binary._attachments)[0]].length;
    }
    function isImage(binary) {
        var fileGenericType = getFileGenericType(binary);
        return "image" === fileGenericType;
    }
    function hasValidSize(file) {
        return file && file.size <= BYTES_SIZE_LIMIT;
    }
    function save(binary) {
        return binary.id ? update(binary) : create(binary);
    }
    function create(binary) {
        var mo = angular.extend(binary, {
            c8y_IsBinary: !0
        });
        return c8yInventory.createConfirm(mo);
    }
    function update(binary) {
        return c8yInventory.update(binary);
    }
    function detail(binaryId, params) {
        return c8yInventory.detail(binaryId, params);
    }
    function remove(binary) {
        return c8yInventory.remove(binary);
    }
    function getDataUri(binary) {
        return binary && binary.dataType && binary.data ? "data:" + binary.dataType + ";base64," + binary.data : "";
    }
    function getIdFromUrl(url) {
        var regexp = new RegExp("\\/inventory\\/binaries\\/(\\d+)|\\/inventory\\/managedObjects\\/(\\d+)"), matches = url.match(regexp);
        return matches && (matches[1] || matches[2]);
    }
    var path = "inventory/binaries", managedObjectsPath = "inventory/managedObjects", BYTES_SIZE_LIMIT = 52428800, fileNameRegexp = /(?:\.([^.]+))?$/, fileTypeIconsMap = {
        archive: {
            mimes: [],
            exts: [ "7z", "apk", "cab", "gz", "iso", "jar", "rar", "tar", "zip" ]
        },
        audio: {
            mimes: [],
            exts: [ "3gp", "aiff", "aac", "amr", "m4a", "m4p", "mp3", "oga", "ogg", "raw", "wav", "wma" ]
        },
        code: {
            mimes: [],
            exts: [ "aspx", "exe", "htm", "html", "jad", "js", "json", "jsp", "php", "xml" ]
        },
        excel: {
            mimes: [],
            exts: [ "xls", "xlsx" ]
        },
        image: {
            mimes: [],
            exts: [ "bmp", "gif", "jpeg", "jpg", "png", "tiff" ]
        },
        pdf: {
            mimes: [],
            exts: [ "pdf" ]
        },
        powerpoint: {
            mimes: [],
            exts: [ "ppt", "pptx" ]
        },
        text: {
            mimes: [],
            exts: [ "txt" ]
        },
        video: {
            mimes: [],
            exts: [ "3gp", "asf", "avi", "flv", "mov", "mp4", "ogv", "qt", "rm", "rmvb", "wmv" ]
        },
        word: {
            mimes: [],
            exts: [ "doc", "docx" ]
        }
    };
    return angular.extend(angular.copy(c8yInventory), {
        BYTES_SIZE_LIMIT: BYTES_SIZE_LIMIT,
        list: list,
        upload: upload,
        downloadAndSaveAs: downloadAndSaveAs,
        downloadAsDataUri: downloadAsDataUri,
        getDownloadUrl: getDownloadUrl,
        removeBinary: removeBinary,
        icon: icon,
        size: size,
        isImage: isImage,
        hasValidSize: hasValidSize,
        getIdFromUrl: getIdFromUrl,
        save: save,
        detail: detail,
        remove: remove,
        getDataUri: getDataUri
    });
} ]), angular.module("c8y.core").factory("c8yCepModule", [ "$http", "$q", "$timeout", "c8yBase", "c8yCepModuleExamples", function($http, $q, $timeout, c8yBase, c8yCepModuleExamples) {
    function wrapFileBody(body) {
        var _boundary = "--" + boundary(), output = _boundary + '\r\nContent-Disposition: form-data; name="file"; filename="module.cep"\r\nContent-Type: text/plain\r\n\r\n' + body + "\r\n" + _boundary;
        return output;
    }
    function boundary() {
        return "83ff53821b7c";
    }
    function updateStatus(module) {
        var url = c8yBase.url(path + "/" + module.id), cfg = {
            headers: c8yBase.contentHeaders(contentType, !0)
        }, data = {
            status: module.status
        };
        if (!module.id) throw new Error("Module id no defined");
        return $http.put(url, data, cfg);
    }
    function updateModule(module) {
        var id = module.id, url = c8yBase.url(path + (id ? "/" + id : "")), body = wrapFileBody(module.body), method = id ? "put" : "post", headers = angular.extend(c8yBase.contentHeaders(contentType, !0), {
            "Content-Type": "multipart/form-data; boundary=" + boundary()
        }), cfg = {
            headers: headers
        };
        return $http[method](url, body, cfg);
    }
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("modules", list, _filters);
        return $http.get(url, cfg).then(filterSmartRulesFromRes).then(onList);
    }
    function filterSmartRulesFromRes(res) {
        return res.data.modules = _.filter(res.data.modules, function(module) {
            return !isSmartRuleModule(module);
        }), res;
    }
    function isSmartRuleModule(module) {
        return module && /^smartRule\d+$/.test(module.name);
    }
    function listWithSmartRules(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("modules", listWithSmartRules, _filters);
        return $http.get(url, cfg).then(onList);
    }
    function detail(_module) {
        var id = _module.id || _module, url = c8yBase.url(path + "/" + id), def = $q.defer(), body = null, module = null, fileConfig = {
            headers: {
                "Content-Type": "text/plain",
                Accept: "text/plain"
            }
        }, dataConfig = {
            headers: {
                Accept: c8yBase.mimeType(contentType)
            }
        }, checkFinal = function() {
            if (body && module) {
                var nameMatch = /module (\w*);\s*\n*/;
                module.name = body.match(nameMatch)[1], module.body = body.replace(nameMatch, ""), 
                def.resolve(module);
            }
        };
        return $http.get(url, dataConfig).then(function(res) {
            module = res.data, $http.get(url, fileConfig).success(function(data) {
                body = data, checkFinal();
            });
        }), def.promise;
    }
    function remove(module) {
        var id = module.id || module, url = c8yBase.url(path + "/" + id);
        return $http["delete"](url);
    }
    function save(_module) {
        var firstStep, def = $q.defer(), module = angular.copy(_module);
        return module.body ? (module.name && (module.body = "module " + module.name + ";\n" + module.body), 
        firstStep = updateModule(module).then(null, function(data) {
            def.reject(data);
        })) : firstStep = detail(module), firstStep.then(function(res) {
            var _module = res.body ? res : res.data;
            module.status && _module.status !== module.status ? (_module.status = module.status, 
            updateStatus(_module).then(function(res) {
                def.resolve(res.data);
            }, function(res) {
                def.reject(res.data);
            })) : def.resolve(_module);
        }), def.promise;
    }
    function detailByName(name) {
        return list().then(function(modules) {
            var _module;
            return modules.forEach(function(m) {
                return m.name === name ? (_module = m, !1) : void 0;
            }), _module || $q.reject("not found");
        });
    }
    function createOrDeploy(module) {
        var name = module.name;
        return cacheCreateOrDeploy[name] || (cacheCreateOrDeploy[name] = detailByName(name).then(function(module) {
            return "DEPLOYED" !== module.status ? (module.status = "DEPLOYED", save(module)) : module;
        }, function() {
            return save(module);
        })), cacheCreateOrDeploy[name];
    }
    function deploy(module) {
        return module.status = "DEPLOYED", save(module);
    }
    function redeploy(module) {
        return undeploy(module).then(deploy);
    }
    function undeploy(module) {
        return module.status = "NOT_DEPLOYED", save(module);
    }
    function examples() {
        return $q.when(c8yCepModuleExamples);
    }
    var path = "cep/modules", contentType = "cepModule", cacheCreateOrDeploy = {};
    return {
        list: list,
        listWithSmartRules: listWithSmartRules,
        isSmartRuleModule: isSmartRuleModule,
        detail: detail,
        save: save,
        remove: remove,
        examples: examples,
        detailByName: detailByName,
        createOrDeploy: createOrDeploy,
        deploy: deploy,
        redeploy: redeploy,
        undeploy: undeploy
    };
} ]).value("c8yCepModuleExamples", [ {
    name: "Send alarms that are active since 30 minutes to email",
    value: 'insert into SendEmail\nselect\n  "info@cumulocity.com" as sender,\n  "YOUR_EMAIL_HERE" as receiver,\n  "Alarm active since 30 mins: " || e.alarm.text as subject,\n  "Time: " || e.alarm.time.format() || \n  " Severity: " || e.alarm.severity.name() || \n  " Source: " || findManagedObjectById(e.alarm.source.value).getName() as text\nfrom pattern [\n   every e = AlarmCreated(alarm.status = CumulocityAlarmStatuses.ACTIVE, alarm.severity = CumulocitySeverities.CRITICAL) \n   -> (timer:interval(30 minutes) \n      and not AlarmUpdated(alarm.status != CumulocityAlarmStatuses.ACTIVE, alarm.id.value = e.alarm.id.value))\n];'
}, {
    name: "Select temperature readings over 100 degree",
    value: 'select * from MeasurementCreated e\nwhere getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
}, {
    name: "Create alarm when temperature over 100 degree",
    value: 'insert into CreateAlarm \n  select\n    e.measurement.time as time,\n    e.measurement.source.value as source,\n    "com_cumulocity_TemperatureAlert" as type,\n    "Temperature too high" as text,\n    "ACTIVE" as status,\n    "CRITICAL" as severity\n  from MeasurementCreated e\n  where getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
}, {
    name: "Create alarm when temperature below 0 degree",
    value: 'insert into CreateAlarm \n  select\n    e.measurement.time as time,\n    e.measurement.source.value as source,\n    "com_cumulocity_TemperatureAlert" as type,\n    "Temperature too low" as text,\n    "ACTIVE" as status,\n    "CRITICAL" as severity\n  from MeasurementCreated e\n  where getNumber(e, "c8y_TemperatureMeasurement.T.value") < 0'
}, {
    name: "Create close relay operation when temperature readings over 100 degree",
    value: 'insert into CreateOperation\n  select\n    "PENDING" as status,\n    heating ID as deviceId,\n    {\n      "c8y_Relay.relayState", "CLOSED"\n    } as fragments\n  from MeasurementCreated e\n  where getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
}, {
    name: "Schedule device restart every day at 1am",
    value: 'insert into CreateOperation\nselect\n  "PENDING" as status,\n  device ID as deviceId,\n  { "c8y_Restart", {} } as fragments\nfrom pattern [every timer:at(*, 1, *, *, *, *)];'
}, {
    name: "Select location change event once for 60 seconds",
    value: 'select * from EventCreated e\nwhere getObject(e, "c8y_LocationMeasurement") is not null\noutput first every 60 seconds'
}, {
    name: "Display current temperature on device",
    value: 'expression string js:prepareText(temp) [\n  function format(text, params){\n    for(param in params) {\n        text = text.replace("{" + param + "}", params[param])\n    }\n    return text\n  }\n  format("Current temperature is {0}", [temp])\n]\ninsert into CreateOperation\n	select\n      "PENDING" as status,\n      e.measurement.source.value as deviceId,\n      { "c8yDisplay", prepareText(\n        getNumber(e, "c8y_TemperatureMeasurement.T.value")\n	   ) } as fragments\n    from MeasurementCreated e\n    where e.measurement.type = "c8y_TemperatureMeasurement";'
}, {
    name: "Change the severities of alarms based on activity time",
    value: '/* Create "context" - definition of a group of events to be processed separately.\n * Context "Alarms" consists of AlarmCreated and AlarmUpdated: \n * with the same source and type = "power off". */\ncreate context Alarms partition by \nalarm.source from AlarmCreated(alarm.type = "power off"),\nalarm.source from AlarmUpdated(alarm.type = "power off");\n\n/* Update severity for all active AlarmCreated \n * after which there is no change to other status in 15 minutes. */\ncontext Alarms \ninsert into UpdateAlarm \nselect \n   a.alarm.id as id,\n   "MAJOR" as severity\nfrom pattern [\n   every a = AlarmCreated(alarm.status = CumulocityAlarmStatuses.ACTIVE) \n   -> (timer:interval(15 minutes) \n      and not AlarmUpdated(alarm.status != CumulocityAlarmStatuses.ACTIVE))\n];'
}, {
    name: "Create alarm if temperature was to low for 15 minutes",
    value: 'create schema NotZeroMeasurementCreated (\n  measurement Measurement\n);\ncreate schema ZeroMeasurementCreated (\n  measurement Measurement\n);\ncreate schema CheckTimeDifference (\n  firstMeasurement Measurement,\n  lastMeasurement Measurement\n);\ninsert into CreateAlarm\n  select\n    check.lastMeasurement.source as source,\n    check.lastMeasurement.time as time,\n    "c8y_LowTemperatureAlarm" as type,\n    CumulocitySeverities.WARNING as severity,\n    CumulocityAlarmStatuses.ACTIVE as status,\n    "Temperature was too low for more than 15 minutes" as text\n  from CheckTimeDifference check\n  where check.lastMeasurement.time.after(check.firstMeasurement.time, 15min);\ninsert into CheckTimeDifference\n  select\n    firstM.measurement as firstMeasurement,\n    lastM.measurement as lastMeasurement\n  from pattern [\n    every (firstM = NotZeroMeasurementCreated ->\n    ZeroMeasurementCreated(measurement.source.value =firstM.measurement.source.value)) ->\n    ZeroMeasurementCreated until lastM = NotZeroMeasurementCreated(measurement.source.value = firstM.measurement.source.value)\n  ];\ninsert into NotZeroMeasurementCreated\n  select\n    m.measurement as measurement\n  from\n    MeasurementCreated m\n  where getNumber(m, "c8y_TemperatureMeasurement.T.value") > 0\n  AND m.measurement.type = "c8y_TemperatureMeasurement";\ninsert into ZeroMeasurementCreated\n  select\n    m.measurement as measurement\n  from\n    MeasurementCreated m\n  where getNumber(m, "c8y_TemperatureMeasurement.T.value") <= 0\n  AND m.measurement.type = "c8y_TemperatureMeasurement";'
}, {
    name: "Send simulator temperature to Zapier",
    value: '@Name("simulatortemperature")\nselect\n  e.measurement.source.value as id,\n  findManagedObjectById(e.measurement.source.value).getName() as name,\n  e.measurement.time.format() as time,\n  getNumber(e, "c8y_TemperatureMeasurement.T.value") as value,\nfrom MeasurementCreated e\n  where e.measurement.type = "TemperatureMeasurement"\n'
}, {
    name: "Send sales to Zapier",
    value: '@Name("sales")\nselect\n  getString(e, "com_nsn_startups_vendme_fragments_SalesReportInfo.vendingMachine_name") as id,\n  getString(e, "com_nsn_startups_vendme_fragments_SalesReportInfo.product_name") as name,\n  e.event.time.format() as time,\n  getNumber(e, "com_nsn_startups_vendme_fragments_SalesReportInfo.totalPaid") as value,\n  getString(e, "com_nsn_startups_vendme_fragments_SalesReportInfo.payment_type") as text\nfrom EventCreated e\n  where e.event.type = "com_nsn_startups_vendme_LiveSalesReport"\n'
} ]), function() {
    function c8yCounter($q, c8yBase, c8yRealtime) {
        function PropertyMap(propertyMap) {
            function createDefault(prop) {
                that.properties = [ prop ], that.filterFn = function(propVal, obj) {
                    return _.isEqual(propVal, obj[prop]);
                }, that.dependencies = [ prop ];
            }
            function parse(propertyMap) {
                var len = propertyMap.length, lastElem = _.last(propertyMap);
                return _.isArray(lastElem) ? (that.dependencies = lastElem, that.filterFn = propertyMap[len - 2], 
                that.properties = propertyMap.slice(0, length - 2), _.isFunction(that.filterFn) && _.every(that.properties, String)) : _.isFunction(lastElem) ? (that.dependencies = _.initial(propertyMap), 
                that.filterFn = lastElem, that.properties = that.dependencies, _.every(that.properties, String)) : !1;
            }
            propertyMap = _.cloneDeep(propertyMap);
            var that = this;
            if (this.properties = null, this.filterFn = null, this.dependencies = null, _.isArray(propertyMap)) {
                if (!parse(propertyMap)) throw new Error("property map is not valid");
            } else {
                if (!_.isString(propertyMap)) throw new Error("parameter is invalid");
                createDefault(propertyMap);
            }
        }
        function FilterConfiguration(filter, config) {
            function clearUndefinedProperties() {
                filter = _.pick(filter, function(val) {
                    return void 0 !== val;
                });
            }
            function fillEmptyMappings() {
                _.forEach(_.keys(filter), function(filterName) {
                    var hasMapping = _.any(that.propertyMapList, function(propertyMap) {
                        return _.any(propertyMap.properties, function(prop) {
                            return prop === filterName;
                        });
                    });
                    hasMapping || that.propertyMapList.push(new PropertyMap(filterName));
                });
            }
            function createPickList() {
                var pickListObj = _.reduce(that.propertyMapList, function(result, propertyMap) {
                    return _.forEach(propertyMap.dependencies, function(prop) {
                        result[prop] = !0;
                    }), result;
                }, {});
                pickListObj.id = !0, that.pickList = _.keys(pickListObj);
            }
            var that = this;
            this.pickList = null, this.queryParams = filter, this.propertyMapList = config && _.map(config, function(propertyMap) {
                return new PropertyMap(propertyMap);
            }) || [], clearUndefinedProperties(), fillEmptyMappings(), createPickList();
        }
        function Counter(listFn, realtimeChannel) {
            function subscribe() {
                if (realtimeChannel) {
                    var realtimeActions = c8yRealtime.realtimeActions();
                    return _.forEach(realtimeActions, function(action) {
                        c8yRealtime.addListener(that.__realtimeId, realtimeChannel, action, onNotification);
                    }), $q.when(c8yRealtime.start(that.__realtimeId, realtimeChannel));
                }
            }
            function unsubscribe() {
                realtimeChannel && c8yRealtime.removeSubscriber(that.__realtimeId, realtimeChannel);
            }
            function onNotification(evt, obj) {
                if (!isRefreshing) {
                    var oldCount = that.count;
                    REALTIME_FN_MAP[evt.name](obj), updateCount();
                    var newCount = that.count;
                    notificationCallback && newCount !== oldCount && notificationCallback(newCount, oldCount);
                }
            }
            function onCreate(obj) {
                hasFilter ? filterMatches(obj) && objects.unshift(map(obj)) : count += 1;
            }
            function onUpdate(obj) {
                if (hasFilter) {
                    var idx = _.findIndex(objects, {
                        id: obj.id
                    });
                    -1 === idx && filterMatches(obj) ? objects.unshift(map(obj)) : -1 === idx || filterMatches(obj) || objects.splice(idx, 1);
                }
            }
            function onDelete(obj) {
                if (hasFilter) {
                    var idx = _.findIndex(objects, {
                        id: obj.id
                    });
                    -1 !== idx && objects.splice(idx, 1);
                } else count -= 1;
            }
            function updateCount() {
                that.count = objects && objects.length || count || 0;
            }
            function map(obj) {
                return _.pick(obj, filterConfig.pickList);
            }
            function filterMatches(obj) {
                return filterConfig.matches(obj);
            }
            if (!_.isFunction(listFn)) throw new Error("list function must be provided");
            var objects, count, notificationCallback, filterConfig, that = this, isRefreshing = !1, hasFilter = !1, filter = {
                pageSize: 1
            }, isStarted = !1, isStopped = !1, REALTIME_FN_MAP = {
                CREATE: onCreate,
                UPDATE: onUpdate,
                DELETE: onDelete
            };
            c8yBase.createLocalId(this, "__realtimeId"), this.start = function() {
                if (isStarted) throw new Error("Cannot restart a counter instance, please create a new instance");
                return isStarted = !0, this.refresh().then(subscribe);
            }, this.stop = function() {
                if (!isStarted) throw new Error("Cannot stop counter instance without starting it first");
                if (isStopped) throw new Error("Cannot stop an already stopped counter instance");
                isStopped = !0, unsubscribe();
            }, this.onNotification = function(callback) {
                notificationCallback = callback;
            }, this.refresh = function() {
                isRefreshing = !0;
                var queryParams = hasFilter ? filterConfig.queryParams : filter;
                return $q.when(listFn(queryParams)).then(function(objs) {
                    hasFilter ? objects = _.chain(objs).filter(filterMatches).map(map).value() : count = objs.statistics.totalPages, 
                    updateCount(), isRefreshing = !1;
                });
            }, this.filter = function(_filter, _filterConfig) {
                if (!_filter && !_filterConfig) return filter;
                if (hasFilter) throw new Error("filter can be set only once");
                hasFilter = !0, filterConfig = new FilterConfiguration(_filter, _filterConfig);
            };
        }
        PropertyMap.prototype.matches = function(filter, obj) {
            filter = _.cloneDeep(filter), _.forEach(this.properties, function(prop) {
                filter[prop] = filter[prop] || void 0;
            });
            var args = _.values(_.pick(filter, this.properties));
            return args.push(obj), this.filterFn.apply(this, args);
        }, FilterConfiguration.prototype.matches = function(obj) {
            var that = this;
            return _.every(this.propertyMapList, function(propertyMap) {
                return propertyMap.matches(that.queryParams, obj);
            });
        };
        var datePropertyMap = [ "dateFrom", "dateTo", function(dateFrom, dateTo, obj) {
            var date = obj && (obj.date || obj.time);
            return date ? dateFrom && moment(dateFrom).isAfter(date) ? !1 : dateTo && moment(dateTo).isBefore(date) ? !1 : !0 : !1;
        }, [ "date", "time" ] ], sourcePropertyMap = [ "source", function(source, obj) {
            return (obj && obj.source && obj.source.id) === source;
        }, [ "source" ] ], defaultPropertyMaps = {
            date: datePropertyMap,
            source: sourcePropertyMap
        };
        return {
            Counter: Counter,
            defaultPropertyMaps: defaultPropertyMaps
        };
    }
    angular.module("c8y.core").factory("c8yCounter", [ "$q", "c8yBase", "c8yRealtime", c8yCounter ]);
}(), angular.module("c8y.core").factory("c8yDeviceControl", [ "$http", "$rootScope", "$q", "c8yBase", "c8yRealtime", function($http, $rootScope, $q, c8yBase, c8yRealtime) {
    function buildDetailUrl(operation) {
        var id = operation.id || operation;
        return c8yBase.url(path + "/" + id);
    }
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeNoTotalFilter(filters), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("operations", list, _filters);
        return $http.get(url, cfg).then(onList);
    }
    function listPaged(filters) {
        var defer = $q.defer(), _filters = angular.extend(filters || {}, {
            pageSize: 1e3
        }), cancelled = !1, onList = function(list) {
            var isNext = angular.isDefined(list.paging.next) && !(list.length < _filters.pageSize);
            return defer.notify(list), isNext || defer.resolve(!0), cancelled ? !0 : isNext ? list.paging.next().then(onList) : !0;
        };
        return angular.extend(defer.promise, {
            cancel: function() {
                cancelled = !0, defer.reject("canceled");
            }
        }), list(_filters).then(onList), defer.promise;
    }
    function detail(operation) {
        var url = buildDetailUrl(operation);
        return $http.get(url);
    }
    function create(operation) {
        var url = c8yBase.url(path), data = clean(operation, cleanKeys), cfg = angular.copy(defaultConfig);
        if (!data.deviceId) throw new Error("c8yDeviceControl: data must have a deviceId property");
        return $http.post(url, data, cfg).then(getIdFromRes)["finally"](function(id) {
            return evtBus.$emit("create"), id;
        });
    }
    function getIdFromRes(res) {
        var regexp = new RegExp(opIdLocationRegExp), matches = res.headers("Location").match(regexp);
        return parseInt(matches[1], 10);
    }
    function createWithNotifications(operation) {
        var created = create(operation), completed = created.then(function(operationId) {
            operation.id = operationId;
            var deferred = $q.defer(), subscriptionId = "operation" + operation.id, subscriptionChannel = "/operations/" + operation.deviceId;
            return c8yRealtime.addListener(subscriptionId, subscriptionChannel, "UPDATE", function(evt, data) {
                data.id == operation.id && (data.status === status.SUCCESSFUL || data.status === status.FAILED ? (c8yRealtime.stop(subscriptionId, subscriptionChannel), 
                deferred.resolve(data)) : deferred.notify(data));
            }), c8yRealtime.start(subscriptionId, subscriptionChannel), deferred.promise;
        });
        return $q.when({
            created: created,
            completed: completed
        });
    }
    function update(operation) {
        var url = c8yBase.url(path) + "/" + operation.id, data = clean(operation, cleanKeys.concat(cleanKeysUpdate)), cfg = angular.copy(defaultConfig);
        return $http.put(url, data, cfg)["finally"](function() {
            evtBus.$emit("update");
        });
    }
    function cancel(operation) {
        return operation.status = status.FAILED, operation.failureReason = "Operation cancelled by user.", 
        update(operation);
    }
    function save(operation) {
        return operation.id ? update(operation) : create(operation);
    }
    function getStyle(operationOrStatus) {
        var _status = angular.isString(operationOrStatus) ? operationOrStatus : operationOrStatus.status;
        return style[_status.toUpperCase()];
    }
    function isReservedKey(key) {
        return -1 !== reservedKeys.indexOf(key);
    }
    function isNotReservedKey(key) {
        return !isReservedKey(key);
    }
    function getKeys(operation) {
        var _operation = angular.copy(operation), props = Object.keys(_operation);
        return props.filter(isNotReservedKey);
    }
    var clean = c8yBase.cleanFields, path = "devicecontrol/operations", opIdLocationRegExp = "\\/devicecontrol\\/operations\\/(\\d+)", defaultConfig = {
        headers: c8yBase.contentHeaders("operation")
    }, status = {
        PENDING: "PENDING",
        SUCCESSFUL: "SUCCESSFUL",
        EXECUTING: "EXECUTING",
        FAILED: "FAILED"
    }, statusList = Object.keys(status), cleanKeys = [ "creationTime", "deviceExternalIDs", "id", "self" ], cleanKeysUpdate = [ "deviceId" ], reservedKeys = cleanKeys.concat([ "deviceId" ]), style = {}, evtBus = $rootScope.$new(!0);
    return style[status.PENDING] = {
        icon: "clock-o",
        cls: "text-muted"
    }, style[status.EXECUTING] = {
        icon: "refresh",
        cls: "text-info"
    }, style[status.SUCCESSFUL] = {
        icon: "check-circle",
        cls: "text-success"
    }, style[status.FAILED] = {
        icon: "times-circle",
        cls: "text-danger"
    }, {
        list: list,
        listPaged: listPaged,
        detail: detail,
        create: create,
        createWithNotifications: createWithNotifications,
        update: update,
        cancel: cancel,
        save: save,
        status: status,
        statusList: statusList,
        getStyle: getStyle,
        getKeys: getKeys,
        events: evtBus
    };
} ]), angular.module("c8y.core").factory("c8yEvents", [ "$http", "c8yBase", "c8yCounter", function($http, c8yBase, c8yCounter) {
    function buildDetailUrl(evt) {
        var id = evt.id || evt;
        return c8yBase.url(path + "/" + id);
    }
    function list(filters) {
        var url = c8yBase.url(path), cfg = {
            params: c8yBase.timeOrderFilter(c8yBase.pageSizeNoTotalFilter(filters))
        }, onList = c8yBase.cleanListCallback("events", list, cfg.params);
        return $http.get(url, cfg).then(onList);
    }
    function detail(evt) {
        var url = buildDetailUrl(evt);
        return $http.get(url);
    }
    function create(evt) {
        var url = c8yBase.url(path), data = clean(evt, reservedKeys), cfg = angular.copy(defaultConfig);
        return $http.post(url, data, cfg);
    }
    function update(evt) {
        var url = buildDetailUrl(evt), data = clean(evt, reservedKeys), cfg = angular.copy(defaultConfig);
        return $http.put(url, data, cfg);
    }
    function save(evt) {
        return evt.id ? update(evt) : create(evt);
    }
    function isReservedKey(key) {
        return -1 !== reservedKeys.indexOf(key);
    }
    function isNotReservedKey(key) {
        return !isReservedKey(key);
    }
    function getKeys(evt) {
        var _evt = angular.copy(evt), props = Object.keys(_evt);
        return props.filter(isNotReservedKey);
    }
    function createCounter(filter) {
        var counter = new c8yCounter.Counter(list, "/events/*"), filterConfig = [ c8yCounter.defaultPropertyMaps.date, c8yCounter.defaultPropertyMaps.source ];
        if (filter.type) {
            var type = filter.type;
            filterConfig.push([ function(obj) {
                return type === obj.type;
            } ]);
        }
        return delete filter.type, counter.filter(filter, filterConfig), counter;
    }
    var clean = c8yBase.cleanFields, path = "event/events", defaultConfig = {
        headers: c8yBase.contentHeaders("event")
    }, reservedKeys = [ "creationTime", "id", "self", "source", "text", "time" ];
    return {
        list: list,
        detail: detail,
        create: create,
        update: update,
        save: save,
        reservedKeys: reservedKeys,
        getKeys: getKeys,
        createCounter: createCounter
    };
} ]), angular.module("c8y.core").factory("c8yDeviceGroup", [ "c8yManagedObject", function(c8yManagedObject) {
    function hasDevices(group) {
        return !!group.childAssets.references.length;
    }
    var exports = {}, deviceGroupType = "c8y_DeviceGroup";
    return exports.list = function(filter) {
        var _filter = {
            type: deviceGroupType,
            pageSize: 1e4
        };
        return angular.isObject(filter) && (_filter = angular.extend(_filter, filter)), 
        c8yManagedObject.list(_filter);
    }, exports.detail = function(id) {
        return c8yManagedObject.detail(id);
    }, exports.create = function(data) {
        return data.type = deviceGroupType, c8yManagedObject.create(data);
    }, exports.remove = function(data) {
        return hasDevices(data) ? !1 : c8yManagedObject.remove(data);
    }, exports.addDevice = function(group, device) {
        return device.c8y_Groups = angular.isArray(device.c8y_Groups) ? device.c8y_Groups : [], 
        device.c8y_Groups.push({
            name: group.name,
            id: group.id
        }), c8yManagedObject.update(device.id, {
            c8y_Groups: device.c8y_Groups
        }), c8yManagedObject.addChildAsset(group, device);
    }, exports.removeDevice = function(group, device) {
        return device.c8y_Groups = device.c8y_Groups.filter(function(g) {
            return g.id !== group.id;
        }), c8yManagedObject.update(device.id, {
            c8y_Groups: device.c8y_Groups
        }), c8yManagedObject.removeChildAsset(group, device);
    }, exports;
} ]), angular.module("c8y.core").factory("c8yDeviceRegistration", [ "$http", "c8yBase", function($http, c8yBase) {
    function buildDetailUrl(device) {
        var id = device.id || device;
        return c8yBase.url(path + "/" + id);
    }
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("newDeviceRequests", list, _filters);
        return $http.get(url, cfg).then(onList);
    }
    function detail(devReg) {
        var url = buildDetailUrl(devReg);
        return $http.get(url);
    }
    function create(device) {
        var url = c8yBase.url(path), data = clean(device, cleanKeys), cfg = angular.copy(defaultConfig);
        if (!data.id) throw new Error("c8yDeviceRegistration: data must have an id property");
        return $http.post(url, data, cfg);
    }
    function accept(device) {
        var url = buildDetailUrl(device), data = {
            status: status.ACCEPTED
        }, cfg = angular.copy(defaultConfig);
        return $http.put(url, data, cfg);
    }
    function cancel(devReg) {
        var url = buildDetailUrl(devReg);
        return $http["delete"](url);
    }
    function getStyle(devReg) {
        var status = devReg.status || "UNKNOWN";
        return style[status.toUpperCase()];
    }
    function newDeviceRequestsStatusIcon(device) {
        return getStyle(device).icon;
    }
    function newDeviceRequestsStatusClass(device) {
        return getStyle(device).cls;
    }
    function isReservedKey(key) {
        return -1 !== reservedKeys.indexOf(key);
    }
    function isNotReservedKey(key) {
        return !isReservedKey(key);
    }
    function getKeys(devReg) {
        var _devReg = angular.copy(devReg), props = Object.keys(_devReg);
        return props.filter(isNotReservedKey);
    }
    var clean = c8yBase.cleanFields, path = "devicecontrol/newDeviceRequests", defaultConfig = {
        headers: c8yBase.contentHeaders("newDeviceRequest")
    }, status = {
        WAITING_FOR_CONNECTION: "WAITING_FOR_CONNECTION",
        PENDING_ACCEPTANCE: "PENDING_ACCEPTANCE",
        ACCEPTED: "ACCEPTED"
    }, statusList = Object.keys(status), cleanKeys = [], reservedKeys = [], style = {};
    return style[status.WAITING_FOR_CONNECTION] = {
        icon: "unlink",
        cls: "text-danger"
    }, style[status.PENDING_ACCEPTANCE] = {
        icon: "circle",
        cls: "text-info"
    }, style[status.ACCEPTED] = {
        icon: "check-circle",
        cls: "text-success"
    }, {
        list: list,
        detail: detail,
        create: create,
        accept: accept,
        cancel: cancel,
        status: status,
        statusList: statusList,
        getStyle: getStyle,
        getKeys: getKeys,
        statusIcon: newDeviceRequestsStatusIcon,
        statusClass: newDeviceRequestsStatusClass
    };
} ]), angular.module("c8y.core").factory("c8yDevices", [ "$cacheFactory", "$filter", "c8yInventory", "c8yUser", function($cacheFactory, $filter, c8yInventory, c8yUser) {
    function buildFilter(filter) {
        return angular.extend({
            skipChildrenNames: !0,
            fragmentType: deviceFragmentType
        }, filter || {});
    }
    function filterDevices(managedObjects) {
        var filtered = managedObjects.filter(function(mo) {
            return mo[deviceFragmentType];
        });
        return filtered.statistics = managedObjects.statistics, filtered.paging = managedObjects.paging, 
        filtered;
    }
    function list(filter) {
        var _filter = buildFilter(filter), http = c8yInventory.list(_filter);
        return _filter.text && (http = http.then(filterDevices)), http;
    }
    function create(device) {
        var mo = angular.copy(device);
        mo[deviceFragmentType] = !0, c8yInventory.create(mo);
    }
    function save(device) {
        return device.id ? update(device) : create(device);
    }
    function supportsOperation(device, operation) {
        var ops = device && device.c8y_SupportedOperations, supports = angular.isArray(ops) && ops.indexOf(operation) > -1;
        return !!supports;
    }
    function getSupportedOperations(device) {
        var ops = [];
        return angular.isArray(device.c8y_SupportedOperations) && (ops = device.c8y_SupportedOperations), 
        ops;
    }
    function isVendme(device) {
        return "com_nsn_startups_vendme_VendingMachine" === device.type;
    }
    function parseAvailability(device) {
        var requiredAvailability = device && device.c8y_RequiredAvailability, availability = device && device.c8y_Availability, status = availability && availability.status || (requiredAvailability ? "UNKNOWN" : "NOT_MONITORED");
        return status;
    }
    function statusIcon(device) {
        return availabilityIconMap[parseAvailability(device)].icon;
    }
    function statusClass(device) {
        return availabilityIconMap[parseAvailability(device)].cls;
    }
    function lastValidMessageColor(device) {
        return lastValidMessageIconMap[isLastValidMessage(device)].color;
    }
    function lastValidMessageIcon(device) {
        return lastValidMessageIconMap[isLastValidMessage(device)].icon;
    }
    function lastValidMessageTooltip(device) {
        return lastValidMessageIconMap[isLastValidMessage(device)].tooltipText;
    }
    function isLastValidMessage(device) {
        if (device.c8y_Availability && device.c8y_Availability.lastMessage && device.c8y_RequiredAvailability && device.c8y_RequiredAvailability.responseInterval) {
            var msInMunute = 6e4, now = moment().valueOf(), lastMessage = moment(device.c8y_Availability.lastMessage).valueOf(), responseInterval = device.c8y_RequiredAvailability.responseInterval * msInMunute;
            return now - lastMessage - responseInterval > 0;
        }
        return null;
    }
    function update(mo) {
        return removeCache(mo), c8yInventory.update(mo);
    }
    function removeCache(mo) {
        var id = mo && mo.id || mo;
        _detailCached.cache && delete _detailCached.cache[id];
    }
    function detail(mo, params) {
        var _params = angular.extend(params || {}, {
            withParents: !0
        });
        return c8yInventory.detail(mo, _params);
    }
    function getCount(filter) {
        var _filter = buildFilter(filter);
        return c8yInventory.getCount(_filter);
    }
    function isDevice(mo) {
        return angular.isDefined(mo[deviceFragmentType]);
    }
    function model(mo) {
        var prop = isVendme(mo) ? "com_nsn_startups_vendme_fragments_VendingMachineTypeInfo" : "c8y_Hardware", hardware = mo && mo[prop];
        return hardware && hardware.model;
    }
    function serial(mo) {
        var prop = isVendme(mo) ? "com_nsn_startups_vendme_fragments_VendingMachineTypeInfo" : "c8y_Hardware", prop2 = isVendme(mo) ? "serial" : "serialNumber", hardware = mo && mo[prop];
        return hardware && hardware[prop2];
    }
    function availabilityTooltip(mo) {
        var availability = mo.c8y_Availability, lastMessage = availability && $filter("relativeDateShort")(availability.lastMessage);
        return lastMessage ? "Last Message: " + lastMessage : "Connection not monitored";
    }
    function removeWithUser(device) {
        return detail(device).then(function(res) {
            var device = res.data, owner = device.owner, canBeDevice = device.c8y_IsDevice && owner && owner.match(/^device_/);
            return canBeDevice = !1, canBeDevice ? c8yUser.detail(owner).then(function(res) {
                var user = res.data, groups = c8yUser.groups(user), isDevice = _.find(groups, {
                    name: "devices"
                });
                return isDevice ? c8yUser.remove(user) : c8yUser;
            }) : device;
        }).then(function() {
            c8yInventory.remove(device);
        });
    }
    function properName(device) {
        return device ? device.name ? device.name : device.id ? "" + device.id : "<Device has no name>" : void 0;
    }
    function switchResponseInterval(device) {
        var mo = {
            id: device.id,
            c8y_RequiredAvailability: {}
        };
        return 0 != device.c8y_RequiredAvailability.responseInterval && (mo.c8y_RequiredAvailability.responseInterval = -device.c8y_RequiredAvailability.responseInterval), 
        c8yInventory.update(mo);
    }
    var deviceFragmentType = "c8y_IsDevice", availabilityIconMap = {
        CONNECTED: {
            icon: "exchange",
            cls: "statusOk"
        },
        AVAILABLE: {
            icon: "check-circle",
            cls: "statusOk"
        },
        MAINTENANCE: {
            icon: "wrench",
            cls: "statusAlert"
        },
        UNAVAILABLE: {
            icon: "exclamation-circle",
            cls: "statusNok"
        },
        UNKNOWN: {
            icon: "circle",
            cls: "statusUnknown"
        },
        NOT_MONITORED: {
            icon: "circle",
            cls: "statusUnknown"
        }
    }, lastValidMessageIconMap = {
        "true": {
            icon: "check-circle",
            color: "green",
            tooltipText: "Valid"
        },
        "false": {
            icon: "exclamation-circle",
            color: "red",
            tooltipText: "Invalid"
        },
        "null": {
            icon: "circle",
            color: "#f3f3f3",
            tooltipText: "Unknown"
        }
    }, _detailCached = _.memoize(detail, function(moOrId) {
        return moOrId && (moOrId.id || moOrId);
    });
    return angular.extend(angular.copy(c8yInventory), {
        list: list,
        save: save,
        update: update,
        detail: detail,
        detailCached: _detailCached,
        create: create,
        removeWithUser: removeWithUser,
        supportsOperation: supportsOperation,
        getSupportedOperations: getSupportedOperations,
        isVendme: isVendme,
        statusIcon: statusIcon,
        statusClass: statusClass,
        parseAvailability: parseAvailability,
        getCount: getCount,
        isDevice: isDevice,
        model: model,
        serial: serial,
        availabilityTooltip: availabilityTooltip,
        properName: properName,
        switchResponseInterval: switchResponseInterval,
        isLastValidMessage: isLastValidMessage,
        lastValidMessageColor: lastValidMessageColor,
        lastValidMessageTooltip: lastValidMessageTooltip,
        lastValidMessageIcon: lastValidMessageIcon
    });
} ]), angular.module("c8y.core").factory("c8yGeo", [ "$http", function($http) {
    function geoCode(address) {
        return $http.jsonp(geoCodeSearchUrl, {
            params: {
                format: "json",
                q: address
            }
        });
    }
    function Bounds() {
        return this.points = [], this;
    }
    var geoCodeSearchUrl = "//open.mapquestapi.com/nominatim/v1/search.php?json_callback=JSON_CALLBACK";
    return Bounds.prototype.add = function(p) {
        this.points.push(p);
    }, Bounds.prototype.reset = function() {
        this.points.length = 0;
    }, Bounds.prototype.get = function() {
        var bounds = {
            southWest: {},
            northEast: {}
        };
        return this.points.length || (bounds = null), this.points.forEach(function(p) {
            p.lat < (bounds.southWest.lat || 1 / 0) && (bounds.southWest.lat = p.lat), p.lng < (bounds.southWest.lng || 1 / 0) && (bounds.southWest.lng = p.lng), 
            p.lat > (bounds.northEast.lat || -(1 / 0)) && (bounds.northEast.lat = p.lat), p.lng > (bounds.northEast.lng || -(1 / 0)) && (bounds.northEast.lng = p.lng);
        }), bounds;
    }, {
        geoCode: geoCode,
        Bounds: Bounds
    };
} ]), angular.module("c8y.core").factory("c8yGroupTypesConfig", [ "c8yInventory", "$q", function(c8yInventory, $q) {
    function save(config) {
        return config.type = type, c8yInventory.save(config);
    }
    function get() {
        return c8yInventory.list(filtersGet).then(getFirstOrDefault);
    }
    function getFirstOrDefault(configs) {
        return configs.length > 0 ? configs[0] : getDefault();
    }
    function getDefault() {
        return {
            type: type,
            groups: getDefaultGroupTypes()
        };
    }
    function getDefaultGroupTypes() {
        return [ getDeviceGroupType() ];
    }
    function getLookup(config) {
        var configPromise = config ? $q.when(config) : get();
        return configPromise.then(_.partial(getGroupTypesConfigLookup, {}));
    }
    function getGroupTypesConfigLookup(lookup, config) {
        return lookup = lookup || {}, _.forEach(config.groups || {}, function(groupConfig) {
            lookup[groupConfig.type] = groupConfig, lookup = getGroupTypesConfigLookup(lookup, groupConfig);
        }), lookup;
    }
    function getDeviceGroupType() {
        return {
            type: "c8y_DeviceGroup",
            name: "Default Group",
            namePlural: "Default Groups",
            showInNavigator: !0,
            groups: []
        };
    }
    function getDeviceSubgroupType() {
        return {
            type: "c8y_DeviceSubgroup",
            name: "Default Subgroup",
            namePlural: "Default Subgroups",
            showInNavigator: !1,
            groups: []
        };
    }
    function getEmptyGroupType() {
        return {
            name: "",
            namePlural: "",
            type: "",
            showInNavigator: !1,
            groups: []
        };
    }
    var type = "c8y_GroupTypesConfig", filtersGet = {
        type: type,
        pageSize: 1
    };
    return {
        save: save,
        get: get,
        getLookup: getLookup,
        getDeviceGroupType: getDeviceGroupType,
        getDeviceSubgroupType: getDeviceSubgroupType,
        getEmptyGroupType: getEmptyGroupType
    };
} ]), angular.module("c8y.core").factory("c8yGroups", [ "$q", "c8yBase", "c8yInventory", "c8yGroupTypesConfig", function($q, c8yBase, c8yInventory, c8yGroupTypesConfig) {
    function getGroupItems(group) {
        return c8yInventory.detail(group).then(c8yBase.getResData).then(getChildrenIds).then(function(childrenIds) {
            return childrenIds.length > 0 ? c8yInventory.list({
                ids: childrenIds.join(","),
                pageSize: childrenIds.length
            }) : $q.when([]);
        });
    }
    function getChildrenIds(group) {
        var childrenIds = [];
        return childrenIds = childrenIds.concat(group.childAssets.references.map(getIdFromManagedObjectReference)), 
        childrenIds = childrenIds.concat(group.childDevices.references.map(getIdFromManagedObjectReference)), 
        $q.when(childrenIds);
    }
    function getIdFromManagedObjectReference(ref) {
        return ref.managedObject.id;
    }
    function getGroupTypeItems(groupTypeName) {
        return c8yGroupTypesConfig.getLookup().then(function(lookup) {
            return [ lookup[groupTypeName] ];
        }).then(getGroupsByGroupTypes);
    }
    function getTopLevelGroups() {
        return getTopLevelGroupTypes().then(getGroupsByGroupTypes);
    }
    function getTopLevelGroupTypes() {
        return c8yGroupTypesConfig.get().then(function(config) {
            return config.groups;
        });
    }
    function getGroupsByGroupTypes(groupTypesList) {
        if (groupTypesList.length > 0) {
            var promises = [];
            return _.forEach(groupTypesList, function(groupType) {
                promises.push(c8yInventory.list({
                    type: groupType.type
                }));
            }), $q.all(promises).then(_.flatten);
        }
        return $q.when([]);
    }
    function isGroup(mo) {
        return !!mo.c8y_IsDeviceGroup || "c8y_DeviceGroup" === mo.type;
    }
    return {
        getGroupItems: getGroupItems,
        getGroupTypeItems: getGroupTypeItems,
        getTopLevelGroups: getTopLevelGroups,
        isGroup: isGroup
    };
} ]), angular.module("c8y.core").factory("c8yIdentity", [ "$http", "c8yBase", function($http, c8yBase) {
    function onExternalIds(res) {
        return res.data.externalIds;
    }
    function buildUrlMo(mo) {
        return c8yBase.url(path) + "/globalIds/" + (mo.id || mo) + "/externalIds";
    }
    function buildUrl(identity) {
        return c8yBase.url(path) + "/externalIds/" + identity.type + "/" + identity.externalId;
    }
    function createIdentity(mo, identity) {
        var url = buildUrlMo(mo), cfg = angular.copy(defaultConfig);
        return $http.post(url, identity, cfg);
    }
    function deleteIdentity(identity) {
        var url = buildUrl(identity);
        return $http["delete"](url);
    }
    function listExternalIds(mo) {
        var url = buildUrlMo(mo);
        return $http.get(url).then(onExternalIds);
    }
    function getExternalId(identity) {
        var url = buildUrl(identity);
        return $http.get(url);
    }
    var path = "identity", defaultConfig = {
        headers: c8yBase.contentHeaders("externalId")
    };
    return {
        createIdentity: createIdentity,
        deleteIdentity: deleteIdentity,
        listExternalIds: listExternalIds,
        getExternalId: getExternalId
    };
} ]), angular.module("c8y.core").factory("c8yInventory", [ "$http", "$q", "c8yBase", "c8yRealtime", function($http, $q, c8yBase, c8yRealtime) {
    function buildDetailUrl(mo) {
        var id = mo && (mo.id || mo);
        return id && c8yBase.url(path + "/" + id);
    }
    function buildChildrenUrl(mo, type) {
        return buildDetailUrl(mo) + "/" + type;
    }
    function buildChildUrl(mo, moChild, type) {
        var id = moChild.id || moChild;
        return buildChildrenUrl(mo, type) + "/" + id;
    }
    function cleanFilters(filters) {
        var _filters = filters || {}, allowedWithText = [ "text", "pageSize", "currentPage", "skipChildrenNames" ];
        return _filters.text && Object.keys(_filters).forEach(function(key) {
            -1 === allowedWithText.indexOf(key) && delete _filters[key];
        }), _filters;
    }
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeFilter(cleanFilters(filters)), cfg = {
            params: _filters
        }, blindPaging = !0, onList = c8yBase.cleanListCallback("managedObjects", list, _filters, blindPaging);
        return $http.get(url, cfg).then(onList);
    }
    function detail(mo, params) {
        var url = buildDetailUrl(mo), _params = params || {}, config = {
            params: _params
        };
        return url ? $http.get(url, config) : $q.reject("Managed object not valid");
    }
    function detailCached(id) {
        return detail(id);
    }
    function detailRealtime(mo, scope) {
        function updateListener(evt, data) {
            mergeMoRT(data);
        }
        function mergeMoRT(_mo) {
            moRT ? angular.extend(moRT, _mo) : moRT = _mo;
        }
        var moRT, moId = mo.id || mo, scopeId = scope.$id, channel = "/managedobjects/" + moId, op = c8yRealtime.realtimeActions().UPDATE;
        return c8yRealtime.addListener(scopeId, channel, op, updateListener), c8yRealtime.start(scopeId, channel), 
        scope.$on("stopRealtime", function() {
            c8yRealtime.stop(scopeId, channel);
        }), scope.$on("$destroy", function() {
            c8yRealtime.stop(scopeId, channel);
        }), detail(moId).then(function(res) {
            return mergeMoRT(res.data), moRT;
        });
    }
    function remove(mo) {
        var url = buildDetailUrl(mo);
        return $http["delete"](url);
    }
    function create(mo) {
        var url = c8yBase.url(path), cfg = angular.copy(defaultConfig), data = c8yBase.cleanFields(mo, fieldsToClean);
        return $http.post(url, data, cfg);
    }
    function createConfirm(mo) {
        return create(mo).then(getIdFromRes).then(detail);
    }
    function getIdFromRes(res) {
        var regexp = new RegExp(moIdLocationRegExp), matches = res.headers("Location").match(regexp);
        return matches[1];
    }
    function update(mo) {
        var url = buildDetailUrl(mo), cfg = angular.copy(defaultConfig), data = c8yBase.cleanFields(mo, fieldsToClean);
        return removeCache(mo), $http.put(url, data, cfg);
    }
    function save(mo) {
        return mo.id ? update(mo) : create(mo);
    }
    function children(mo, type, config) {
        var url = buildChildrenUrl(mo, type), cfg = config || {};
        return detailCached(mo).then(function(res) {
            return res.data[type].references.length;
        }).then(function(childrenCount) {
            return cfg.params = {
                pageSize: childrenCount
            }, $http.get(url, cfg);
        });
    }
    function onChildren(res) {
        var data = res.data;
        return data.references.map(function(ref) {
            return ref.managedObject;
        });
    }
    function childDevices(mo, config) {
        return children(mo, "childDevices", config).then(onChildren);
    }
    function childAssets(mo, config) {
        return children(mo, "childAssets", config).then(onChildren);
    }
    function addChild(mo, moChild, type) {
        var url = buildChildrenUrl(mo, type), data = {
            managedObject: moChild
        }, cfg = angular.copy(defaultConfigReference);
        return $http.post(url, data, cfg);
    }
    function parents(mo, parentType, moType, moFragmentType) {
        return detail(mo, {
            withParents: !0
        }).then(function(res) {
            return res.data[parentType + "Parents"].references.map(function(item) {
                return item.managedObject.id;
            });
        }).then(function(parentIds) {
            var out = [];
            return parentIds.length && (out = list({
                ids: parentIds.join(",")
            }), (moType || moFragmentType) && (out = out.then(function(mos) {
                return mos.filter(function(mo) {
                    return moType && mo.type === moType || moFragmentType && angular.isDefined(mo[moFragmentType]);
                });
            }))), out;
        });
    }
    function parentsDevice(mo, moType, moFragmentType) {
        return parents(mo, "device", moType, moFragmentType);
    }
    function parentsAsset(mo, moType, moFragmentType) {
        return parents(mo, "asset", moType, moFragmentType);
    }
    function directParentAssets(mo, moType, moFragmentType) {
        return directParents(mo, "asset", moType, moFragmentType);
    }
    function directParentDevices(mo, moType, moFragmentType) {
        return directParents(mo, "device", moType, moFragmentType);
    }
    function directParents(mo, parentType, moType, moFragmentType) {
        var childIdParamName = "child" + parentType.charAt(0).toUpperCase() + parentType.slice(1) + "Id", filters = {
            withParents: !0
        };
        return filters[childIdParamName] = mo.id, list(filters).then(function(parents) {
            return (moType || moFragmentType) && (parents = parents.filter(function(p) {
                return moType && p.type === moType || moFragmentType && angular.isDefined(p[moFragmentType]);
            })), parents;
        });
    }
    function addChildDevice(mo, moChild) {
        return addChild(mo, moChild, "childDevices");
    }
    function addChildAsset(mo, moChild) {
        return addChild(mo, moChild, "childAssets");
    }
    function removeChild(mo, moChild, type) {
        var url = buildChildUrl(mo, moChild, type);
        return $http["delete"](url);
    }
    function removeChildDevice(mo, moChild) {
        return removeChild(mo, moChild, "childDevices");
    }
    function removeChildAsset(mo, moChild) {
        return removeChild(mo, moChild, "childAssets");
    }
    function removeCache(mo) {
        var id = mo && mo.id || mo;
        delete _detailCached.cache[id];
    }
    function getCount(filter) {
        return c8yBase.getCount(list, filter || {});
    }
    function getSupportedMeasurements(mo) {
        var url = buildDetailUrl(mo) + "/supportedMeasurements";
        return $http.get(url).then(function(res) {
            return res.data.c8y_SupportedMeasurements;
        });
    }
    function supportsMeasurement(mo, measurementType) {
        var supports;
        getSupportedMeasurements(mo).then(function(measurements) {
            return supports = angular.isArray(measurements) && measurements.indexOf(measurementType) > -1, 
            !!supports;
        });
    }
    function getFragments(mo) {
        return Object.keys(c8yBase.cleanFields(mo, _.union(fieldsToClean, [ "id", "type", "name", "owner", "self" ])));
    }
    var path = "inventory/managedObjects", moIdLocationRegExp = "\\/inventory\\/managedObjects\\/(\\d+)", defaultConfig = {
        headers: c8yBase.contentHeaders("managedObject")
    }, defaultConfigReference = {
        headers: c8yBase.contentHeaders("managedObjectReference")
    }, fieldsToClean = [ "lastUpdated", "assetParents", "deviceParents", "childAssets", "childDevices", "c8y_ActiveAlarmsStatus", "c8y_Availability" ], _detailCached = _.memoize(detailCached, _.identity);
    return {
        list: list,
        detail: detail,
        detailCached: _detailCached,
        detailRealtime: detailRealtime,
        create: create,
        createConfirm: createConfirm,
        update: update,
        save: save,
        remove: remove,
        childAssets: childAssets,
        childDevices: childDevices,
        addChildAsset: addChildAsset,
        addChildDevice: addChildDevice,
        removeChildAsset: removeChildAsset,
        removeChildDevice: removeChildDevice,
        parentsAsset: parentsAsset,
        parentsDevice: parentsDevice,
        directParentAssets: directParentAssets,
        directParentDevices: directParentDevices,
        getCount: getCount,
        getSupportedMeasurements: getSupportedMeasurements,
        supportsMeasurement: supportsMeasurement,
        getFragments: getFragments
    };
} ]), angular.module("c8y.core").factory("c8yMeasurements", [ "$http", "$q", "c8yBase", "c8yCepModule", function($http, $q, c8yBase, c8yCepModule) {
    function buildDetailUrl(measurement) {
        var id = measurement.id || measurement;
        return c8yBase.url(path) + "/" + id;
    }
    function list(filters) {
        var page_size_custom = PAGE_SIZE, url = c8yBase.url(path), _filters = c8yBase.todayFilter(angular.extend({
            pageSize: page_size_custom
        }, filters || {})), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("measurements", list, _filters);
        return $http.get(url, cfg).then(onList);
    }
    function listSeries(filters) {
        var page_size_custom = PAGE_SIZE, url = c8yBase.url(path + "/series"), _filters = c8yBase.todayFilter(angular.extend({
            pageSize: page_size_custom
        }, filters || {})), cfg = {
            params: _filters
        }, onList = function(res) {
            return res.data;
        }, requestIndex = _.findIndex(listSeries._cacheFilter, _.partial(_.isEqual, _filters)), request = requestIndex >= 0 ? listSeries._cacheRequest[requestIndex] : null;
        return request || (request = $http.get(url, cfg).then(onList), listSeries._cacheFilter.push(angular.copy(_filters)), 
        listSeries._cacheRequest.push(request)), request;
    }
    function listPaged(filters) {
        var defer = $q.defer(), _filters = angular.extend(filters || {}, {
            pageSize: 1e3,
            withTotalPages: !0
        }), cancelled = !1, onList = function(list) {
            var isNext = angular.isDefined(list.paging.next) && !(list.length < _filters.pageSize);
            return defer.notify(list), isNext || defer.resolve(!0), cancelled ? !0 : isNext ? list.paging.next().then(onList) : !0;
        };
        return angular.extend(defer.promise, {
            cancel: function() {
                cancelled = !0, defer.reject("canceled");
            }
        }), list(_filters).then(onList), defer.promise;
    }
    function listSeriesPaged(filters) {
        var defer = $q.defer(), _filters = angular.extend(filters || {}, {
            pageSize: 1e3,
            withTotalPages: !0
        }), cancelled = !1, onList = function(list) {
            return defer.notify(list), list.paging.next || defer.resolve(!0), cancelled ? !0 : list.paging.next ? list.paging.next().then(onList) : !0;
        };
        return angular.extend(defer.promise, {
            cancel: function() {
                cancelled = !0, defer.reject("canceled");
            }
        }), listSeries(_filters).then(onList), defer.promise;
    }
    function detail(measurement) {
        var url = buildDetailUrl(measurement);
        return $http.get(url);
    }
    function create(measurement) {
        var url = c8yBase.url(path), data = clean(measurement), cfg = angular.copy(defaultConfig);
        if (!data.source) throw new Error("c8yMeasurement: source must be defined");
        return $http.post(url, data, cfg);
    }
    function update(measurement) {
        var url = buildDetailUrl(measurement), data = clean(measurement), cfg = angular.copy(defaultConfig);
        return $http.put(url, data, cfg);
    }
    function save(measurement) {
        return measurement.id ? update(measurement) : create(measurement);
    }
    function remove(measurement) {
        var url = buildDetailUrl(measurement);
        return $http["delete"](url);
    }
    function activateCep() {
        return c8yCepModule.createOrDeploy(cepModule);
    }
    var clean = c8yBase.clean, path = "measurement/measurements", defaultConfig = {
        headers: c8yBase.contentHeaders("measurement")
    }, cepModule = {
        status: "DEPLOYED",
        name: "c8yui_measurements",
        body: 'insert into SendNotification select measurement as payload, "c8yui/measurements" as channelName from MeasurementCreated;'
    }, PAGE_SIZE = 1440;
    return listSeries._cacheFilter = [], listSeries._cacheRequest = [], {
        list: list,
        listPaged: listPaged,
        listSeries: listSeries,
        listSeriesPaged: listSeriesPaged,
        detail: detail,
        create: create,
        update: update,
        save: save,
        remove: remove,
        activateCep: activateCep
    };
} ]), angular.module("c8y.core").factory("c8yNotifications", [ "$rootScope", "$q", "$timeout", "c8yBase", "info", function($rootScope, $q, $timeout, c8yBase, info) {
    function newAbortConnectionTimer() {
        return $timeout(function() {
            cometd.getTransport().abort();
        }, timeout);
    }
    function onSubscribe(msg) {
        var subscription = getSubscriptionByMsg(msg);
        subscription.scope.$emit("connected"), subscription.scope.connected = !0, scopeApply();
    }
    function onMessage(scope, msg) {
        abortConnection && ($timeout.cancel(), abortConnection = newAbortConnectionTimer()), 
        scope.$emit("message", msg), scopeApply();
    }
    function onUnsubscribe(sub) {
        sub.counter--, sub.counter || (cometd.unsubscribe(sub.comet), delete subscriptionMap[sub.channel], 
        Object.keys(subscriptionMap).length || disconnect());
    }
    function disconnect() {
        abortConnection && ($timeout.cancel(abortConnection), abortConnection = void 0), 
        cometd.removeListener(onSubscribeListener), cometd.disconnect();
    }
    function scopeApply() {
        $rootScope.$$phase || $rootScope.$apply();
    }
    function connect() {
        var defer = $q.defer();
        if (cometd.isDisconnected()) {
            cometd.handshake();
            var connectListener = cometd.addListener("/meta/connect", function() {
                defer.resolve(!0), cometd.removeListener(connectListener);
            });
            onSubscribeListener = cometd.addListener("/meta/subscribe", onSubscribe);
        } else defer.resolve(!0);
        return defer.promise;
    }
    function getSubscriptionByMsg(msg) {
        var subscriptions = Object.keys(subscriptionMap).filter(function(sub) {
            return msg.subscription.match(sub);
        });
        return subscriptionMap[subscriptions[0]];
    }
    function getSubscription(channel) {
        return subscriptionMap[channel];
    }
    function subscribe(channel) {
        var sub = getSubscription(channel) || {}, created = !1;
        return sub.channel || (created = !0, subscriptionMap[channel] = sub, sub.channel = channel, 
        sub.scope = $rootScope.$new(!0), sub.scope.unsubscribe = angular.bind({}, onUnsubscribe, sub), 
        sub.counter = 0), sub.counter++, connect().then(function() {
            return created && (sub.comet = cometd.subscribe(channel, angular.bind({}, onMessage, sub.scope)), 
            abortConnection = newAbortConnectionTimer()), sub.scope;
        });
    }
    function configure(type) {
        var _cfg = angular.copy("debug" === type ? debugNotificationsCfg : cfg);
        cometd.configure(_cfg);
    }
    var abortConnection, onSubscribeListener, cometd = $.cometd, subscriptionMap = {}, path = "cep/customnotifications", pathNotifications = "cep/notifications", url = c8yBase.url(path), cfg = {
        url: url,
        logLevel: "info",
        requestHeaders: {
            Authorization: "Basic " + info.token,
            UseXBasic: !0
        },
        appendMessageTypeToURL: !1
    }, timeout = 57e4, debugNotificationsCfg = angular.copy(cfg);
    return debugNotificationsCfg.url = c8yBase.url(pathNotifications), cometd.unregisterTransport("websocket"), 
    cometd.registerExtension("acceptEmptyMessages", {
        incoming: function(message) {
            void 0 === message.successful && void 0 === message.data && (message.data = {
                message: "The output from statement was empty"
            });
        }
    }), cometd.configure(angular.copy(cfg)), {
        subscribe: subscribe,
        configure: configure
    };
} ]), angular.module("c8y.core").factory("c8ySettings", [ "$http", "c8yBase", function($http, c8yBase) {
    function buildDetailUrl(option) {
        return c8yBase.url(path + "/" + option.category + (option.key ? "/" + option.key : ""));
    }
    function buildDetailUrlForReadOnly(option) {
        return c8yBase.url(pathReadOnly + "/" + option.category + (option.key ? "/" + option.key : ""));
    }
    function buildDetailUrlForSystem(option) {
        return c8yBase.url(pathSystem + "/" + option.category + (option.key ? "/" + option.key : ""));
    }
    function list(filters) {
        var url = c8yBase.url(path), _filters = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filters
        }, onList = c8yBase.cleanListCallback("options", list, _filters), promise = $http.get(url, cfg).then(onList);
        return filters && filters.category && (promise = promise.then(function(options) {
            var filtered = options.filter(function(opt) {
                return opt.category === filters.category;
            });
            return filtered.paging = options.paging, filtered;
        })), promise;
    }
    function updateOption(option) {
        var url = buildDetailUrl(option), data = angular.copy(option), cfg = angular.copy(config);
        return $http.put(url, data, cfg);
    }
    function createOption(option) {
        var url = c8yBase.url(path), data = angular.copy(option), cfg = angular.copy(config);
        return $http.post(url, data, cfg);
    }
    function deleteOption(option) {
        var url = buildDetailUrl(option);
        return $http["delete"](url);
    }
    function detail(option) {
        var url = "password" === option.category ? buildDetailUrlForReadOnly(option) : buildDetailUrl(option);
        return $http.get(url);
    }
    function getSystemOption(option) {
        var url = buildDetailUrlForSystem(option);
        return $http.get(url);
    }
    var path = "tenant/options", pathReadOnly = "tenant/security-options", pathSystem = "tenant/system/options", config = {
        headers: c8yBase.contentHeaders("option")
    };
    return {
        list: list,
        detail: detail,
        updateOption: updateOption,
        createOption: createOption,
        deleteOption: deleteOption,
        getSystemOption: getSystemOption
    };
} ]), angular.module("c8y.core").factory("c8yStatement", [ "$http", "$q", "$timeout", "c8yBase", function($http, $q, $timeout, c8yBase) {
    function clean(statement) {
        return statement = angular.copy(statement), delete statement.id, delete statement.module, 
        statement;
    }
    function isDefaultModule(module) {
        return "default" === module.name;
    }
    function toId(id) {
        return angular.isObject(id) ? id.id : id;
    }
    function buildStatementUrl(id) {
        return c8yBase.url(path + "/" + defaultModule.id + "/statements" + (id ? "/" + toId(id) : ""));
    }
    function ensureDefaultModule(callback) {
        return function(param) {
            var success, fail, deferred = $q.defer();
            return deferred.promise.then(function() {
                callback(param).success(success).error(fail);
            }), defaultModule ? deferred.resolve() : $http.get(c8yBase.url(path)).success(function(modules) {
                for (var idx in modules.modules) {
                    var module = modules.modules[idx];
                    if (isDefaultModule(module)) return defaultModule = module, void deferred.resolve();
                }
                $http.post(c8yBase.url(path), {
                    name: "default"
                }, moduleConfig()).success(function(module) {
                    defaultModule = module, deferred.resolve();
                });
            }), {
                then: function(s, e) {
                    success = s, fail = e;
                },
                success: function(s) {
                    return success = s, this;
                },
                error: function(e) {
                    return fail = e, this;
                }
            };
        };
    }
    var defaultModule, exports = {}, path = "cep/modules", moduleConfig = function() {
        return c8yBase.requestConfig("cepModule", "cepModule");
    }, statementConfig = function() {
        return c8yBase.requestConfig("cepStatement", "cepStatement");
    }, examples = [ {
        name: "select temperate readings over 100 degree",
        value: 'select * from MeasurementCreated e\nwhere getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
    }, {
        name: "create alarm when temperature over 100 degree",
        value: 'insert into CreateAlarm \n  select\n    e.measurement.time as time,\n    e.measurement.source.value as source,\n    "com_cumulocity_TemperatureAlert" as type,\n    "Temperature too high" as text,\n    "ACTIVE" as status,\n    "CRITICAL" as severity\n  from MeasurementCreated e\n  where getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
    }, {
        name: "create alarm when temperature below 0 degree",
        value: 'insert into CreateAlarm \n  select\n    e.measurement.time as time,\n    e.measurement.source.value as source,\n    "com_cumulocity_TemperatureAlert" as type,\n    "Temperature too low" as text,\n    "ACTIVE" as status,\n    "CRITICAL" as severity\n  from MeasurementCreated e\n  where getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
    }, {
        name: "create close replay operation when temperature readings over 100 degree",
        value: 'insert into CreateOperation\n  select\n    "PENDING" as status,\n    heating ID as deviceId\n    {\n      "c8y_Relay.relayState", "CLOSED"\n    } as fragments\n  from MeasurementCreated e\n  where getNumber(e, "c8y_TemperatureMeasurement.T.value") > 100'
    }, {
        name: "select location change event once for 60 seconds",
        value: 'select * from EventCreated e\nwhere getObject(e, "c8y_LocationMeasurement") is not null\noutput first every 60 seconds'
    }, {
        name: "send email notification with current temperature",
        value: 'expression string js:prepareEmailText(temp, state) [\n    function format(text, params){\n            for(param in params) {\n                text = text.replace("{" + param + "}", params[param])\n            }\n        return text\n    }\n    format("Hello,\\n current temperature is {0} (state = {1}). Regards.", [temp, state])\n]\ninsert into SendEmail\nselect\n  "sender@sender" as sender,\n  "receiver@receiver" as receiver,\n  "Temperature critical!" as subject,\n  prepareEmailText(\n    getNumber(e, "c8y_TemperatureMeasurement.T.value"),\n    getString(e, "c8y_TemperatureMeasurement.T.state")\n   ) as text\nfrom MeasurementCreated e'
    }, {
        name: "change the severities of alarms based on activity time",
        value: '/* Create "context" - definition of a group of events to be processed separately.\n * Context "Alarms" consists of AlarmCreated and AlarmUpdated: \n * with the same source and type = "power off". */\ncreate context Alarms partition by \nalarm.source from AlarmCreated(alarm.type = "power off"),\nalarm.source from AlarmUpdated(alarm.type = "power off");\n\n/* Update severity for all active AlarmCreated \n * after which there is no change to other status in 15 minutes. */\ncontext Alarms \ninsert into UpdateAlarm \nselect \n   a.alarm.id as id,\n   "MAJOR" as severity\nfrom pattern [\n   every a = AlarmCreated(alarm.status = CumulocityAlarmStatuses.ACTIVE) \n   -> (timer:interval(15 minutes) \n      and not AlarmUpdated(alarm.status != CumulocityAlarmStatuses.ACTIVE))\n];'
    } ];
    return exports.list = ensureDefaultModule(function(filters) {
        return $http.get(c8yBase.url(path + "/" + defaultModule.id + "/statements"), filters);
    }), exports.detail = ensureDefaultModule(function(id) {
        return $http.get(buildStatementUrl(id));
    }), exports.remove = ensureDefaultModule(function(statement) {
        return $http["delete"](buildStatementUrl(statement.id));
    }), exports.save = ensureDefaultModule(function(statement) {
        var request, id = statement.id;
        return request = id ? $http.put(buildStatementUrl(id), clean(statement), statementConfig()) : $http.post(buildStatementUrl(), clean(statement), statementConfig());
    }), exports.examples = function() {
        return {
            success: function(callback) {
                $timeout(function() {
                    callback(examples);
                });
            }
        };
    }, exports;
} ]), angular.module("c8y.core").factory("c8yStatistics", [ "c8yBase", "$http", function(c8yBase, $http) {
    function getSummary(params) {
        var url = c8yBase.url(path + "/summary"), cfg = {
            params: params
        };
        return $http.get(url, cfg);
    }
    function list(filters) {
        var url = c8yBase.url(path + "/allTenantsSummary"), cfg = {
            params: c8yBase.timeOrderFilter(c8yBase.pageSizeNoTotalFilter(filters))
        };
        return $http.get(url, cfg).then(c8yBase.getResData);
    }
    var path = "tenant/statistics";
    return {
        getSummary: getSummary,
        list: list
    };
} ]), angular.module("c8y.core").factory("c8yUser", [ "$http", "$q", "$timeout", "c8yBase", "info", "c8yAuth", function($http, $q, $timeout, c8yBase, info, c8yAuth) {
    function applyTenant(url, tenant) {
        return url.replace(/{tenant}/g, tenant);
    }
    function clean(user) {
        return user = angular.copy(user), user.id && delete user.userName, delete user.id, 
        delete user.self, delete user.effectiveRoles, user;
    }
    function buildUserUrl(user) {
        var _id = user.id || user;
        return buildUsersUrl().then(function(url) {
            return url + "/" + _id;
        });
    }
    function buildCurrentUserUrl() {
        return $q.when(c8yBase.url(currentUserPath));
    }
    function buildUsersUrl() {
        return current().then(function(user) {
            return c8yBase.url(applyTenant(path, user.tenant));
        });
    }
    function getTenantFromSelf(url) {
        var FIND_TENANT = /\/user\/(\w+)\//, match = url.match(FIND_TENANT);
        if (match.length < 2) throw new Error("Cannot find tenant on user self URL");
        return match[1];
    }
    function current(forceUpdate) {
        var output, url = currentUserPath, cfg = angular.copy(configCurrentUser);
        return forceUpdate && (currentUser = null), output = currentUser && !angular.isFunction(currentUser.then) ? $q.when(currentUser) : currentUser = currentUser || $http.get(c8yBase.url(url), cfg).then(function(res) {
            return currentUser = res.data, currentUser.tenant = getTenantFromSelf(currentUser.self), 
            currentUser;
        }, function() {
            return currentUser = null, $q.reject();
        });
    }
    function list(filter) {
        var _filter = c8yBase.pageSizeFilter(filter), cfg = {
            params: _filter
        }, onList = c8yBase.cleanListCallback("users", list, _filter);
        return buildUsersUrl().then(function(url) {
            return $http.get(url, cfg).then(onList);
        });
    }
    function detail(user, silentError) {
        var cfg = {
            silentError: !!silentError
        };
        return buildUserUrl(user).then(function(url) {
            return $http.get(url, cfg);
        });
    }
    function detailCurrent() {
        var url = c8yBase.url(currentUserPath), cfg = angular.copy(configCurrentUser);
        return $http.get(url, cfg);
    }
    function remove(user) {
        return buildUserUrl(user).then(function(url) {
            return $http["delete"](url);
        });
    }
    function create(user) {
        var data = clean(user), cfg = angular.copy(config);
        return buildUsersUrl().then(function(url) {
            return $http.post(url, data, cfg);
        });
    }
    function update(user, isCurrent) {
        var data = clean(user), cfg = angular.copy(config), url = isCurrent ? buildCurrentUserUrl() : buildUserUrl(user);
        return url.then(function(url) {
            return $http.put(url, data, cfg);
        });
    }
    function save(user) {
        var action = user.id ? update(user) : create(user);
        return action.then(function() {
            updateToken(user);
        }), action;
    }
    function saveCurrent(user) {
        return update(user, !0).then(function() {
            updateToken(user);
        });
    }
    function updateToken(user) {
        checkIfCurrent(user).then(function(isCurrent) {
            isCurrent && c8yAuth.updatePassword(getPassword(user));
        });
    }
    function checkIfCurrent(user) {
        var userId = user.id || user;
        return current().then(function(currentUser) {
            return $q.when(currentUser.id === userId);
        });
    }
    function getPassword(user) {
        var token = c8yAuth.decodeToken(info.token);
        return user.password || token.password;
    }
    function isCurrentPassword(password) {
        var token = c8yAuth.decodeToken(info.token);
        return token.password === password;
    }
    function groups(user) {
        var _groups = user.groups && user.groups.references || [];
        return _groups.map(function(ref) {
            return ref.group;
        });
    }
    function isDeviceUser(user) {
        return user.id.match(/^device_/);
    }
    function hasRole(user, roleId) {
        var result = hasRoleInUser(user, roleId);
        return result || (result = hasRoleInGroups(user, roleId)), result;
    }
    function hasRoleInUser(user, roleId) {
        var result = !1;
        return user.roles && user.roles.references && angular.forEach(user.roles.references, function(ref) {
            ref.role.id === roleId && (result = !0);
        }), result;
    }
    function hasRoleInGroups(user, roleId) {
        var result = !1;
        return user.groups && user.groups.references && angular.forEach(user.groups.references, function(groupRef) {
            angular.forEach(groupRef.group.roles.references, function(roleRef) {
                roleRef.role.id === roleId && (result = !0);
            });
        }), result;
    }
    function getDevicePermissions(user, deviceId) {
        var _filter = c8yBase.pageSizeFilter({
            moId: deviceId
        }), cfg = {
            params: _filter
        };
        return buildUserUrl(user).then(function(url) {
            return $http.get(url + "/devicePermissions", cfg);
        });
    }
    function login(tenant, username, password, remember) {
        return $q.when(getToken(tenant, username, password)).then(_.partial(confirmToken, remember));
    }
    function logout() {
        deleteToken(), currentUser = null, info.token = null;
    }
    function getToken(tenant, username, password) {
        return btoa((tenant ? tenant + "/" : "") + username + ":" + password);
    }
    function confirmToken(remember, _token) {
        return info.token = _token, $http.get(c8yBase.url(currentUserPath), {
            headers: getHeaders(_token)
        }).then(function(res) {
            return info.token = _token, setToken(_token, remember), res.data;
        }, function() {
            deleteToken();
        });
    }
    function setToken(_token, remember) {
        remember ? window.localStorage.setItem("_tcy8", _token) : window.sessionStorage.setItem("_tcy8", _token);
    }
    function deleteToken() {
        var TOKEN = "_tcy8";
        window.localStorage.removeItem(TOKEN), window.sessionStorage.removeItem(TOKEN);
    }
    function isAdmin(user) {
        var admin = _.some(user.groups.references, function(ref) {
            return "admins" === ref.group.name;
        });
        return admin;
    }
    function getHeaders(token) {
        var t = token || info.token;
        return {
            Authorization: "Basic " + t,
            UseXBasic: !0,
            Accept: "application/vnd.com.nsn.cumulocity.user+json;"
        };
    }
    var path = "user/{tenant}/users", currentUserPath = "user/currentUser", currentUser = null, config = {
        headers: c8yBase.contentHeaders("user", !0)
    }, configCurrentUser = {
        headers: c8yBase.contentHeaders("user", !0)
    };
    return {
        current: current,
        checkIfCurrent: checkIfCurrent,
        list: list,
        detail: detail,
        detailCurrent: detailCurrent,
        remove: remove,
        save: save,
        saveCurrent: saveCurrent,
        groups: groups,
        isDeviceUser: isDeviceUser,
        hasRole: hasRole,
        getDevicePermissions: getDevicePermissions,
        login: login,
        logout: logout,
        isAdmin: isAdmin,
        isCurrentPassword: isCurrentPassword
    };
} ]), angular.module("c8y.core").factory("c8yUserGroup", [ "$http", "$q", "c8yBase", "c8yUser", function($http, $q, c8yBase, c8yUser) {
    function buildGroupsUrl() {
        return c8yUser.current().then(function(user) {
            var tenant = user.tenant;
            return c8yBase.url(basePath + tenant + "/groups");
        });
    }
    function buildRolesUrl() {
        return $q.when(c8yBase.url(basePath + "roles"));
    }
    function buildGroupUrl(group) {
        var groupId = group.id || group;
        return c8yUser.current().then(function(user) {
            var tenant = user.tenant;
            return c8yBase.url(basePath + tenant + "/groups/" + groupId);
        });
    }
    function buildGroupUsersUrl(group, user) {
        return buildGroupUrl(group).then(function(url) {
            return url + "/users" + (user ? "/" + (user.id || user) : "");
        });
    }
    function buildGroupRolesUrl(group) {
        return buildGroupUrl(group).then(function(url) {
            return url + "/roles";
        });
    }
    function buildGroupRoleUrl(group, role) {
        var roleId = role.id || role;
        return buildGroupRolesUrl(group).then(function(url) {
            return url + "/" + roleId;
        });
    }
    function list(filters) {
        var _filter = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filter
        }, onList = c8yBase.cleanListCallback("groups", list, _filter);
        return buildGroupsUrl().then(function(url) {
            return $http.get(url, cfg).then(onList);
        });
    }
    function detail(group) {
        return buildGroupUrl(group).then(function(url) {
            return $http.get(url);
        });
    }
    function remove(group) {
        return buildGroupUrl(group).then(function(url) {
            return $http["delete"](url);
        });
    }
    function update(group) {
        var cfg = {
            headers: c8yBase.contentHeaders("group")
        };
        return buildGroupUrl(group).then(function(url) {
            return $http.put(url, group, cfg).then(function() {
                return group;
            });
        });
    }
    function create(group) {
        var cfg = {
            headers: c8yBase.contentHeaders("group")
        };
        return buildGroupsUrl().then(function(url) {
            return $http.post(url, group, cfg).then(function(res) {
                var location = res.headers("location"), id = location.match(/\d+$/)[0];
                return detail(id).then(function(res) {
                    return res.data;
                });
            });
        });
    }
    function save(group) {
        return group.id ? update(group) : create(group);
    }
    function listRoles(filters) {
        var _filter = c8yBase.pageSizeFilter(filters), cfg = {
            params: _filter,
            cache: !0
        }, onList = c8yBase.cleanListCallback("roles", listRoles, _filter);
        return buildRolesUrl().then(function(url) {
            return $http.get(url, cfg).then(onList);
        });
    }
    function findRole(roleId) {
        return listRoles().then(function(roles) {
            var selRole;
            return roles.forEach(function(role) {
                return role.id === roleId ? (selRole = role, !1) : void 0;
            }), selRole;
        });
    }
    function addUserToGroup(group, user) {
        var data = {
            user: user
        };
        return buildGroupUsersUrl(group).then(function(url) {
            return $http.post(url, data);
        });
    }
    function removeUserFromGroup(group, user) {
        return buildGroupUsersUrl(group, user).then(function(url) {
            return $http["delete"](url);
        });
    }
    function updateGroups(user, groupIds) {
        var references = user && user.groups && user.groups.references || [], userGroupsIds = references.map(function(ref) {
            return ref.group.id;
        }), actions = [];
        return groupIds.forEach(function(groupId) {
            -1 === userGroupsIds.indexOf(groupId) && actions.push(addUserToGroup(groupId, user));
        }), userGroupsIds.forEach(function(groupId) {
            -1 === groupIds.indexOf(groupId) && actions.push(removeUserFromGroup(groupId, user));
        }), $q.all(actions);
    }
    function addRoleToGroup(group, role) {
        var cfg = {
            headers: c8yBase.contentHeaders("roleReference")
        };
        return buildGroupRolesUrl(group).then(function(url) {
            return $http.post(url, {
                role: role
            }, cfg);
        });
    }
    function removeRoleFromGroup(group, role) {
        return buildGroupRoleUrl(group, role).then(function(url) {
            return $http["delete"](url);
        });
    }
    function updateRoles(group, roleIds) {
        var groupRoleIds = group.roles.references.map(function(ref) {
            return ref.role.id;
        }), actions = [];
        return roleIds.forEach(function(roleId) {
            -1 === groupRoleIds.indexOf(roleId) && actions.push(findRole(roleId).then(function(role) {
                return addRoleToGroup(group, role);
            }));
        }), groupRoleIds.forEach(function(roleId) {
            -1 === roleIds.indexOf(roleId) && actions.push(removeRoleFromGroup(group, roleId));
        }), $q.all(actions);
    }
    var basePath = "user/";
    return {
        list: list,
        detail: detail,
        remove: remove,
        create: create,
        update: update,
        save: save,
        listRoles: listRoles,
        updateGroups: updateGroups,
        updateRoles: updateRoles
    };
} ]), angular.module("c8y.core").factory("c8yRealtime", [ "$http", "$rootScope", "$timeout", "c8yBase", "info", function($http, $rootScope, $timeout, c8yBase, info) {
    function initConnection() {
        cometd.isDisconnected() && !restartConnection && (disconnecting ? restartConnection = function() {
            cometd.handshake();
        } : cometd.handshake());
    }
    function newAbortConnectionTimer() {
        return $timeout(function() {
            cometd.getTransport().abort();
        }, timeout);
    }
    function subscribe(channel) {
        if (cometd.isDisconnected()) return initConnection(), void subscriptionQueue.push(channel);
        var subObj = cometd.subscribe(channel, function(msg) {
            var scope = subscriptionMap[channel].scope;
            scope.$emit(msg.data.realtimeAction, msg.data.data), abortConnection && ($timeout.cancel(), 
            abortConnection = newAbortConnectionTimer()), apply();
        });
        return abortConnection = newAbortConnectionTimer(), subscriptionMap[channel].subObj || (subscriptionMap[channel].subObj = subObj), 
        subObj;
    }
    function unsubscribe(subObj) {
        subObj && cometd.unsubscribe(subObj);
    }
    function apply() {
        $rootScope.$$phase || $rootScope.$apply();
    }
    function switchRealtime(id, channel) {
        subscriptionMap[channel].subscribers[id].active ? stop(id, channel) : start(id, channel);
    }
    function getIcon(status) {
        return icons[status];
    }
    function getSubscriptionMap() {
        return subscriptionMap;
    }
    function getRealtimeActions() {
        return realtimeActions;
    }
    function getStatus(id, channel) {
        var channelObj = subscriptionMap[channel];
        if (void 0 === channelObj) return !1;
        var subscriber = channelObj.subscribers[id];
        return subscriber && subscriber.hasOwnProperty("active") ? subscriber.active : !1;
    }
    function removeSubscriber(id, channel) {
        if (getStatus(id, channel) === !1) throw new Error('There is no listener registered for your scope on the channel "' + channel + '"');
        stop(id, channel), delete subscriptionMap[channel].subscribers[id], 0 === Object.keys(subscriptionMap[channel].subscribers).length && (subscriptionMap[channel].scope.$destroy(), 
        delete subscriptionMap[channel]);
    }
    function init(id, channel) {
        subscriptionMap[channel] || (subscriptionMap[channel] = {
            scope: $rootScope.$new(!0),
            subscribers: {},
            activeSubscribers: 0,
            subObj: void 0,
            ready: !1
        }), subscriptionMap[channel].subscribers[id] = {
            listeners: [],
            unreg: void 0
        };
    }
    function addListener(id, channel, watch, func) {
        subscriptionMap[channel] && subscriptionMap[channel].subscribers[id] || init(id, channel), 
        subscriptionMap[channel].subscribers[id].listeners.push({
            watch: watch,
            func: func
        });
    }
    function start(id, channel) {
        if (void 0 === subscriptionMap[channel]) throw new Error('There is no listener registered for your scope on the channel "' + channel + '"');
        var scope = subscriptionMap[channel].scope, listeners = subscriptionMap[channel].subscribers[id].listeners, unreg = [];
        for (var listener in listeners) unreg.push({
            watch: listeners[listener].watch,
            func: scope.$on(listeners[listener].watch, listeners[listener].func)
        });
        subscriptionMap[channel].subscribers[id].unreg = unreg, subscriptionMap[channel].subscribers[id].active = !0, 
        0 === subscriptionMap[channel].activeSubscribers ? subscribe(channel) : subscriptionMap[channel].ready && scope.$emit(id + "-subscribed"), 
        subscriptionMap[channel].activeSubscribers++;
    }
    function stop(id, channel) {
        var unsub, scope = subscriptionMap[channel].scope, unreg = subscriptionMap[channel].subscribers[id].unreg;
        void 0 !== unreg && unreg.forEach(function(element) {
            element.watch === id + "-unsubscribed" ? unsub = element.func : element.func();
        }), unsub && (scope.$emit(id + "-unsubscribed"), unsub()), subscriptionMap[channel].subscribers[id].unreg = void 0, 
        subscriptionMap[channel].subscribers[id].active = !1, subscriptionMap[channel].activeSubscribers--, 
        subscriptionMap[channel].activeSubscribers <= 0 && (subscriptionMap[channel].subObj && (unsubscribe(subscriptionMap[channel].subObj), 
        subscriptionMap[channel].subObj = void 0, subscriptionMap[channel].ready = !1), 
        subscriptionMap[channel].activeSubscribers = 0);
    }
    function destroySubscription(id, channel) {
        getStatus(id, channel) === !0 && removeSubscriber(id, channel);
    }
    var abortConnection, disconnecting, restartConnection, lastConnect, path = "cep/realtime", config = {
        url: c8yBase.url(path),
        logLevel: "info",
        requestHeaders: {
            Authorization: "Basic " + info.token,
            UseXBasic: !0
        },
        appendMessageTypeToURL: !1
    }, timeout = 57e4, overallSubscriptions = 0, subscriptionQueue = [], cometd = new $.Cometd(), icons = {}, subscriptionMap = {}, realtimeActions = {
        CREATE: "CREATE",
        UPDATE: "UPDATE",
        DELETE: "DELETE"
    }, bus = $rootScope.$new(!0);
    return icons[!0] = "check-circle-o", icons[!1] = "circle-o", cometd.unregisterTransport("websocket"), 
    cometd.configure(config), cometd.addListener("/meta/connect", function(data) {
        subscriptionQueue.forEach(function(s) {
            subscribe(s);
        }), subscriptionQueue.length = 0, data.successful ? (lastConnect && bus.$emit("connect", {
            fromLastConnect: moment().diff(lastConnect, "seconds")
        }), lastConnect = moment()) : bus.$emit("connectfailure", data);
    }), cometd.addListener("/meta/disconnect", function() {
        disconnecting = !1, "function" == typeof restartConnection && (restartConnection(), 
        restartConnection = void 0);
    }), cometd.addListener("/meta/subscribe", function(msg) {
        if (msg.successful) {
            var scope = subscriptionMap[msg.subscription].scope, subscribers = subscriptionMap[msg.subscription].subscribers;
            subscriptionMap[msg.subscription].ready = !0, overallSubscriptions++;
            for (var id in subscribers) subscribers[id].active && scope.$emit(id + "-subscribed");
            apply();
        } else cometd.isDisconnected() || 0 !== overallSubscriptions || (cometd.disconnect(), 
        disconnecting = !0);
    }), cometd.addListener("/meta/unsubscribe", function() {
        overallSubscriptions--, cometd.isDisconnected() || 0 !== overallSubscriptions || (abortConnection && ($timeout.cancel(abortConnection), 
        abortConnection = void 0), cometd.disconnect(), disconnecting = !0);
    }), {
        start: start,
        stop: stop,
        bus: function() {
            return bus;
        },
        addListener: addListener,
        removeSubscriber: removeSubscriber,
        switchRealtime: switchRealtime,
        icon: getIcon,
        getStatus: getStatus,
        realtimeActions: getRealtimeActions,
        destroySubscription: destroySubscription,
        getSubscriptionMap: getSubscriptionMap
    };
} ]), angular.module("c8y.core").factory("c8ySimulator", [ "$http", "c8yBase", function($http, c8yBase) {
    function list() {
        var simulatorUrl = c8yBase.url(configPath);
        return $http.get(simulatorUrl).then(c8yBase.getResData);
    }
    function changeState(simulator, newstate) {
        var id = simulator.id || simulator, url = c8yBase.url(configPath + "/" + id), data = {
            state: newstate
        }, cfg = angular.copy(defaultConfigSimulator);
        return $http.put(url, data, cfg);
    }
    function deleteSimulator(simulator) {
        var id = simulator.id || simulator, url = c8yBase.url(configPath + "/" + id), cfg = angular.copy(defaultConfigSimulator);
        return $http["delete"](url, cfg);
    }
    function getSensors() {
        var sensorsUrl = c8yBase.url(sensorsPath);
        return $http.get(sensorsUrl).then(c8yBase.getResData);
    }
    function createTemplate(template) {
        var url = c8yBase.url(templatePath), data = angular.copy(template), cfg = angular.copy(defaultConfigTemplate);
        return $http.post(url, data, cfg);
    }
    function createSimulator(simulator) {
        var url = c8yBase.url(configPath), data = angular.copy(simulator), cfg = angular.copy(defaultConfigSimulator);
        return $http.post(url, data, cfg);
    }
    var templatePath = "simulator/templates", configPath = "simulator/configurations", sensorsPath = templatePath + "/sensors", defaultConfigSimulator = {
        headers: c8yBase.contentHeaders("simulator", "simulator")
    }, defaultConfigTemplate = {
        headers: c8yBase.contentHeaders("template", "template")
    };
    return {
        list: list,
        changeState: changeState,
        deleteSimulator: deleteSimulator,
        createSimulator: createSimulator,
        createTemplate: createTemplate,
        getSensors: getSensors
    };
} ]), angular.module("c8y.core").factory("c8yKpi", [ "$q", "c8yInventory", "c8yMeasurements", "c8yDevices", "c8yUser", "c8yBase", "c8yAlert", "c8yBatchOp", function($q, c8yInventory, c8yMeasurements, c8yDevices, c8yUser, c8yBase, c8yAlert, c8yBatchOp) {
    function list() {
        return c8yInventory.list({
            fragmentType: FRAG
        }).then(filterOld);
    }
    function listByIds(ids) {
        return list().then(function(kpis) {
            return ids && ids.length ? _.filter(kpis, function(kpi) {
                return ids.indexOf(kpi.id) > -1;
            }) : kpis;
        });
    }
    function isPureKpi(mo) {
        var allowedKeys = [ "assetParents", FRAG, "childAssets", "childDevices", "deviceParents", "id", "lastUpdated", "owner", "self" ], keys = Object.keys(mo);
        return _.every(keys, function(key) {
            return allowedKeys.indexOf(key) > -1;
        });
    }
    function filterOld(managedObjects) {
        var defer = $q.defer(), oldDevices = _.filter(managedObjects, function(mo) {
            return !isPureKpi(mo) && !mo.c8y_Kpi_Migrated;
        }), standaloneKpi = _.pluck(_.filter(managedObjects, isPureKpi, FRAG));
        if (oldDevices.length) {
            var modal, kpisToCreate = _.map(_.reduce(_.flatten(_.pluck(oldDevices, FRAG)), _.partial(uniqueKpi, standaloneKpi), []), function(k) {
                var mo = {};
                return mo[FRAG] = k, _.partial(c8yInventory.save, mo);
            }), devicesWithKpi = _.map(oldDevices, function(dev) {
                return _.partial(migrateKpi, dev);
            }), ops = _.flatten([ kpisToCreate, devicesWithKpi ]), promise = $q.when();
            c8yUser.current().then(function(user) {
                c8yUser.hasRole(user, "ROLE_INVENTORY_ADMIN") && (modal = c8yBatchOp.run(ops, "Migrating KPIs to new data model"), 
                promise = modal.result.then(function(result) {
                    return "complete" === result ? list() : void c8yAlert.danger("Failed to migrate KPIs to new data model!");
                }));
            }), defer.resolve(promise);
        } else defer.resolve(_.filter(managedObjects, isPureKpi));
        return defer.promise;
    }
    function matchKpi(list, kpi) {
        return _.find(list, function(k) {
            return k.fragment === kpi.fragment && k.series === kpi.series && k.unit === kpi.unit && k.label === kpi.label;
        });
    }
    function uniqueKpi(existingList, list, kpi) {
        var found = matchKpi(existingList, kpi) || matchKpi(list, kpi);
        return !found && kpi.fragment && kpi.series && list.push(kpi), list;
    }
    function migrateKpi(managedObject) {
        var mo = {
            id: managedObject.id,
            c8y_Kpi_Migrated: !0
        };
        return c8yInventory.save(mo);
    }
    function detail(id) {
        return c8yInventory.detail(id).then(function(res) {
            var data = res.data.c8y_Kpi;
            return _.forEach(FLOAT_FIELDS, function(field) {
                angular.isDefined(data[field]) && (data[field] = parseFloat(data[field]), isNaN(data[field]) && delete data[field]);
            }), res;
        });
    }
    function deviceSeriesList(deviceId) {
        var from = moment().subtract(1, "month").format(c8yBase.dateFormat), aggregation = "DAILY";
        return c8yMeasurements.listSeries({
            source: deviceId,
            dateFrom: from,
            aggregationType: aggregation
        }).then(function(obj) {
            return _.map(obj.series, function(def) {
                return {
                    fragment: def.type,
                    series: def.name
                };
            });
        });
    }
    function listKpiForDevice(device) {
        var deviceId = device.id || device;
        return $q.all([ list(), deviceSeriesList(deviceId) ]).then(function(promises) {
            var kpis = promises[0], series = promises[1], matchKpi = _.filter(kpis, function(k) {
                return _.find(series, {
                    fragment: k.c8y_Kpi.fragment,
                    series: k.c8y_Kpi.series
                });
            }), nonKpiSeries = _.filter(series, function(s) {
                return !_.find(kpis, function(k) {
                    return k.c8y_Kpi.fragment === s.fragment && k.c8y_Kpi.series === s.series;
                });
            });
            return {
                matchKpi: matchKpi,
                nonKpiSeries: nonKpiSeries
            };
        });
    }
    function onMeasurement(kpi, measurement) {
        var data = (measurement || {})[kpi.fragment] || {};
        return data.kpi = kpi, data.time = (measurement || {}).time, data.source = (measurement || {}).source, 
        data;
    }
    function getMeasurement(_kpi, device, overRidePageSize) {
        var kpi = _kpi.c8y_Kpi || _kpi;
        return c8yMeasurements.list(angular.extend(c8yBase.timeOrderFilter(), {
            revert: !0,
            fragmentType: kpi.fragment,
            source: device,
            pageSize: overRidePageSize || 10
        })).then(function(measurements) {
            return _.find(measurements, function(m) {
                var frag = m[_kpi.fragment];
                return frag && angular.isDefined(frag[_kpi.series]);
            });
        }).then(_.partial(onMeasurement, kpi));
    }
    var FRAG = "c8y_Kpi", FLOAT_FIELDS = [ "target", "min", "max", "yellowRangeMin", "yellowRangeMax", "redRangeMin", "redRangeMax" ];
    return {
        list: list,
        listByIds: listByIds,
        detail: detail,
        remove: c8yInventory.remove,
        save: c8yInventory.save,
        listKpiForDevice: listKpiForDevice,
        getMeasurement: getMeasurement
    };
} ]), angular.module("c8y.core").factory("c8yDeviceShell", [ "$http", "$q", "c8yBase", function($http, $q, c8yBase) {
    function getCommandTemplatesForDeviceType(deviceType) {
        var url = getCommandTemplatesUrl(deviceType);
        return $http.get(url).then(c8yBase.getResData).then(_.partial(extractCommandTemplatesFromData, deviceType));
    }
    function getCommandTemplatesUrl(deviceType) {
        var commandTemplatesBaseUrl = "/apps/c8ydata/devicecommands/";
        return commandTemplatesBaseUrl + deviceType + ".json";
    }
    function extractCommandTemplatesFromData(deviceType, data) {
        var templates;
        return templates = angular.isArray(data) ? _.chain(data).map(function(d) {
            return getExtendedTemplates(d.templates, d.syntax, deviceType);
        }).flatten().value() : getExtendedTemplates(data.templates, data.syntax, deviceType), 
        $q.when(templates);
    }
    function getExtendedTemplates(templates, syntax, deviceType) {
        return _.map(templates || [], function(t) {
            return angular.extend(t, {
                syntax: syntax,
                deviceType: deviceType
            });
        });
    }
    return {
        getCommandTemplatesForDeviceType: getCommandTemplatesForDeviceType
    };
} ]), function() {
    function c8yUtil(c8yBase) {
        function dateToString(date) {
            return date && moment(date).format(c8yBase.dateFormat);
        }
        function stringToDate(date) {
            return date && moment(date).toDate();
        }
        return {
            dateToString: dateToString,
            stringToDate: stringToDate
        };
    }
    angular.module("c8y.core").factory("c8yUtil", [ "c8yBase", c8yUtil ]);
}(), angular.module("c8y.core").factory("c8ySystem", [ "$http", "$q", "c8yBase", "$window", function($http, $q, c8yBase, $window) {
    function getBackendVersion() {
        var url = c8yBase.url(path);
        return $http.get(url).then(c8yBase.getResData);
    }
    function getUIVersion() {
        return $q.when($window.UI_VERSION || "dev");
    }
    var path = "tenant/system/options/system/version";
    return {
        getBackendVersion: getBackendVersion,
        getUIVersion: getUIVersion
    };
} ]), function() {
    function c8yRetentions($http, $q, c8yBase) {
        function list(filters) {
            var url = c8yBase.url(path);
            filters = c8yBase.pageSizeFilter(filters);
            var cfg = {
                params: filters,
                silentError: !0
            }, onList = c8yBase.cleanListCallback("retentionRules", list, filters);
            return $http.get(url, cfg).then(onList, $q.reject);
        }
        function detail(ro) {
            var url = buildDetailUrl(ro);
            return url ? $http.get(url) : $q.reject("Retention rule object is not valid");
        }
        function create(ro) {
            var url = c8yBase.url(path);
            return $http.post(url, ro, defaultConfig);
        }
        function update(ro) {
            var url = buildDetailUrl(ro);
            return $http.put(url, ro, defaultConfig);
        }
        function save(ro) {
            return ro.id ? update(ro) : create(ro);
        }
        function remove(ro) {
            var url = buildDetailUrl(ro);
            return url ? $http["delete"](url) : $q.reject("Retention rule object is not valid");
        }
        function buildDetailUrl(ro) {
            var id = ro && ro.id || ro;
            if (id) return c8yBase.url(path + "/" + id);
        }
        var path = "retention/retentions", defaultConfig = {
            headers: {
                "Content-Type": "application/json"
            }
        }, dataTypes = [ "ALARM", "EVENT", "MEASUREMENT", "OPERATION", "AUDIT", "*" ];
        return {
            list: list,
            detail: detail,
            create: create,
            update: update,
            save: save,
            remove: remove,
            dataTypes: dataTypes
        };
    }
    angular.module("c8y.core").factory("c8yRetentions", [ "$http", "$q", "c8yBase", c8yRetentions ]);
}(), function() {
    function c8yBaseUrl(info) {
        function link(scope, elem, attrs) {
            info.baseUrl = attrs.c8yBaseUrl;
        }
        return {
            restrict: "A",
            link: link
        };
    }
    angular.module("c8y.core").directive("c8yBaseUrl", [ "info", c8yBaseUrl ]);
}(), function() {
    function c8yLogin(c8yCumulocity) {
        function link(scope, elem) {
            elem.bind("click", function() {
                c8yCumulocity.login(scope.tenant(), scope.user(), scope.password(), scope.rememberMe()).then(scope.onSuccess)["catch"](scope.onFailure);
            });
        }
        return {
            restrict: "A",
            link: link,
            scope: {
                tenant: "&",
                user: "&",
                password: "&",
                rememberMe: "&",
                onSuccess: "&",
                onFailure: "&"
            }
        };
    }
    angular.module("c8y.core").directive("c8yLogin", [ "c8yCumulocity", c8yLogin ]);
}(), function() {
    function c8yLogout(c8yCumulocity) {
        function link(scope, elem) {
            elem.bind("click", function() {
                c8yCumulocity.logout(), scope.ngClick();
            });
        }
        return {
            priority: 1,
            terminal: !0,
            restrict: "A",
            link: link,
            scope: {
                ngClick: "&"
            }
        };
    }
    angular.module("c8y.core").directive("c8yLogout", [ "c8yCumulocity", c8yLogout ]);
}(), function() {
    function c8yRepeat($injector, $compile, $rootScope) {
        function compile(elem, attrs) {
            function replaceWithNgRepeat() {
                var regex = /^\s*([^\s]+)\s*in\s*([^\s]+)\s*/, matches = regex.exec(attrs.c8yRepeat), varName = matches[1];
                serviceName = matches[2], elem.removeAttr("c8y-repeat"), elem.removeAttr("data-c8y-repeat"), 
                elem.attr("ng-repeat", varName + " in __c8y_serviceResult track by " + varName + ".id"), 
                ngRepeatLink = $compile(elem);
            }
            var serviceName, ngRepeatLink;
            return replaceWithNgRepeat(), function(scope, elem, attrs, ctrl, transcludeFn) {
                function assignRefreshFunction() {
                    scope.refresh = fetchResults;
                }
                function fetchResults() {
                    $rootScope.c8y && $rootScope.c8y.user && callService().then(function(result) {
                        parentScope.__c8y_serviceResult = result;
                    });
                }
                function callService() {
                    var filter = scope.filter || {};
                    switch (serviceName) {
                      case "inventory":
                        return $injector.get("c8yInventory").list(filter).then(function(res) {
                            return res.data;
                        });

                      default:
                        return $injector.get("c8y" + capitalize(serviceName)).list(filter);
                    }
                }
                function capitalize(s) {
                    return s[0].toUpperCase() + s.slice(1);
                }
                function init() {
                    parentScope = scope.$parent, ngRepeatLink(parentScope), assignRefreshFunction(), 
                    $rootScope.$on("c8y.api.login", function() {
                        fetchResults();
                    }), scope.$watch("filter", fetchResults, !0);
                }
                var parentScope;
                init();
            };
        }
        return {
            restrict: "A",
            compile: compile,
            transclude: !1,
            scope: {
                filter: "=?",
                refresh: "=?"
            }
        };
    }
    angular.module("c8y.core").directive("c8yRepeat", [ "$injector", "$compile", "$rootScope", c8yRepeat ]);
}();
//# sourceMappingURL=main.js.map